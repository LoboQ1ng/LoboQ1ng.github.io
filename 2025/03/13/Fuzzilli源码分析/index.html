<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Lobo Q1ng">


    <meta name="subtitle" content="天空是为蓝色~">




<title>Fuzzilli源码分析 | Lobo Q1ng&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Q1ng&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Q1ng&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Fuzzilli源码分析</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Lobo Q1ng</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 13, 2025&nbsp;&nbsp;20:09:57</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Fuzz/">Fuzz</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Fuzzilli源码分析"><a href="#Fuzzilli源码分析" class="headerlink" title="Fuzzilli源码分析"></a>Fuzzilli源码分析</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>分析与调试环境为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dog@dog:~/swift/usr/bin$ lldb --version</span><br><span class="line">lldb version 17.0.0 (https://github.com/swiftlang/llvm-project.git revision 3a02857b159678d97e33f8c5032541c3ddd5f1f6)</span><br><span class="line">Swift version 6.2-dev (LLVM 3a02857b159678d, Swift c91e29523420c00)</span><br></pre></td></tr></table></figure>

<p>使用swift编译Fuzzilli时，使用debug模式：<code>swift build -c debug</code>，这种情形下，才能对其进行调试。</p>
<blockquote>
<p>Vscode调试swift项目时会存在BUG，调试时无法获取变量的值，也无法获得任何有用信息。即鼠标悬停在变量时，出现<code>Unable to determine byte size</code>，解决方案：<a target="_blank" rel="noopener" href="https://github.com/vadimcn/codelldb/wiki/Swift">Codelldb Debugging problems</a></p>
</blockquote>
<p>以下是使用vscode调试时的<code>launch.json</code>文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sourceLanguages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;swift&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug swift-executable&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/.build/debug/FuzzilliCli&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;--profile=qjs&quot;</span><span class="punctuation">,</span><span class="string">&quot;Targets/QJS/quickjs/qjs&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;Build for debug&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Fuzzilli-工作原理"><a href="#Fuzzilli-工作原理" class="headerlink" title="Fuzzilli 工作原理"></a>Fuzzilli 工作原理</h2><p>Fuzzilli具有两个主要的模糊测试引擎：Mutation Engine和Hybrid Engine。后者本质上是纯生成组件与现有变异的结合。</p>
<p>在解释这些引擎的工作原理之前，首先解释FuzzIL，这是Fuzzilli构建的基础的自定义中间语言。</p>
<p>可以通过使用<code>--inspect</code>CLI标志来观察文档中描述的所有机制的实际运行情况。如果启用，所有写入磁盘的程序（本质上是语料库中的程序以及Crash）都将有一个额外的.history文件，描述程序的“历史记录”，即为生成程序而执行的确切变异、拼接、代码生成等步骤。</p>
<h3 id="Fuzzilli的目标"><a href="#Fuzzilli的目标" class="headerlink" title="Fuzzilli的目标"></a>Fuzzilli的目标</h3><p>除了生成”interesting”的JavaScript代码这个核心目标外，Fuzzilli还必须处理以下两个问题。</p>
<h4 id="语法正确性"><a href="#语法正确性" class="headerlink" title="语法正确性"></a>语法正确性</h4><p>如果一个程序在语法上无效，它将在引擎中被解析器在处理的早期阶段拒绝。 由于 Fuzzilli 不尝试查找语言解析器中的错误，因此这样的执行将有效地被浪费。 因此，Fuzzilli 致力于实现 100% 的句法正确率。 这是通过使用 FuzzIL（接下来讨论）来构建实现的，FuzzIL 只能表达在语法上有效的 JavaScript 代码。</p>
<h4 id="语义正确性"><a href="#语义正确性" class="headerlink" title="语义正确性"></a>语义正确性</h4><p>在 Fuzzilli 中，引发未捕获异常的程序被认为是语义上不正确的，或简称为无效。 虽然可以将每个（或大多数）语句包装到 try-catch 块中，但这将从根本上改变生成的程序的控制流，从而改变 JIT 编译器的优化方式。 许多 JIT 错误无法通过这样的程序触发。 因此，至关重要的是，Fuzzilli 生成具有相当高程度的语义有效的样本（作为基准，Fuzzilli 应以高于 50% 的正确率为目标）。</p>
<p>这个挑战取决于每个模糊测试引擎，因此将分别针对每个引擎进行讨论。</p>
<h3 id="FuzzIL-中间语言"><a href="#FuzzIL-中间语言" class="headerlink" title="FuzzIL 中间语言"></a>FuzzIL 中间语言</h3><p>源码位于：Sources&#x2F;Fuzzilli&#x2F;FuzzIL</p>
<p>Fuzzilli基于一种名为FuzzIL的自定义中间语言。FuzzIL的设计具有四个核心目标：</p>
<ul>
<li>促进有意义的代码变异</li>
<li>易于静态推理（参见关于类型系统的章节）</li>
<li>易于提升（lift）到JavaScript</li>
<li>确保生成的JavaScript代码的某些正确性属性，例如语法正确性以及在使用变量之前定义变量</li>
</ul>
<p>Fuzzilli 内部专门对 FuzzIL 程序进行操作，并且仅为了执行才将其提升到 JavaScript。 因此，使用 FuzzIL 的高级模糊测试管道如下所示：</p>
<img src="/2025/03/13/Fuzzilli%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20250313210907839.png" class="" title="image-20250313210907839">

<p>提升由 <code>JavaScriptLifter</code> 执行，而 JavaScript 代码的执行通过 REPRL（读取-求值-打印-重置-循环）机制进行，这本质上是 JS 引擎的持久模糊测试的实现，它还提供有关执行是否成功的反馈（如果执行因未捕获的异常而终止，则执行失败）。</p>
<p>FuzzIL 程序可以序列化为 protobuf，这用于将它们存储到磁盘或在分布式模糊测试的情况下通过网络发送它们。 可以使用 <code>FuzzILTool</code> 将 protobuf 格式的 FuzzIL 程序转换为 JavaScript 或 FuzzIL 的文本表示形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift run FuzzILTool --liftToFuzzIL path/to/program.protobuf</span><br></pre></td></tr></table></figure>

<p>FuzzIL 致力于实现大部分自解释性。 例如，一个假想的 FuzzIL 样本可能如下所示</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v0 &lt;- BeginPlainFunctionDefinition -&gt; v1, v2, v3</span><br><span class="line">    v4 &lt;- BinaryOperation v1 &#x27;+&#x27; v2</span><br><span class="line">    SetProperty v3, &#x27;foo&#x27;, v4</span><br><span class="line">EndPlainFunctionDefinition</span><br><span class="line">v5 &lt;- LoadString <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">v6 &lt;- CreateObject [&#x27;bar&#x27;: v5]</span><br><span class="line">v7 &lt;- LoadFloat 13.37</span><br><span class="line">v8 &lt;- CallFunction v0, [v7, v7, v6]</span><br></pre></td></tr></table></figure>

<p>当内联中间表达式时，提升到 JavaScript 代码的同一个程序可能如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f0</span>(<span class="params">a1, a2, a3</span>) &#123;</span><br><span class="line">  a3.<span class="property">foo</span> = a1 + a2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v6 = &#123; <span class="attr">bar</span>: <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">f0</span>(<span class="number">13.37</span>, <span class="number">13.37</span>, v6);</span><br></pre></td></tr></table></figure>

<p>或者，当使用简单的提升算法时，可能如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f0</span>(<span class="params">a1, a2, a3</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> v4 = a1 + a2;</span><br><span class="line">  a3.<span class="property">foo</span> = v4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v5 = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> v6 = &#123; <span class="attr">bar</span>: v5 &#125;;</span><br><span class="line"><span class="keyword">const</span> v7 = <span class="number">13.37</span>;</span><br><span class="line"><span class="keyword">const</span> v8 = <span class="title function_">f0</span>(v7, v7, v6);</span><br></pre></td></tr></table></figure>

<p>最终，使用的提升算法可能并不重要，因为无论代码的语法表示形式如何，JavaScript 引擎的字节码和 JIT 编译器都会产生几乎相同的结果。</p>
<p>FuzzIL 有一个“受保护”操作的概念，这些操作通过 try-catch 保护免受运行时异常的影响。 例如，如果 <code>CallFunction</code> 操作可能合理地引发异常（例如，因为参数类型不正确），则可以将其标记为受保护：<code>CallFunction v3, [v5, v6] (guarded)</code>。 在这种情况下，它将提升到如下所示的 JavaScript 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">v3</span>(v5, v6);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>由于为受保护操作生成的 try-catch 块会对程序的行为产生负面影响（如上所述），因此应谨慎使用它们。 此外，Fuzzilli 尝试在 Minimization 期间以及通过 <code>FixupMutator</code> 将受保护操作转换为不受保护的操作，这两者将在本文档后面进一步讨论。</p>
<p>FuzzIL 具有许多属性：</p>
<ul>
<li>一个 FuzzIL 程序只是一个指令列表。</li>
<li>每个 FuzzIL 程序都可以提升为语法上有效的 JavaScript 代码。</li>
<li>一个 FuzzIL 指令是一个操作，以及输入和输出变量，并且可能有一个或多个参数（在上面的表示法中用单引号括起来）。</li>
<li>每个变量在使用之前都已定义，并且变量编号是递增且连续的。</li>
<li>控制流通过“块”来表达，这些块至少具有一个 <code>Begin</code> 和一个 <code>End</code> 操作，但也可能具有中间操作，例如 <code>BeginIf</code>、<code>BeginElse</code>、<code>EndIf</code>。</li>
<li>块指令可以具有内部输出（在上面的表示法中，<code>-&gt;</code> 后面的那些），这些输出仅在新打开的作用域中可见（例如函数参数）。</li>
<li>指令的输入始终是变量，没有立即值。</li>
<li>指令的每个输出都是一个新变量，并且只能通过专用操作（例如 <code>Reassign</code> 指令）来重新分配现有变量。</li>
</ul>
<h3 id="变异FuzzIL代码"><a href="#变异FuzzIL代码" class="headerlink" title="变异FuzzIL代码"></a>变异FuzzIL代码</h3><p>FuzzIL 旨在促进各种有意义的代码变异。 在本节中，将解释核心变异。</p>
<p>应该注意的是，Fuzzilli 中的程序是不可变的，这使得推理它们更容易。 因此，当一个程序被变异时，它实际上是在将变异应用到它的同时被复制。 这是通过 <code>ProgramBuilder</code> 类完成的，它是 Fuzzilli 中的一个核心组件，允许生成新指令或从另一个程序复制指令，并公开关于正在构建的程序的各种信息，例如哪些变量当前可见。</p>
<h4 id="Input-Mutator"><a href="#Input-Mutator" class="headerlink" title="Input Mutator"></a>Input Mutator</h4><p>实现：<code>InputMutator.swift</code></p>
<p>这是核心数据流变异。 本质上，它只是将指令的输入替换为另一个随机选择的输入：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SetProperty</span> <span class="built_in">v3</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="built_in">v4</span>		# <span class="built_in">v3</span>.foo = <span class="built_in">v4</span></span><br></pre></td></tr></table></figure>

<p>可能变成</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SetProperty</span> <span class="built_in">v3</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="built_in">v2</span>		# <span class="built_in">v3</span>.foo = <span class="built_in">v2</span></span><br></pre></td></tr></table></figure>

<p>由于 FuzzIL 的设计，特别是所有指令的输入都是变量这一事实，这种变异只需要少量 LOC（Lines of Code, 代码行数）即可实现。</p>
<h4 id="Operation-Mutator"><a href="#Operation-Mutator" class="headerlink" title="Operation Mutator"></a>Operation Mutator</h4><p>实现：<code>OperationMutator.swift</code></p>
<p>另一种基本变异，它会变异操作的参数（在 FuzzIL 的文本表示形式中用单引号括起来的值）。 例如：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v4 &lt;- BinaryOperation v1 &#x27;+&#x27; v2</span><br></pre></td></tr></table></figure>

<p>可能变成</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v4 &lt;- BinaryOperation v1 &#x27;/&#x27; v2</span><br></pre></td></tr></table></figure>

<h4 id="Splicing"><a href="#Splicing" class="headerlink" title="Splicing"></a>Splicing</h4><p>实现：<code>SpliceMutator</code></p>
<p>拼接背后的想法是将一个程序中自我包含的一部分复制到另一个程序中，以便组合来自不同程序的特性。 考虑以下程序：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v0 &lt;- LoadInt <span class="string">&#x27;42&#x27;</span></span><br><span class="line">v1 &lt;- LoadFloat <span class="string">&#x27;13.37&#x27;</span></span><br><span class="line">v2 &lt;- LoadBuiltin <span class="string">&#x27;Math&#x27;</span></span><br><span class="line">v3 &lt;- CallMethod v2, <span class="string">&#x27;sin&#x27;</span>, [v1]</span><br><span class="line">v4 &lt;- CreateArray [v3, v3]</span><br></pre></td></tr></table></figure>

<p>以其最简单的形式，从 <code>CallMethod</code> 指令进行拼接将导致三个中间指令被复制到当前程序中。 这还需要重命名变量，以便它们不与现有变量冲突：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... 现有代码</span><br><span class="line">v13 &lt;- LoadFloat <span class="string">&#x27;13.37&#x27;</span></span><br><span class="line">v14 &lt;- LoadBuiltin <span class="string">&#x27;Math&#x27;</span></span><br><span class="line">v15 &lt;- CallMethod v14, <span class="string">&#x27;sin&#x27;</span>, [v13]</span><br><span class="line">... 现有代码</span><br></pre></td></tr></table></figure>

<p>也可以进行更复杂的拼接。 例如，Fuzzilli 将概率性地将正在拼接的程序中的一些变量重新映射到宿主程序中的“兼容”变量，以组合两个程序的数据流，因此也可能最终产生以下结果：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... 现有代码</span><br><span class="line">v14 &lt;- LoadBuiltin <span class="string">&#x27;Math&#x27;</span></span><br><span class="line">v15 &lt;- CallMethod v14, <span class="string">&#x27;sin&#x27;</span>, [v3]</span><br><span class="line">... 现有代码</span><br></pre></td></tr></table></figure>

<p>在这里，拼接算法已决定用现有变量 (v3) 替换 <code>LoadFloat</code> 操作，例如因为该变量也包含一个浮点数。</p>
<p>拼接变异的一个简单的变体是 <code>CombineMutator</code>，它只是将另一个程序完整地插入到当前变异的程序中。 在这种情况下，拼接本质上是整个程序。</p>
<h4 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h4><p>实现：<code>CodeGenMutator.swift</code></p>
<p>最终的基本变异是代码生成。 这种变异器在变异程序的单个或多个随机位置生成新的随机代码。</p>
<p>代码生成是通过“CodeGenerators”执行的：小函数，用于生成特定的代码片段，通常只是单个 FuzzIL 指令，同时（通常）根据需要将现有变量用作输入。 一个非常简单的代码生成器如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;IntegerGenerator&quot;</span>) &#123; b <span class="keyword">in</span></span><br><span class="line">    b.loadInt(b.genInt())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此生成器发出一个 <code>LoadInteger</code> 指令，该指令创建一个包含随机整数值的新变量（从技术上讲，并不完全随机，因为 <code>genInt()</code> 将倾向于一些“有趣的”整数）。 另一个示例代码生成器可能是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;ComparisonGenerator&quot;</span>, inputs: (.anything, .anything)) &#123; b, lhs, rhs <span class="keyword">in</span></span><br><span class="line">    b.compare(lhs, with: rhs, using: chooseUniform(from: allComparators))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>此生成器发出一个比较指令（例如 <code>==</code>），比较两个现有变量（任意类型）。</p>
<p>默认代码生成器可以在 <code>CodeGenerators.swift</code> 中找到，而自定义代码生成器可以为特定引擎添加，例如触发不同级别的 JITing。</p>
<p>代码生成器存储在加权列表中，因此使用不同的（当前手动选择的）权重来选择它们。 这允许对生成的代码的分布进行某种程度的控制，例如，大致上执行算术运算或方法调用的频率，或者生成多少控制流（if-else、循环等），相对于数据流。 此外，<code>CodeGenerators</code> 提供了一种简单的方法，通过添加生成过去经常导致错误的特定代码片段（例如原型更改、自定义类型转换回调（例如 valueOf）或索引访问器）的 <code>CodeGenerators</code>，来引导 Fuzzilli 寻找某些错误类型。</p>
<p>通过代码生成器，最终将生成所有相关的语言功能（例如，对象操作、一元和二元操作等），然后将其保存在语料库中（因为它们触发了新的覆盖范围）并在此后进行进一步变异。</p>
<h4 id="Exploration"><a href="#Exploration" class="headerlink" title="Exploration"></a>Exploration</h4><p>实现：<code>ExplorationMutator.swift</code></p>
<p>这种高级变异器使用 JavaScript 中可用的运行时类型信息来执行更智能的变异，特别是确定可以对现有值执行的可能操作。 它执行以下操作：</p>
<ol>
<li>它为要变异的程序中的随机现有变量插入 <code>Explore</code> 操作</li>
<li>它执行生成的（临时）程序。 <code>Explore</code> 操作将被提升为一段代码，该代码在运行时检查变量（使用 JavaScript 中的“typeof”和“Object.getOwnPropertyNames”等功能），并选择要对其执行的“有用”操作（例如，加载属性、调用方法等），然后报告它做了什么</li>
<li>变异器处理步骤 2 的输出，并将一些 <code>Explore</code> 变异替换为运行时选择的具体操作。 所有其他 <code>Explore</code> 操作都将被丢弃</li>
</ol>
<p>结果是一个程序，即使在静态未知其类型的情况下，也可以对一些现有变量执行有用的操作。 结果程序也是确定性的和“JIT 友好”的，因为它不再依赖于任何类型的运行时对象检查。</p>
<h4 id="Probing"><a href="#Probing" class="headerlink" title="Probing"></a>Probing</h4><p>实现：<code>ProbingMutator.swift</code></p>
<p>这是另一种运行时辅助变异器，它试图确定现有值的使用方式。 特别是，它试图确定某个对象上是否应该存在某些属性。 这种变异器执行以下操作：</p>
<ol>
<li>它为要变异的程序中的随机现有变量插入 <code>Probe</code> 操作</li>
<li>它执行生成的（临时）程序。 <code>Probe</code> 操作将被提升为一段代码，该代码将对象（实际上是对象的原型）替换为 <code>Proxy</code>，然后记录对不存在的属性的所有访问。 然后将这些列表发送回 Fuzzilli。</li>
<li>变异器处理步骤 2 的输出并安装一些缺失的属性和回调。</li>
</ol>
<p>这种变异器因此实现了几件事：</p>
<ul>
<li>它可以自动检测操作是否触发回调，然后可以安装回调函数。 例如，这可以帮助查找与意外回调相关的错误。</li>
<li>它可以确定内置 API 的工作方式以及它期望的参数类型。 例如，许多 API 需要“配置”对象，这些对象应该具有某些键。 这种变异器可以确定这些键是什么，从而可以以一种有用的方式调用这些 API。</li>
<li>它可以使现有代码更有用。 例如，我们可能已经有一个在对象参数上运行但访问不存在的属性的 jit 优化函数，这可能不是很有用。 这种变异器可以确保这些属性存在，从而使整个程序更有意义。</li>
</ul>
<h4 id="FixupMutator"><a href="#FixupMutator" class="headerlink" title="FixupMutator"></a>FixupMutator</h4><p>实现：<code>FixupMutator.swift</code></p>
<p>这是最后的运行时辅助变异器。 它的目标是修复&#x2F;改进现有代码。 特别是，它想要</p>
<ul>
<li>删除不必要的 try-catch 块和保护</li>
<li>修复对不存在的属性和元素的访问（待办）</li>
<li>修复无效的函数、方法或构造函数调用（待办）</li>
<li>修复导致 NaN 的算术运算，这通常表明没有执行有意义的操作（待办）</li>
</ul>
<p>除了第一个之外，所有这些都尚未实现，因此此变异器仍在开发中。</p>
<p><code>FixupMutator</code> 是将受保护操作转换为不受保护操作的两种方式之一（通常首选后者）。</p>
<h3 id="类型系统和类型推断"><a href="#类型系统和类型推断" class="headerlink" title="类型系统和类型推断"></a>类型系统和类型推断</h3><p>实现：<code>TypeSystem.swift</code> 和 <code>JSTyper.swift</code></p>
<p>到目前为止，代码生成器只是一个简单的函数，它获取零个或多个随机输入变量并生成一些新的 FuzzIL 指令来对它们执行一些操作。 现在考虑以下假想的代码生成器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;FunctionCallGenerator&quot;</span>) &#123; b <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> function <span class="operator">=</span> b.randomVariable()</span><br><span class="line">    <span class="keyword">let</span> arguments <span class="operator">=</span> [b.randomVariable(), b.randomVariable(), b.randomVariable()]</span><br><span class="line">    b.callFunction(f, with: arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此生成器选择一个随机的、当前可见的变量，然后将其作为带有三个随机参数的函数调用。</p>
<p>这里的问题是，由于在任何给定时间只有少量变量实际上是函数，因此此生成器最终会生成大量无效的函数调用，例如以下内容：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v3 &lt;- LoadString <span class="string">&quot;foobar&quot;</span></span><br><span class="line">v4 &lt;- CallFunction v3, []</span><br><span class="line"><span class="comment">// TypeError: v3 is not a function</span></span><br></pre></td></tr></table></figure>

<p>这将导致抛出运行时异常，然后导致程序的其余部分不被执行，并且该程序被认为是无效的。</p>
<p>为了解决这个问题，Fuzzilli 实现了相对简单的类型推断，它尝试在 <code>ProgramBuilder</code> 构建程序时推断每个变量的可能类型。 这（可能）比听起来容易，因为解释器只需要在大多数时候是正确的（它基本上是一种优化），而不是总是正确的。 这大大简化了实现，因为许多具有复杂效果的操作（例如原型更改）在很大程度上可以忽略。 例如，考虑推断 typeof、instanceof 和比较操作结果的规则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">is</span> <span class="type">TypeOf</span>:</span><br><span class="line">    <span class="keyword">set</span>(instr.output, environment.stringType)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">is</span> <span class="type">InstanceOf</span>:</span><br><span class="line">    <span class="keyword">set</span>(instr.output, environment.booleanType)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Compare</span>:</span><br><span class="line">    <span class="keyword">set</span>(instr.output, environment.booleanType)</span><br></pre></td></tr></table></figure>

<p>为了正确推断内置对象、方法和函数的类型，类型推断依赖于 JavaScript 运行时环境的静态模型，该模型可以例如告诉解释器 eval 内置函数是一个期望单个参数的函数，Object 内置函数是一个具有各种方法的对象，或者 Uint8Array 内置函数是一个返回 Uint8Array 实例的构造函数，然后该实例具有一组特定的属性和方法。</p>
<p>FuzzIL 的设计旨在使类型推断尽可能简单。 例如，考虑 ES6 类的实现。 在 FuzzIL 中，它们看起来大致像这样：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v0 &lt;- BeginClassDefinition</span><br><span class="line">ClassAddInstanceProperty <span class="string">&quot;foo&quot;</span>, v5</span><br><span class="line">BeginClassInstanceMethod <span class="string">&quot;bar&quot;</span> -&gt; v8 (this), v9</span><br><span class="line">    ... <span class="keyword">implementation</span> <span class="keyword">of</span> method <span class="string">&quot;bar&quot;</span></span><br><span class="line">EndClassInstanceMethod</span><br><span class="line">BeginClassInstanceMethod <span class="string">&quot;baz&quot;</span> -&gt; v6 (this)</span><br><span class="line">    ... <span class="keyword">implementation</span> <span class="keyword">of</span> method <span class="string">&quot;baz&quot;</span></span><br><span class="line">EndClassInstanceMethod</span><br><span class="line">EndClassDefinition</span><br></pre></td></tr></table></figure>

<p>根据这些，从 FuzzIL 代码推断类实例的类型相当简单：<code>.object(withProperties: [&quot;foo&quot;], withMethods: [&quot;bar&quot;, &quot;baz&quot;])</code>。</p>
<p>有了可用的类型信息，上面的 <code>CodeGenerator</code> 现在可以请求一个包含函数的变量，并且还可以尝试查找与函数的参数类型兼容的变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;FunctionCallGenerator&quot;</span>) &#123; b <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> function <span class="operator">=</span> b.randomVariable(ofType: .function())</span><br><span class="line">    <span class="keyword">let</span> arguments <span class="operator">=</span> b.randomArguments(forCalling: function)</span><br><span class="line">    b.callFunction(f, with: arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，即使进行了此更改，如果参数值具有错误的类型，函数调用仍然会引发异常。 Fuzzilli 尝试通过两种方式来处理这个问题：</p>
<ol>
<li>如果函数的类型已知（即其签名已知），<code>randomArguments(forCalling:)</code> 将尝试查找合适的参数。</li>
<li>如果没有找到匹配的参数（或者如果签名未知），生成器可以选择将调用操作标记为“受保护”。 这将导致在提升期间将其包装在 try-catch 中。</li>
</ol>
<p>重要的是要注意，对于基于变异的模糊测试，<code>JSTyper</code> 和类型系统应被视为优化，而不是基本功能，因此模糊器仍然应该能够在没有类型信息的情况下运行。 此外，虽然使用类型信息进行变异可以提高模糊器的性能（产生较少明显不正确的样本），但过度依赖它可能会限制模糊器，从而对性能产生负面影响（产生较少多样化的样本）。 一个例子是 <code>InputMutator</code>，它可以选择是类型感知的，在这种情况下，它将尝试找到“兼容的”替换变量。 为了不过多地限制模糊器，Fuzzilli 的 <code>MutationEngine</code> 目前配置为同时使用非类型感知的 <code>InputMutator</code> 和类型感知的 <code>InputMutator</code>。</p>
<h4 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h4><p>实现：<code>TypeSystem.swift</code></p>
<p>为了完成它的工作，<code>JSTyper</code> 需要一个类型系统。 FuzzIL 的类型系统旨在支持两个主要用例：</p>
<ol>
<li>确定可以对给定变量执行的操作。 例如，类型系统需要说明对象上哪些属性和方法可用，以及它们的类型和签名是什么。</li>
<li>为给定操作找到一个兼容的变量。 例如，一个函数可能需要某种参数类型，例如 <code>Number</code> 或 <code>Uint8Array</code>。 类型系统必须能够表达这些类型，并且能够识别存储这种类型或子类型的值的变量。 例如，当需要 <code>Uint8Array</code> 时，可以使用具有附加属性的 <code>Uint8Array</code>，当需要父类时，可以使用子类的对象。</li>
</ol>
<p>这两种操作都需要高效，因为它们将经常执行。</p>
<p>类型系统围绕<code>位集</code>构建，基本类型分别由 32 位整数中的单个位表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> nothing     <span class="operator">=</span> <span class="type">BaseType</span>([])</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> undefined   <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> integer     <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">1</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> bigint      <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> float       <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">3</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> boolean     <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">4</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> string      <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">5</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> regexp      <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">6</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> object      <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">7</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> function    <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">8</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> constructor <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">9</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> iterable    <span class="operator">=</span> <span class="type">BaseType</span>(rawValue: <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">10</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> anything    <span class="operator">=</span> <span class="type">BaseType</span>([.undefined, .integer, .float, .string, .boolean, .object, .function, .constructor, .bigint, .regexp, .iterable])</span><br></pre></td></tr></table></figure>

<p>每个基本类型都表示可以在其类型的某个值上执行某些操作（用例 1）。 例如，数值类型表示可以在其值上执行算术运算，<code>.iterable</code> 类型表示可以迭代该值（例如，通过 for-of 循环或使用扩展运算符），<code>.object</code> 类型表示该值具有可以访问的属性和方法，<code>.function</code> 类型表示可以使用函数调用来调用该值。</p>
<p>附加类型信息，例如属性和方法、函数的签名或数组的元素类型，存储在“类型扩展”对象中，这些对象可以在多个 <code>Type</code> 结构之间共享（以减少内存消耗）。</p>
<p>可以使用三个运算符组合基本类型以形成更复杂的类型：并集、交集和合并。 接下来将讨论这些。</p>
<h5 id="Union-Operator"><a href="#Union-Operator" class="headerlink" title="Union Operator"></a>Union Operator</h5><p>Operator: <code>|</code> (按位或)</p>
<p>并集表示变量具有一种类型或另一种类型：类型 <code>t1 | t2</code> 表示值是 <code>t1</code> 或 <code>t2</code>。</p>
<p>在 Fuzzilli 中，并集类型经常作为函数的输入或输出类型出现。 例如，<code>String.prototype.replace</code> 方法可以将正则表达式对象或字符串作为第一个参数：<code>&quot;replace&quot; : [.string | .jsRegExp, .string] =&gt; .jsString</code>。 此外，由于条件执行，也会出现并集类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v4 = <span class="number">42</span>; 		<span class="comment">// .integer</span></span><br><span class="line"><span class="keyword">if</span> (v2) &#123;</span><br><span class="line">    v4 = <span class="string">&quot;foobar&quot;</span>; 	<span class="comment">// .string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v4 = .integer | .string</span></span><br></pre></td></tr></table></figure>

<h5 id="Intersection-Operator"><a href="#Intersection-Operator" class="headerlink" title="Intersection Operator"></a>Intersection Operator</h5><p>运算符：<code>&amp;</code>（按位与）</p>
<p>交集运算符计算两个（并集）类型之间的交集。 例如，<code>t1 | t2</code> 与 <code>t1 | t3</code> 的交集是 <code>t1</code>。</p>
<p>在 Fuzzilli 中，此运算符用于确定变量是否可能具有某种类型，例如它是否可能是 <code>BigInt</code>，在这种情况下，许多算术运算符的结果类型也应包括 <code>BigInt</code>。</p>
<h5 id="Merge-Operator"><a href="#Merge-Operator" class="headerlink" title="Merge Operator"></a>Merge Operator</h5><p>运算符：<code>+</code> (加号)</p>
<p>这个运算符可能是最不直观的，并且可能对这个类型系统来说是独一无二的。</p>
<p>本质上，如果一个变量具有合并类型 <code>t1 + t2</code>，那么它同时是两种输入类型。 因此，只要需要原始类型之一，就可以使用它。 为了理解为什么这可能有用，请考虑一些常见的 JavaScript 值：</p>
<ul>
<li><strong>字符串：<code>&quot;foobar&quot;</code></strong> 虽然 JavaScript 字符串显然是“字符串”类型，这意味着例如它可以用于进行字符串连接，但它也是一个具有属性（例如 <code>.length</code>）和方法（例如 <code>.charCodeAt</code>）的对象。 此外，它也表现为数组，因为它可以迭代和扩展。 因此，JavaScript 字符串的类型将是 <code>.string + .object(...) + .array</code></li>
<li><strong>函数：<code>function foo(...) &#123; ... &#125;</code></strong> JavaScript 函数既是函数（可以调用），又是对象（具有属性和方法）。 因此，类型将是 <code>.function(...) + .object(...)</code></li>
<li><strong>数组：<code>[ ... ]</code></strong> JavaScript 数组是可迭代的，但也包含属性和方法，因此表示为 <code>.array + .object(...)</code>。</li>
</ul>
<p>本质上，合并类型允许 FuzzIL 对 JavaScript 语言的动态特性进行建模，特别是经常执行的隐式类型转换以及许多事物（也）是对象这一事实。</p>
<h5 id="Type-Subsumption"><a href="#Type-Subsumption" class="headerlink" title="Type Subsumption"></a>Type Subsumption</h5><p>运算符：<code>&lt;=</code> 和 <code>&gt;=</code></p>
<p>为了支持类型查询（用例 2），类型系统实现了类型之间的蕴含关系。 这可以被认为是“是”关系，并且通常应该在搜索给定类型约束的“兼容”变量时使用。</p>
<p>一般的蕴含规则是：</p>
<ul>
<li>基本类型只蕴含自身（整数是整数但不是字符串）</li>
<li>并集 <code>t1 | t2</code> 蕴含 <code>t1</code> 和 <code>t2</code>（字符串是“字符串或数字”）</li>
<li>合并类型 <code>t1 + t2</code> 被 <code>t1</code> 和 <code>t2</code> 蕴含（JavaScript 函数既是函数又是具有属性和方法的对象）</li>
<li>继承关系（包括添加的属性&#x2F;方法）按预期工作：具有附加属性的 <code>Uint8Array</code> 仍然是 <code>Uint8Array</code>。 子类的实例也是父类的实例。</li>
</ul>
<h5 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h5><p>类型实现为两个 32 位整数，一个存储明确类型，一个存储可能类型。 根据经验，明确类型通过合并增长，而可能类型通过并集增长。</p>
<p>由于这种表示形式，类型通常只能是并集类型或合并类型。 例如，不可能（如果尝试，将会导致运行时错误）合并并集类型，因为这无法正确表示。 然而，在实践中，这是不需要的，因此没有问题。 支持Union Merged types，但是，结果通常太宽泛。 例如，类型 <code>(t1 + t2) | (t3 + t4)</code> 将与类型 <code>t1 | t2 | t3 | t4</code> 无法区分。 因此，结果类型比必要的更宽泛，但仍然是正确的，因为结果类型蕴含两个输入类型。 同样，在实践中，这并不重要，因为这种情况仅在条件执行期间发生，在这种情况下，结果类型可能无论如何都无法以有意义的方式使用（它不能保证是任何类型，因此在需要其中一种类型时不能使用）。</p>
<h5 id="Type-Examples"><a href="#Type-Examples" class="headerlink" title="Type Examples"></a>Type Examples</h5><p>为了更好地理解 FuzzIL 的类型系统，本节展示了一些常见的 JavaScript 值以及它们在 FuzzIL 中对应的类型。 也可以通过使用 <code>--inspect=types</code> 标志来检查这一点。 如果启用，写入磁盘的程序将包含变量类型的注释。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v0 = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line"><span class="comment">// .string + .object(...) + .array</span></span><br><span class="line"><span class="comment">// the object part contains all the standard string methods and properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v0 = &#123; <span class="title function_">valueOf</span>(<span class="params"></span>) &#123; ...; <span class="keyword">return</span> <span class="number">13.37</span>; &#125;&#125;;</span><br><span class="line"><span class="comment">// .object(...) + .float</span></span><br><span class="line"><span class="comment">// The object can be used for numerical operations since it has a meaningful</span></span><br><span class="line"><span class="comment">// conversion operator defined (a custom valueOf method with known signature).</span></span><br><span class="line"><span class="comment">// Note: this is not yet implemented, currently the type would just be .object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v0 = [...];</span><br><span class="line"><span class="comment">// .array + .object(...)</span></span><br><span class="line"><span class="comment">// the JavaScript array is clearly an array (can be iterated over) but also</span></span><br><span class="line"><span class="comment">// exposes properties and methods and as such is also an object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">v0</span> &#123; ... <span class="title function_">foo</span>(<span class="params"></span>) &#123; ... &#125;; <span class="title function_">bar</span>(<span class="params"></span>) &#123; ... &#125; &#125;;</span><br><span class="line"><span class="comment">// .constructor([...] =&gt; .object(...))</span></span><br><span class="line"><span class="comment">// The variable v0 is a constructor with the parameters indicated by its</span></span><br><span class="line"><span class="comment">// constructor and which returns an object of the v0 &quot;group&quot; with certain</span></span><br><span class="line"><span class="comment">// properties and methods (e.g. foo and bar)</span></span><br></pre></td></tr></table></figure>

<h3 id="The-Mutation-Engine"><a href="#The-Mutation-Engine" class="headerlink" title="The Mutation Engine"></a>The Mutation Engine</h3><p>实现: <code>MutationEngine.swift</code>（–engine&#x3D;mutation）</p>
<p>本节将解释 Fuzzilli 的变异引擎是如何工作的。 为此，它首先介绍变异引擎的三个缺失组件，即最小化器、语料库和覆盖率收集，然后解释变异引擎使用的高级模糊测试算法。</p>
<h4 id="Minimization"><a href="#Minimization" class="headerlink" title="Minimization"></a>Minimization</h4><p>实现：<code>Minimization/</code> </p>
<p>Fuzzilli 执行的变异都有一个共同点：它们只能增加 FuzzIL 程序的大小（指令数量），而永远不会减小它。 因此，经过多轮变异后，程序最终会变得太大而无法在时限内执行。 此外，如果不从有趣的程序中删除不必要的功能，未来变异的效率会降低，因为许多变异将被“浪费”在变异不相关的代码上。 因此，Fuzzilli 需要一个最小化器，在程序插入语料库之前删除程序中不必要的代码。</p>
<p>最小化在概念上很简单：<strong>Fuzzilli 尝试识别和删除触发新发现的覆盖边缘不需要的指令</strong> 。 在最简单的情况下，这意味着删除单个指令，然后重新运行程序以查看它是否仍然触发新的边缘。 还有一些专门的最小化过程。 例如，有一个内联简化器，它尝试将函数内联到它们的调用点。 这是必要的，否则代码模式，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params">...</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params">...</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">v3</span>(<span class="params">...</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">v3</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">v2</span>(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">v1</span>(...);</span><br></pre></td></tr></table></figure>

<p>会随着时间的推移而构建，例如当从另一个程序中拼接函数调用和定义到当前程序中时。</p>
<p>可以想象，最小化非常昂贵，经常需要超过一百次执行。 然而，虽然最小化开销在模糊测试的早期阶段（当经常发现有趣的样本时）占主导地位，但在模糊测试的后期阶段（当很少发现新的、有趣的程序时），它接近于零。</p>
<p>可以通过 <code>--minimizationLimit=N</code> CLI 标志来调整最小化器以减少代码的积极程度。 这样，可以强制最小化器使最小化的程序保持在给定的指令数量之上。 这有助于保留一些可能有助于未来变异的额外代码片段。 这也可以稍微加快最小化速度，因为需要删除的指令更少。 但是，将此值设置得太高可能会导致与最小化器尝试首先解决的相同类型的问题。</p>
<p>除了删除指令，最小化器还尝试以其他方式简化程序。 例如，它尝试将受保护的操作转换为不受保护的操作，删除函数调用中不必要的参数，合并包含相同值的变量，并将一些复杂的指令转换为更简单的指令（例如，将扩展调用转换为常规调用）。</p>
<h4 id="Corpus"><a href="#Corpus" class="headerlink" title="Corpus"></a>Corpus</h4><p>实现：<code>Corpus.swift</code></p>
<p>Fuzzilli 将“有趣的”样本保存在其语料库中以供未来变异。 在默认语料库实现中，样本被添加、然后随机变异，并在它们被变异至少一定次数后（通过 <code>--minMutationsPerSample</code> 标志控制）最终“退役”。 也可以实现其他语料库管理算法。 例如，已经实现了一种基于马尔可夫链的语料库管理算法。</p>
<p>如果使用 <code>--storagePath</code> CLI 标志，Fuzzilli 会将其添加到语料库中的所有样本以 protobuf 格式写入磁盘。 例如，这些可以通过 <code>--resume</code> 恢复之前的模糊测试会话，或者可以使用 FuzzILTool 进行检查。</p>
<h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><p>实现：<code>Compiler/</code></p>
<p>默认情况下，Fuzzilli 始终从语料库中单个任意选择的程序开始。 可能希望从现有的程序语料库开始，例如查找过去错误的变体。 在 Fuzzilli 中，这需要从 JavaScript 到 FuzzIL 的编译器，因为 Fuzzilli 只能对 FuzzIL 程序进行操作。 Fuzzilli 附带了这样一个编译器，它使用 babel.js 来解析 JavaScript 代码，然后使用一个相对简单的编译器来处理生成的 AST 并从中生成 FuzzIL 程序。 该编译器尚未完成所有功能，需要支持更多的语言结构。</p>
<h4 id="Coverage"><a href="#Coverage" class="headerlink" title="Coverage"></a>Coverage</h4><p>实现：<code>Evaluation/</code> 子目录</p>
<p>为了确定是否应将生成的程序添加到语料库中，Fuzzilli 依赖于代码覆盖率作为指导指标。 为了获得覆盖率信息，目标 JavaScript 引擎使用 <code>-fsanitize-coverage=trace-pc-guard</code> 进行编译，并且向其中添加了一个小代码存根，该代码存根通过 REPRL 接口在每次执行 JavaScript 程序期间收集边缘覆盖率信息。 在每次执行新生成的程序之后，都会处理覆盖率位图，以确定是否发现了 JavaScript 引擎控制流图中的任何新分支（因此覆盖率增加）。 如果是这样，则该样本被确定为有趣的，并在最小化后添加到语料库中。</p>
<p><strong>应该注意的是，在 JIT 编译器的情况下，Fuzzilli 仅收集编译器代码上的覆盖率信息，而不收集生成代码上的覆盖率信息。 这比尝试检测生成的代码（如果原始 JavaScript 代码被变异，生成的代码将迅速改变）要简单得多。 此外，通常应该是这种情况，JIT 编译器仅编译已经执行多次的代码。 因此，生成的 JIT 代码之后也被执行的可能性应该相当高。 无论如何，研究是否可以将关于发出的 JIT 代码的覆盖率指导用作指导指标仍然是未来研究的主题。</strong></p>
<h4 id="关于确定性的一点说明"><a href="#关于确定性的一点说明" class="headerlink" title="关于确定性的一点说明"></a>关于确定性的一点说明</h4><p>现代 JavaScript 引擎在后台线程上执行各种任务，例如 JIT 编译或垃圾回收。 除其他原因外，这可能导致非确定性行为：一个样本可能触发一次 JIT 编译器或 GC 边缘，但在随后的执行期间不会触发。 如果 Fuzzilli 保留了这样的样本，它将对变异引擎的有效性产生负面影响，例如因为 Fuzzilli 将无法最小化该样本，并且随后会“浪费”许多执行来尝试变异它。 为了处理这个问题，Fuzzilli 默认情况下确保新发现的样本能够确定性地触发新的边缘。 这是通过重复执行样本并形成触发边缘的交集来实现的，直到该交集变得稳定为止。 此外，在使用分布式模糊测试时，worker 实例在导入样本时会重新执行样本，从而也确保了确定性行为。</p>
<p>由于与非确定性行为相关的崩溃可能难以重现但仍然可能很有趣，因此 Fuzzilli 在重现器样本中包含了原始失败消息（例如，断言失败消息和堆栈跟踪）以及退出代码作为注释，以帮助进行分析。</p>
<h4 id="变异算法"><a href="#变异算法" class="headerlink" title="变异算法"></a>变异算法</h4><p>Fuzzilli 的变异引擎遵循基于变异的模糊器的典型过程：从语料库中获取一个样本（在 Fuzzilli 的例子中是一个 FuzzIL 程序），并变异给定的次数。 在变异期间，变量的类型通过 JSTyper 进行近似，以允许更智能的变异。 如果在任何时候，变异后的样本触发了新的覆盖率，则在最小化后将其添加到语料库中。 然而，为了实现高度的语义正确性，如果变异导致无效的程序，变异引擎将恢复变异。 这确保了高度的语义正确性，因为只有有效的程序被变异，并且因为每个变异只有相对较低的概率将有效的程序变为无效的程序。</p>
<p>变异引擎实现的高级算法总结在下图。</p>
<img src="/2025/03/13/Fuzzilli源码分析/mutation_engine.png"  alt="mutation_engine" style="zoom: 67%;" />

<h3 id="当前变异引擎的局限性"><a href="#当前变异引擎的局限性" class="headerlink" title="当前变异引擎的局限性"></a>当前变异引擎的局限性</h3><p>免责声明：本节主要基于思维实验、现有的模糊测试研究、直觉、已发现（尤其是未发现）的漏洞以及偶尔的语料库检查，而不是专门的实验或测量。</p>
<p>本节试图从理论的角度讨论变异引擎的局限性。</p>
<p>可以将模糊器视为从可能的输入宇宙中进行采样的工具。 从这个角度来看，Fuzzilli 将从所有语法上有效的 JavaScript 程序的宇宙中进行采样。 Fuzzilli 的一个通用原则是，它不应该尝试（均匀地）从所有语法上有效的 JavaScript 程序的整个宇宙中进行采样，因为那个宇宙太大了。 因此，需要某种形式的指导来（希望）将模糊器引导到更有可能触发错误的样本。 在 MutationEngine 中，这种指导（主要）来自覆盖率反馈，它自动将模糊器引导到具有高复杂度的代码区域。 可以使用额外的、手动的指导来偏向模糊器，例如通过旨在触发 JIT 编译的特定 CodeGenerators。 这样，变异引擎基本上从可以通过将 N 个连续的变异应用于语料库中的程序而到达的程序集合中进行采样，而语料库中的程序是那些触发新覆盖率的程序。 此外，应该存在这样的情况：一个样本离语料库“越远”，就越不可能被发现，因为导致它的长度为 N 的可能变异“路径”的数量减少（即，一个非常接近语料库中样本的样本可能可以通过许多不同的变异来找到，而一个遥远的样本需要特定的变异序列才能到达）。</p>
<p>然后，MutationEngine 将能够找到与语料库中的错误有些“接近”的错误，但不能找到远离语料库的错误。</p>
<p>那么，关键问题是语料库中样本的分布可能是什么样子，因为它极大地影响了生成的样本的总体分布。 这里的论点是，语料库中的样本通常只会触发引擎的一个或几个特性，因为一个新程序不太可能一次触发多个新的、复杂的优化。 这可以通过查看典型语料库中样本的新发现的边缘数量（<code>--inspect</code> 将包含它）来在一定程度上进行测量。 下表显示了针对 JavaScriptCore 进行的具有大约 20000 个样本的模糊测试运行的结果：</p>
<table>
<thead>
<tr>
<th>新边的数量</th>
<th>样本数量</th>
<th>占总数的百分比</th>
<th>平均大小（以JS LoC为单位）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>9631</td>
<td>48%</td>
<td>40</td>
</tr>
<tr>
<td>2-5</td>
<td>5999</td>
<td>30%</td>
<td>61</td>
</tr>
<tr>
<td>6-10</td>
<td>1580</td>
<td>8%</td>
<td>69</td>
</tr>
<tr>
<td>10+</td>
<td>2849</td>
<td>14%</td>
<td>74</td>
</tr>
</tbody></table>
<p>因此，MutationEngine 可能最大的缺点之一是它很难找到需要对相关对象执行多个不同操作的漏洞。 虽然覆盖率指导会奖励模糊器第一次触发每个操作的实现，但将它们组合成单个数据流不会有额外的奖励。 类似地，一旦模糊器触发了一次回调机制（例如 valueOf 回调或 Proxy 陷阱），它可能不会因为在不同的上下文（例如不同的内置函数）中触发相同的回调机制而获得奖励，尽管这可能会导致有趣的错误。</p>
<p>对此问题有许多可能的解决方案：</p>
<ul>
<li>设计一种替代指导指标，作为纯代码覆盖率的替代或补充，该指标引导模糊器发现现有指标难以发现的错误。 例如，该指标可以尝试将覆盖率反馈与某种形式的数据流分析相结合，以奖励模糊器在同一数据流上触发多个不同的特性。 这是未来研究的主题。</li>
<li>从旧漏洞的概念验证代码或回归测试中为模糊器播种，以找到可以通过有些类似的代码触发的剩余错误。 这可以通过使用上面讨论的 FuzzIL 编译器将现有的 JavaScript 代码编译成 FuzzIL 语料库来实现。 这种方法本质上仅限于寻找与过去漏洞至少有些相似的错误。</li>
<li>改进代码生成基础设施并使用它从头开始创建新程序，可能针对目标 JavaScript 引擎的特定错误类型或组件。 本文档的其余部分讨论了这种方法和实现它的 HybridEngine。</li>
</ul>
<h3 id="The-HybridEngine"><a href="#The-HybridEngine" class="headerlink" title="The HybridEngine"></a>The HybridEngine</h3><p>实现：<code>HybridEngine.swift</code>（<code>--engine=hybrid</code>）</p>
<p>HybridEngine 背后的核心思想是将代码生成与现有的变异和拼接机制相结合。 这实现了许多目标：</p>
<ul>
<li>通过配置生成的程序的形状和方面（例如，强调 JavaScript 引擎的某些区域或特定 API），可以实现手动模糊器指导。</li>
<li>允许纯代码生成器保持相当简单，而是依赖于变异器使生成的代码更有趣或更正确。 特别是，FixupMutator 专门设计用于帮助 HybridEngine 生成正确且有意义的程序。</li>
<li>它可以防止过度专业化，并提高发出的代码的多样性，因为变异（主要是输入和操作变异）是完全随机且无偏的（例如，它们忽略任何类型信息）。 因此，它们也经常导致语义上无效的样本。</li>
<li>它使代码生成引擎能够“学习”有趣的代码片段，因为这些片段将被添加到语料库中（由于覆盖率反馈），然后用于拼接。 因此，即使在生成式模糊测试模式下，仍然使用代码覆盖率反馈。</li>
</ul>
<p>与 MutationEngine 相比，HybridEngine 主要缺乏覆盖率指导。 因此，它需要以不同的方式解决许多问题：</p>
<h4 id="1-正确性问题"><a href="#1-正确性问题" class="headerlink" title="1. 正确性问题"></a>1. 正确性问题</h4><p>由于变异引擎会恢复无效的变异（那些导致引发运行时异常的变异），因此变异期间的代码生成可能有些激进，因此导致更多无效的样本。 然而，当从头开始生成整个程序时，生成的样本的正确率更为重要。 因此，代码生成器需要小心不要生成无效的代码。 这通过多种方式实现：</p>
<ul>
<li>代码生成器应选择正确类型的输入变量。 例如，发出函数调用的生成器应确保所选变量包含可调用的值。</li>
<li>当代码生成器无法证明在运行时不会抛出异常时（这可能由于多种原因发生，包括当前没有所需类型的变量可用），可以使用受保护的指令（或显式的 try-catch 块）。 如上所述，FixupMutator 和 Minimizer 都会负责删除不必要的保护。</li>
<li>还有一些其他的临时机制，试图防止无效程序的常见来源。 例如，ProgramBuilder 支持“递归保护”，它可以防止琐碎的递归。</li>
</ul>
<h4 id="2-意义性问题"><a href="#2-意义性问题" class="headerlink" title="2. 意义性问题"></a>2. 意义性问题</h4><p>考虑以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v0 = ...;</span><br><span class="line"><span class="keyword">let</span> v1 = v0 / &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然语义上有效（运行时不会抛出异常），但该代码在很大程度上是语义上无意义的，因为它只会产生 NaN（非数字）值。 因此，无论 v0 的实际值如何，此代码的输出状态空间都是 1。 （大多数）无意义操作的其他示例包括加载或删除不存在的属性（这将始终导致未定义）、对没有自定义 toPrimitive 转换运算符的对象或非数字字符串执行任何类型的数学运算（算术运算符或 Math 函数）、将不正确类型的值作为参数传递给内置函数，或在非对象上存储属性。</p>
<p>理想情况下，“无意义”很可能被定义为始终导致引擎的相同内部状态转换，而不管输入类型和周围代码如何。 由于这很难衡量，Fuzzilli 对该术语的解释在很大程度上是模糊的近似值，因此 Fuzzilli 认为无意义的某些操作实际上会在某些引擎中引起一些有趣的行为。 然而，由于执行的变异，“无意义”的代码仍然会被生成（只是不是以不合理的高概率），希望允许发现相关的错误。</p>
<p>在变异引擎中，代码覆盖率与最小化器相结合有效地解决了这个问题：无意义的代码片段不会触发任何新的覆盖率，因此会在包含在语料库中之前被最小化器删除。 因此，语料库包含的主要是<em>有意义的代码片段，因此生成的代码也主要是</em>有意义的。</p>
<p>然而，生成式引擎没有依赖于覆盖率反馈的奢侈（除了拼接）。 因此，代码生成引擎的主要设计目标是努力以高频率生成有意义的代码，其中有意义的宽松定义是，对于给定的输入类型，输出可以根据输入值具有不同的值。 在实践中，这个例子意味着执行按位运算的 CodeGenerator 应该需要数值输入值而不是完全任意的输入值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;BitOp&quot;</span>, inputs: .preferred(.number, .number)) &#123; b, lhs, rhs <span class="keyword">in</span></span><br><span class="line">    b.binary(lhs, rhs, with: chooseUniform(from: allBitwiseOperators))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，FixupMutator（最终）也旨在通过检测运行时无意义的操作并将它们更改为更有意义的操作来解决此问题。</p>
<h4 id="3-前瞻性问题"><a href="#3-前瞻性问题" class="headerlink" title="3. 前瞻性问题"></a>3. 前瞻性问题</h4><p>考虑 Fuzzilli 生成函数定义的情况（例如通过 PlainFunctionGenerator）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">v4, v5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，当生成函数体时，v4 和 v5 的类型是未知的，因为它们只能在稍后调用该函数时由 JSTyper 观察到。 然而，如果参数只是设置为未知类型（FuzzIL 类型系统中的 .anything），那么主体中的代码将无法有意义地使用它们。</p>
<p>因此，解决方案是每次生成函数时都生成一个随机但非平凡的函数签名。 例如，在伪代码中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">v4: <span class="built_in">Number</span>, v5: JSArray</span>) -&gt; <span class="title class_">JSArray</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在这里有意义地使用 v4 和 v5</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，主体中的代码可以有意义地使用参数，并且它的返回值也可以被使用。 该函数将具有存储在其类型中的签名（就像内置函数和方法一样），因此将来对其进行的任何调用都将尝试获取正确类型的参数值。 生成签名时，会考虑当前可用的变量，以使生成无法满足的签名的概率非常低。</p>
<p>一个相关的问题是如何处理自定义对象类型，例如生成如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">v3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> v3.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使这成为可能，Fuzzilli 不仅必须知道 v3 的类型，还必须知道其属性的类型。</p>
<p>这可以通过预先生成许多自定义对象类型并在生成器中使用它们来类似地解决。 例如，以下类型可能用于上面的 v3：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v3 = .<span class="title function_">object</span>(<span class="string">&quot;ObjType1&quot;</span>, [</span><br><span class="line">    .<span class="property">a</span>: .<span class="title function_">object</span>(<span class="string">&quot;ObjType2&quot;</span>, [</span><br><span class="line">        .<span class="property">b</span>: .<span class="title function_">object</span>(<span class="string">&quot;ObjType3&quot;</span>, [</span><br><span class="line">            .<span class="property">c</span>: .<span class="property">integer</span></span><br><span class="line">        ])</span><br><span class="line">    ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>为了使此方法有效，生成对象或属性存储的代码生成器必须遵守这些属性类型。</p>
<h4 id="程序模板"><a href="#程序模板" class="headerlink" title="程序模板"></a>程序模板</h4><p>如前所述，需要某种指导机制将模糊器引导到代码的特定区域。 在 HybridEngine 中，这通过 ProgramTemplates 实现：程序结构的高级描述，然后从中生成具体的程序。 这有效地限制了搜索空间，因此可以更有效地发现漏洞。</p>
<p>接下来显示 ProgramTemplate 的示例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProgramTemplate</span>(<span class="string">&quot;JITFunction&quot;</span>) &#123; b <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 从一个随机前缀和一些随机代码开始。</span></span><br><span class="line">    b.buildPrefix()</span><br><span class="line">    b.build(n: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个较大的函数并为其生成一个签名</span></span><br><span class="line">    <span class="keyword">let</span> f <span class="operator">=</span> b.buildPlainFunction(with: b.randomParameters()) &#123; args <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">assert</span>(args.count <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">        b.build(n: <span class="number">30</span>)</span><br><span class="line">        b.doReturn(b.randomVariable())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 JIT 优化</span></span><br><span class="line">    b.buildRepeatLoop(n: <span class="number">100</span>) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">        b.callFunction(f, withArgs: b.randomArguments(forCalling: f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个相当简单的模板旨在通过生成一个随机函数，强制编译它，然后使用不同的参数再次调用它来搜索 JIT 编译器错误。</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>以下是 HybridEngine 如何基于上述模板生成程序的示例。 请注意，并非所有 CodeGenerators 都已迁移以与 HybridEngine 很好地配合使用（例如，通过在必要时发出受保护的指令），因为这仍在进行中。</p>
<h5 id="1-前缀代码生成"><a href="#1-前缀代码生成" class="headerlink" title="1. 前缀代码生成"></a>1. 前缀代码生成</h5><p>该模板首先通过 b.buildPrefix() 方法生成一个小的“前缀”。 前缀只是代码片段，其目的是创建一些变量以供后续代码使用。 通常建议从这样的前缀开始，因为它确保 CodeGenerators 具有可见变量以用作输入。 在底层，前缀生成执行代码生成，但只使用标记为“值生成器”的一小部分代码生成器。 这些必须始终生成新变量并且不得失败。 结果可能是一段代码，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v0 &lt;- <span class="title class_">LoadInt</span> <span class="string">&#x27;42&#x27;</span></span><br><span class="line">v1 &lt;- <span class="title class_">LoadInt</span> <span class="string">&#x27;1337&#x27;</span></span><br><span class="line">v2 &lt;- <span class="title class_">LoadString</span> <span class="string">&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-随机代码生成"><a href="#2-随机代码生成" class="headerlink" title="2. 随机代码生成"></a>2. 随机代码生成</h5><p>模板的下一部分只是使用主代码生成 API：ProgramBuilder.build(n:) 生成几个随机指令。 对于代码生成，ProgramBuilder 将重复选择随机 CodeGenerators 并运行它们，直到至少生成 n 个指令。 例如，CodeGenerator 可以如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;BinOp&quot;</span>, inputs: .preferred(.number, .number)) &#123; b, lhs, rhs <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> needGuard <span class="operator">=</span> b.type(of: lhs).<span class="type">MayBe</span>(.bigint) <span class="operator">||</span> b.type(of: rhs).<span class="type">MayBe</span>(.bigint)</span><br><span class="line">    b.binary(lhs, rhs, with: chooseUniform(from: allBinaryOperators), guard: needGuard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，生成器如何小心地生成正确且有意义的代码，同时又不对其输入要求过于严格。 它的做法是声明它“希望”接收数字作为输入（这意味着如果有可用的变量，则应使用数字调用它，但也可以使用不同类型的变量调用），然后检查其中一个输入是否可能是 BigInts（在这种情况下，很可能会出现运行时异常：“TypeError: Cannot mix BigInt and other types, use explicit conversions”），如果是，则将操作标记为受保护的（导致在运行时使用 try-catch）。</p>
<p>在此上下文中，可以使用 v0 和 v1 调用生成器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3 &lt;- <span class="title class_">Binary</span> v0, <span class="string">&#x27;*&#x27;</span>, v1</span><br></pre></td></tr></table></figure>

<p>由于静态已知两个输入的类型都不是 BigInts，因此不需要任何保护。</p>
<p>此时，只生成了一个新指令，因此代码生成将继续。 然而，为了简洁起见，在本例中我们将在此处停止代码生成并继续到模板的下一部分。</p>
<h5 id="3-函数生成"><a href="#3-函数生成" class="headerlink" title="3. 函数生成"></a>3. 函数生成</h5><p>模板的下一部分负责生成一个随机函数。 为此，第一步是使用 ProgramBuilder.randomParameters API 生成一个随机签名。 这将查看现有变量及其类型，并基于它们选择签名。 这样，以后很有可能找到合适的参数值。 在此特定情况下，它可以提出诸如 [.string, .int] 之类的签名，因为存在两种类型的现有变量。 请注意，签名尚不包括返回值类型。 这将仅在函数定义结束时根据函数体内部生成的 Return 语句来计算。</p>
<p>生成签名后，模板将创建函数并使用代码生成机制填充其主体。 这次，我们将使用以下三个代码生成器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;BuiltinGenerator&quot;</span>) &#123; b <span class="keyword">in</span></span><br><span class="line">    b.loadBuiltin(b.randomBuiltin())</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;FunctionCallGenerator&quot;</span>, inputs: .preferred(.function())) &#123; b, f <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> arguments <span class="operator">=</span> b.randomArguments(forCalling: f)</span><br><span class="line">    <span class="keyword">let</span> needGuard <span class="operator">=</span> b.type(of: f).<span class="type">MayNotBe</span>(.function())  <span class="comment">// 技术上，如果参数类型与签名不匹配，也需要保护</span></span><br><span class="line">    b.callFunction(f, withArgs: arguments, guard: needGuard)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="type">CodeGenerator</span>(<span class="string">&quot;ComputedPropertyAssignmentGenerator&quot;</span>, inputs: .preferred(.object())) &#123; b, obj <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> propertyName <span class="operator">=</span> b.randomVariable()</span><br><span class="line">    <span class="keyword">let</span> value <span class="operator">=</span> b.randomVariable()</span><br><span class="line">    <span class="keyword">let</span> needGuard <span class="operator">=</span> b.type(of: obj).<span class="type">MayBe</span>(.nullish)</span><br><span class="line">    b.setComputedProperty(propertyName, of: obj, to: value, guard: needGuard)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>运行第一个生成器时，ProgramBuilder.randomBuiltin API 将查询静态环境模型以查找可用的内置函数。 在这种情况下，环境模型可能包含以下内置函数：<code>bar: .function([] =&gt; .anything)</code>，然后选择它。 接下来，代码生成可能会选择 FunctionCallGenerator。 因为它声明它需要 .function() 作为参数，所以 ProgramBuilder 会（可能）选择先前加载的内置函数。 因为它的签名是已知的，所以没有为调用选择任何参数值，并且返回值类型为 .anything。 最后，代码生成可能会选择 ComputedPropertyAssignmentGenerator。 因为当前没有类型为 .object() 的可用值，所以函数调用的返回值（可能）会被选择，因为它具有类型 .anything。 这样，至少有机会使该值在运行时成为对象。 由于不能排除该值不是“nullish”（null 或 undefined）的情况，在这种情况下会引发运行时异常，因此代码生成器将操作标记为受保护的。 将所有内容放在一起，为函数生成以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v4 &lt;- <span class="title class_">BeginPlainFunction</span> -&gt; v5, v6</span><br><span class="line">    v7 &lt;- <span class="title class_">LoadBuiltin</span> <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    v8 &lt;- <span class="title class_">CallFunction</span> v7, []</span><br><span class="line">    <span class="title class_">SetComputedProperty</span> v8, v5, <span class="title function_">v6</span> (guarded)</span><br><span class="line">    <span class="title class_">Return</span> v8</span><br><span class="line"><span class="title class_">EndPlainFunction</span></span><br></pre></td></tr></table></figure>

<h5 id="4-组合各个部分"><a href="#4-组合各个部分" class="headerlink" title="4. 组合各个部分"></a>4. 组合各个部分</h5><p>模板的其余部分只是生成一个循环来调用在步骤 3 中生成的函数。 通常，应该使用不同的参数再次调用该函数几次，并且可能在执行更多随机生成的代码之后。 为了使本示例保持简短，此处省略了这些步骤。</p>
<p>提升到 JavaScript（使用表达式内联），生成的代码现在将是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f4</span>(<span class="params">a5, a6</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v8 = <span class="title function_">bar</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; v8[a5] = a6; &#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v9 = <span class="number">0</span>; v9 &lt; <span class="number">100</span>; v9++) &#123;</span><br><span class="line">    <span class="title function_">f6</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">42</span> * <span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成后，样本将被进一步变异。 由于 FixupMutator 对于 HybridEngine 特别有用，因此它始终用作第一个变异器，以“完善”生成的程序。 在这种情况下，变异器可能会发现不需要 try-catch 保护（如果它在运行时从未触发），因此可以将其删除，从而产生最终的（“完善的”）程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f4</span>(<span class="params">a5, a6</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v8 = <span class="title function_">bar</span>();</span><br><span class="line">    v8[a5] = a6;</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v9 = <span class="number">0</span>; v9 &lt; <span class="number">100</span>; v9++) &#123;</span><br><span class="line">    <span class="title function_">f6</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">42</span> * <span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后的变异可能会以各种有趣（和不太有趣）的方式更改生成的程序。</p>
<h4 id="Code-Generation-Mutations-The-HybridEngine"><a href="#Code-Generation-Mutations-The-HybridEngine" class="headerlink" title="Code Generation + Mutations: The HybridEngine"></a>Code Generation + Mutations: The HybridEngine</h4><p>HybridEngine 将代码生成引擎与现有的变异器结合在一起。 为此，它首先选择一个随机 ProgramTemplate，然后使用如前所述的代码生成引擎从中生成一个程序。 如果生成的程序有效，它将使用 Mutationengine 也使用的算法进一步变异几次。</p>
<p>混合引擎使用的高级算法总结在下图。</p>
<img src="/2025/03/13/Fuzzilli源码分析/hybrid_engine.png"  alt="hybrid_engine" style="zoom:67%;" />

<p>HybridEngine 可以通过不同的方式使用。接下来将讨论这些内容。</p>
<h4 id="Application-Component-Fuzzing"><a href="#Application-Component-Fuzzing" class="headerlink" title="Application: Component Fuzzing"></a>Application: Component Fuzzing</h4><p>通过 ProgramTemplates，可以将模糊器引导到引擎的主要组件，例如 JIT 编译器。 除了对目标代码（以及可能其中的过去错误）有高级别的理解之外，这种模板可能几乎不需要任何努力。</p>
<p>应用：补丁正确性验证和变体模糊测试</p>
<p>HybridEngine 的另一个应用是搜索先前错误的变体。</p>
<p>这种技术的一个很好的例子是 V8MapTransition 模板。 该模板搜索 CVE-2020-16009 的变体（并尝试验证补丁的正确性）。 这个想法只是将代码生成引擎限制为一小组 JavaScript 特性，即对象字面量、属性加载和存储以及函数定义和调用，以减少搜索空间。 该模板成功地在数亿次执行中再次触发了原始漏洞，从而证明了该技术是可行的。</p>
<h4 id="Application-Targeted-Fuzzing"><a href="#Application-Targeted-Fuzzing" class="headerlink" title="Application: Targeted Fuzzing"></a>Application: Targeted Fuzzing</h4><p>此应用与前一个应用类似，不同之处在于它不是从现有错误开始的。 相反，安全研究人员或开发人员必须首先确定目标引擎中可能容易出现复杂错误的特定功能，然后开发一个模板来尽可能好地强调该组件。</p>
<p>与第一个应用相比，这种模板需要对目标源代码区域有相当深入的了解，例如，为了确定需要生成哪些类型的代码片段以及不需要生成哪些类型的代码片段。 另一方面，它应该效率更高。</p>
<h4 id="MutationEngine-vs-HybridEngine"><a href="#MutationEngine-vs-HybridEngine" class="headerlink" title="MutationEngine vs. HybridEngine"></a>MutationEngine vs. HybridEngine</h4><p>本节简要比较Fuzzilli中使用的两种引擎。</p>
<table>
<thead>
<tr>
<th>MutationEngine</th>
<th>HybridEngine</th>
</tr>
</thead>
<tbody><tr>
<td>遵循通用指导算法，几乎不需要手动调整即可生成有趣的 JavaScript 代码</td>
<td>需要手动指导，以程序模板和代码生成器形式</td>
</tr>
<tr>
<td>生成的样本对控制的余地很小，因为它们主要是由覆盖率反馈决定的。影响代码的可能方法包括代码生成器及其相对权重、突变体以及最小化器的侵略性。</td>
<td>允许对生成的代码有大量控制，包括对高级结构（例如，一个正在 JIT 编译的函数，然后被调用几次）以及通过代码生成器对低级代码片段的控制</td>
</tr>
<tr>
<td>能够发现与样本“相似”的漏洞，从而触发新的覆盖率（因此被添加到语料库中），但可能难以发现不是这种情况的漏洞。后者可能包括需要通过多个不同的代码路径进行复杂状态操作的漏洞</td>
<td>能够找到与所使用的 ProgramTemplates 之一“相似”的漏洞，这些模板可能来自过去的漏洞、希望测试特定区域的开发者或希望测试代码库复杂区域的审计员</td>
</tr>
</tbody></table>
<p>由于这两个引擎相互补充，因此可能需要在同一个模糊测试会话中同时运行这两个引擎。 至少在理论上，这两个引擎也应该能够相互受益：变异引擎可以进一步变异来自 HybridEngine 的样本，而 HybridEngine 可以（通过拼接）从由 MutationEngine 构建的更好的语料库中受益。 因此，MultiEngine（<code>--engine=multi</code>）允许在一个模糊测试会话中使用这两个引擎，并允许大致控制每个引擎的调度频率。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>一次周期内，Fuzzilli的执行流分析。</p>
<h3 id="基本架构：由main-swift开始"><a href="#基本架构：由main-swift开始" class="headerlink" title="基本架构：由main.swift开始"></a>基本架构：由main.swift开始</h3><p>这一个文件主要是对参数的读取以及相关初始化。</p>
<p>创建好CodeGenerator加权列表用于后续的随机选择：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否启用WasmCodeGenerator</span></span><br><span class="line"><span class="keyword">let</span> codeGeneratorsToUse <span class="operator">=</span> <span class="keyword">if</span> enableWasm &#123;</span><br><span class="line">    <span class="type">CodeGenerators</span> <span class="operator">+</span> <span class="type">WasmCodeGenerators</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">CodeGenerators</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置CodeGenerator权重</span></span><br><span class="line"><span class="keyword">let</span> standardCodeGenerators: [(<span class="type">CodeGenerator</span>, <span class="type">Int</span>)] <span class="operator">=</span> codeGeneratorsToUse.map &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> weight <span class="operator">=</span> codeGeneratorWeights[<span class="variable">$0</span>.name] <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.fatal(<span class="string">&quot;Missing weight for code generator <span class="subst">\(<span class="variable">$0</span>.name)</span> in CodeGeneratorWeights.swift&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable">$0</span>, weight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个空的加权列表来存储CodeGenerator</span></span><br><span class="line"><span class="keyword">var</span> codeGenerators: <span class="type">WeightedList</span>&lt;<span class="type">CodeGenerator</span>&gt; <span class="operator">=</span> <span class="type">WeightedList</span>&lt;<span class="type">CodeGenerator</span>&gt;([])</span><br><span class="line"><span class="comment">// 遍历所有Generator，跳过被禁用的Generator</span></span><br><span class="line"><span class="keyword">for</span> (generator, <span class="keyword">var</span> weight) <span class="keyword">in</span> (additionalCodeGenerators <span class="operator">+</span> standardCodeGenerators) &#123;</span><br><span class="line">    <span class="keyword">if</span> disabledGenerators.contains(generator.name) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> swarmTesting &#123;</span><br><span class="line">        weight <span class="operator">=</span> <span class="type">Int</span>.random(in: <span class="number">1</span><span class="operator">...</span><span class="number">30</span>)</span><br><span class="line">        logger.info(<span class="type">String</span>(format: <span class="string">&quot;%6d | <span class="subst">\(generator.name)</span>&quot;</span>, weight))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codeGenerators.append(generator, withWeight: weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是<code>loadCorpus</code>函数的定义，用于从指定目录加载文件。生成的programs是该目录下的文件列表</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadCorpus</span>(<span class="params">from</span> <span class="params">dirPath</span>: <span class="type">String</span>) -&gt; [<span class="type">Program</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> isDir: <span class="type">ObjCBool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="type">FileManager</span>.default.fileExists(atPath: dirPath, isDirectory: <span class="operator">&amp;</span>isDir) <span class="operator">&amp;&amp;</span> isDir.boolValue <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.fatal(<span class="string">&quot;Cannot import programs from <span class="subst">\(dirPath)</span>, it is not a directory!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> programs <span class="operator">=</span> [<span class="type">Program</span>]()</span><br><span class="line">    <span class="keyword">let</span> fileEnumerator <span class="operator">=</span> <span class="type">FileManager</span>.default.enumerator(atPath: dirPath)</span><br><span class="line">    <span class="comment">// 遍历目录的每个文件</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> filename <span class="operator">=</span> fileEnumerator<span class="operator">?</span>.nextObject() <span class="keyword">as?</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> filename.hasSuffix(<span class="string">&quot;.fzil&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> path <span class="operator">=</span> dirPath <span class="operator">+</span> <span class="string">&quot;/&quot;</span> <span class="operator">+</span> filename</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: <span class="type">URL</span>(fileURLWithPath: path))</span><br><span class="line">            <span class="keyword">let</span> pb <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Fuzzilli_Protobuf_Program</span>(serializedBytes: data)</span><br><span class="line">            <span class="keyword">let</span> program <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Program</span>.<span class="keyword">init</span>(from: pb)</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>program.isEmpty &#123;</span><br><span class="line">                programs.append(program)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to load program <span class="subst">\(path)</span>: <span class="subst">\(error)</span>. Skipping&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> programs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>makeFuzzer</code>函数，这个函数的定义很长，用来初始化并配置一个Fuzzer示例，代码就不放了。简单分析一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeFuzzer</span>(<span class="params">with</span> <span class="params">configuration</span>: <span class="type">Configuration</span>) -&gt; <span class="type">Fuzzer</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作用：根据传入的<code>Configuration</code>配置，构建并返回一个完整的Fuzzer实例。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> runner <span class="operator">=</span> <span class="type">REPRL</span>(executable: jsShellPath, processArguments: jsShellArguments, processEnvironment: profile.processEnv, maxExecsBeforeRespawn: profile.maxExecsBeforeRespawn) <span class="comment">// 在插桩的JavaScript引擎中运行测试代码。</span></span><br></pre></td></tr></table></figure>

<p>REPRL为在被插装的JS引擎中执行js代码的script runner</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为各个变异器分配权重，如（ExplorationMutator权重为3，更频繁使用）。</span></span><br><span class="line"><span class="comment">// mutator负责根据语料库变异程序并且评估结果</span></span><br><span class="line"><span class="keyword">var</span> mutators <span class="operator">=</span> <span class="type">WeightedList</span>([</span><br><span class="line">        (<span class="type">ExplorationMutator</span>(),                 <span class="number">3</span>),</span><br><span class="line">        (<span class="type">CodeGenMutator</span>(),                     <span class="number">2</span>),</span><br><span class="line">        (<span class="type">SpliceMutator</span>(),                      <span class="number">2</span>),</span><br><span class="line">        (<span class="type">ProbingMutator</span>(),                     <span class="number">2</span>),</span><br><span class="line">        (<span class="type">InputMutator</span>(typeAwareness: .loose),  <span class="number">2</span>),</span><br><span class="line">        (<span class="type">InputMutator</span>(typeAwareness: .aware),  <span class="number">1</span>),</span><br><span class="line">        <span class="comment">// Can be enabled for experimental use, ConcatMutator is a limited version of CombineMutator</span></span><br><span class="line">        <span class="comment">// (ConcatMutator(),                   1),</span></span><br><span class="line">        (<span class="type">OperationMutator</span>(),                   <span class="number">1</span>),</span><br><span class="line">        (<span class="type">CombineMutator</span>(),                     <span class="number">1</span>),</span><br><span class="line">        <span class="comment">// Include this once it does more than just remove unneeded try-catch</span></span><br><span class="line">        <span class="comment">// (FixupMutator()),                   1),</span></span><br><span class="line">    ])	</span><br></pre></td></tr></table></figure>

<p>前面的文档中提及过的FuzzEngine：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> engineName &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hybrid&quot;</span>:</span><br><span class="line">    engine <span class="operator">=</span> <span class="type">HybridEngine</span>(numConsecutiveMutations: consecutiveMutations)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;multi&quot;</span>:</span><br><span class="line">    <span class="keyword">let</span> mutationEngine <span class="operator">=</span> <span class="type">MutationEngine</span>(numConsecutiveMutations: consecutiveMutations)</span><br><span class="line">    <span class="keyword">let</span> hybridEngine <span class="operator">=</span> <span class="type">HybridEngine</span>(numConsecutiveMutations: consecutiveMutations)</span><br><span class="line">    <span class="keyword">let</span> engines <span class="operator">=</span> <span class="type">WeightedList</span>&lt;<span class="type">FuzzEngine</span>&gt;([</span><br><span class="line">        (mutationEngine, <span class="number">1</span>),</span><br><span class="line">        (hybridEngine, <span class="number">1</span>),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>

<p>其余的还有程序模板（ProgramTemplates），<code>JavaScriptEnvironment</code>是管理可用的内置函数、属性名和方法名，可以通过配置文件来添加自定义内置函数。<code>ProgramCoverageEvaluator</code>接收覆盖率数据。还有lifter，Corpus以及Minimizer。就不赘述了。</p>
<p>然后是调用Configuration函数进行配置信息的初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainConfig <span class="operator">=</span> <span class="type">Configuration</span>(arguments: <span class="type">CommandLine</span>.arguments,</span><br><span class="line">                               timeout: <span class="type">UInt32</span>(timeout),</span><br><span class="line">                               logLevel: logLevel,</span><br><span class="line">                               startupTests: profile.startupTests,</span><br><span class="line">                               minimizationLimit: minimizationLimit,</span><br><span class="line">                               enableDiagnostics: diagnostics,</span><br><span class="line">                               enableInspection: inspect,</span><br><span class="line">                               staticCorpus: staticCorpus,</span><br><span class="line">                               tag: tag)</span><br></pre></td></tr></table></figure>

<p>再调用makeFuzzer函数以config来创建一个Fuzzer实例。再初始化信号处理器，在接收到终止信号时能够优雅地关闭fuzzer（这是一种标准的Swift信号处理模式，适用于需要优雅地退出的命令行工具或服务）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install signal handlers to terminate the fuzzer gracefully.</span></span><br><span class="line"><span class="keyword">var</span> signalSources: [<span class="type">DispatchSourceSignal</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">for</span> sig <span class="keyword">in</span> [<span class="type">SIGINT</span>, <span class="type">SIGTERM</span>] &#123;</span><br><span class="line">    <span class="comment">// Seems like we need this so the dispatch sources work correctly?</span></span><br><span class="line">    signal(sig, <span class="type">SIG_IGN</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> source <span class="operator">=</span> <span class="type">DispatchSource</span>.makeSignalSource(signal: sig, queue: <span class="type">DispatchQueue</span>.main)</span><br><span class="line">    source.setEventHandler &#123;</span><br><span class="line">        fuzzer.async &#123;</span><br><span class="line">            fuzzer.shutdown(reason: .userInitiated)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.activate()</span><br><span class="line">    signalSources.append(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后<code>fuzzer.sync</code>，它初始化关键模块（统计数据，存储，网络同步等）。网络同步是分布式模糊测试，支持多机协同（主节点发 任务，子节点执行），随后又一个<code>ThreadParent(for: fuzzer)</code>多线程并行，最后三步是<code>fuzzer.initialize()</code>初始化所有模块，<code>fuzzer.runStartupTests()</code>运行基础测试，确保各个模块，引擎等正常工作。最后<code>fuzzer.start(runUntil: exitCondition)</code>，启动fuzz loop。</p>
<p>首先看一下Fuzzer对象的<code>ShutDownComplete</code>事件对象上挂载了一个回调函数（称为<code>listener</code>），用于在Fuzzer退出时做一些收尾工作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fuzzer.sync &#123;   <span class="comment">// 向fuzzer的dispath queue发送一个回调函数, 并等待任务完成 </span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当主fuzzer完全停止时, 退出这个进程</span></span><br><span class="line">    fuzzer.registerEventListener(for: fuzzer.events.<span class="type">ShutdownComplete</span>) &#123; reason <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> resume, <span class="keyword">let</span> path <span class="operator">=</span> storagePath &#123;</span><br><span class="line">            <span class="comment">// Check if we have an old_corpus directory on disk, this can happen if the user Ctrl-C&#x27;s during an import.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="type">FileManager</span>.default.fileExists(atPath: path <span class="operator">+</span> <span class="string">&quot;/old_corpus&quot;</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Corpus import aborted. The old corpus is now in <span class="subst">\(path <span class="operator">+</span> <span class="string">&quot;/old_corpus&quot;</span>)</span>.&quot;</span>)</span><br><span class="line">                logger.info(<span class="string">&quot;You can recover the old corpus by moving it to <span class="subst">\(path <span class="operator">+</span> <span class="string">&quot;/corpus&quot;</span>)</span>.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exit(reason.toExitCode())    <span class="comment">// 整个进程退出, 所有线程被kill</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步了解<code>Fuzzer</code>的事件机制</p>
<p><code>Event&lt;T&gt;</code>类的定义如下，发现<code>Event</code>其实是一个<code>listener</code>容器，表示该事件发生时所有要回调的<code>listener</code>，<code>T</code>则代表回调函数的参数类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Event</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">EventListener</span> <span class="operator">=</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span>			<span class="comment">// 事件监听器也就是listener的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The list of observers for this event.				// 所有监听该事件的listener组成的数组</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">public</span> <span class="keyword">var</span> listeners <span class="operator">=</span> [<span class="type">EventListener</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Registers an event listener for this event.			// 向该事件中注册listener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">addListener</span>(<span class="keyword">_</span> <span class="params">listener</span>: <span class="keyword">@escaping</span> <span class="type">EventListener</span>) &#123;</span><br><span class="line">        listeners.append(listener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Events</code>则是各种类型的集合，包含所有可以被分派给fuzzer的事件，部分事件如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// List of all events that can be dispatched in a fuzzer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Events</span> &#123;</span><br><span class="line">    <span class="comment">/// Signals that the fuzzer is fully initialized. fuzzer被完全初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> <span class="type">Initialized</span> <span class="operator">=</span> <span class="type">Event</span>&lt;<span class="type">Void</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Signals that a this instance is shutting down.	fuzzer即将被关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> <span class="type">Shutdown</span> <span class="operator">=</span> <span class="type">Event</span>&lt;<span class="type">ShutdownReason</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Signals that this instance has successfully shut down.	fuzzer被成功关闭</span></span><br><span class="line">    <span class="comment">/// Clients are expected to terminate the hosting process when handling this event.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> <span class="type">ShutdownComplete</span> <span class="operator">=</span> <span class="type">Event</span>&lt;<span class="type">ShutdownReason</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Signals that a log message was dispatched.	一个日志信息被发送</span></span><br><span class="line">    <span class="comment">/// The origin field contains the UUID of the fuzzer instance that originally logged the message.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> <span class="type">Log</span> <span class="operator">=</span> <span class="type">Event</span>&lt;(origin: <span class="type">UUID</span>, level: <span class="type">LogLevel</span>, label: <span class="type">String</span>, message: <span class="type">String</span>)&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Signals that a new (mutated) program has been generated.	一个新的（变异后的）程序被生成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> <span class="type">ProgramGenerated</span> <span class="operator">=</span> <span class="type">Event</span>&lt;<span class="type">Program</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Signals that a valid program has been found.			一个合法程序被发现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> <span class="type">ValidProgramFound</span> <span class="operator">=</span> <span class="type">Event</span>&lt;<span class="type">Program</span>&gt;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此<code>fuzzer.registerEventListener()</code>其实就是把<code>listener</code>回调添加到<code>event.listeners</code>数组中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">registerEventListener</span>&lt;<span class="type">T</span>&gt;(<span class="params">for</span> <span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">T</span>&gt;, <span class="params">listener</span>: <span class="keyword">@escaping</span> <span class="type">Event</span>&lt;<span class="type">T</span>&gt;.<span class="type">EventListener</span>) &#123;</span><br><span class="line">    dispatchPrecondition(condition: .onQueue(queue))</span><br><span class="line">    event.addListener(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>listener被触发的流程：</p>
<ul>
<li>以<code>ShutdownComplete</code>时间为例，在fuzz循环次数到达限制或者时间到达限制后会调用<code>Fuzzer::shutdown()</code>方法退出fuzz</li>
<li>该方法会执行<code>dispatchEvent(events.ShudownComplete, data: reason)</code>表示以参数<code>data</code>触发<code>ShutdownComplete</code>事件对象上的所有listener</li>
<li>而<code>dispatchEvent()</code>会直接回调<code>event.listeners</code>数组中所有的事件监听器</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store samples to disk if requested.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> path <span class="operator">=</span> storagePath &#123;			<span class="comment">// 把生成的样本保存在磁盘中， 参数--storagePath被设置时</span></span><br><span class="line">    <span class="keyword">if</span> resume &#123;	<span class="comment">// 恢复模式：将旧语料库移动到old_corpus，并后续导入</span></span><br><span class="line">        <span class="comment">// Move the old corpus to a new directory from which the files will be imported afterwards</span></span><br><span class="line">        <span class="comment">// before the directory is deleted.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">FileManager</span>.default.fileExists(atPath: path <span class="operator">+</span> <span class="string">&quot;/old_corpus&quot;</span>) &#123;</span><br><span class="line">            logger.fatal(<span class="string">&quot;Unexpected /old_corpus directory found! Was a previous import aborted? Please check if you need to recover the old corpus manually by moving to to /corpus or deleting it.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="type">FileManager</span>.default.moveItem(atPath: path <span class="operator">+</span> <span class="string">&quot;/corpus&quot;</span>, toPath: path <span class="operator">+</span> <span class="string">&quot;/old_corpus&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Nothing to resume from: <span class="subst">\(path)</span>/corpus does not exist&quot;</span>)</span><br><span class="line">            resume <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> overwrite &#123;	<span class="comment">// 覆盖模式：清空存储目录</span></span><br><span class="line">        logger.info(<span class="string">&quot;Deleting all files in <span class="subst">\(path)</span> due to --overwrite&quot;</span>)</span><br><span class="line">        <span class="keyword">try?</span> <span class="type">FileManager</span>.default.removeItem(atPath: path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The corpus directory must be empty. We already checked this above, so just assert here</span></span><br><span class="line">        <span class="keyword">let</span> directory <span class="operator">=</span> (<span class="keyword">try?</span> <span class="type">FileManager</span>.default.contentsOfDirectory(atPath: path <span class="operator">+</span> <span class="string">&quot;/corpus&quot;</span>)) <span class="operator">??</span> []</span><br><span class="line">        <span class="built_in">assert</span>(directory.isEmpty)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 添加存储模块</span></span><br><span class="line">    fuzzer.addModule(<span class="type">Storage</span>(for: fuzzer,</span><br><span class="line">                             storageDir: path,</span><br><span class="line">                             statisticsExportInterval: exportStatistics <span class="operator">?</span> <span class="type">Double</span>(statisticsExportInterval) <span class="operator">*</span> Minutes : <span class="literal">nil</span></span><br><span class="line">                            ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Storage</code>模块：负责将测试用例和Crash数据存储到磁盘中。</p>
</blockquote>
<p>下面研究一下什么是模块，<code>Module</code>接口的定义如下，该接口只要求实现一个<code>initialize()</code>方法，该方法会在<code>Fuzzer</code>的对象初始化完毕之后回调，用于进行模块初始化</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">    <span class="comment">// initialize()方法会在fuzzer完全完全初始化并且能够执行程序时调用</span></span><br><span class="line">    <span class="comment">// 此时，其他模块将要被初始化但是还没有完全初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">initialize</span>(<span class="params">with</span> <span class="params">fuzzer</span>: <span class="type">Fuzzer</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="built_in">type</span>(of: <span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns the instance of this module on the provided fuzzer instance if it exists, nil otherwise.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">instance</span>(<span class="params">for</span> <span class="params">fuzzer</span>: <span class="type">Fuzzer</span>) -&gt; <span class="keyword">Self</span><span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> instance <span class="operator">=</span> fuzzer.modules[<span class="keyword">self</span>.name] &#123;</span><br><span class="line">            <span class="keyword">return</span> instance <span class="keyword">as?</span> <span class="keyword">Self</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>Storage</code>模块为例子，该模块初始化时会向<code>Fuzzer</code>对象的<code>CrashFound</code>和<code>InterestingProgramFound</code>事件注册回调，用于在发现crash和interesting prog时将其保存在磁盘中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span>: <span class="title class_ inherited__">Module</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fuzzer对象初始化完毕后回调该模块的该方法, 负责对fuzzer对象进行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">initialize</span>(<span class="params">with</span> <span class="params">fuzzer</span>: <span class="type">Fuzzer</span>) &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在fuzzer中注册事件回调, 在发现crash时写入到磁盘中</span></span><br><span class="line">        fuzzer.registerEventListener(for: fuzzer.events.<span class="type">CrashFound</span>) &#123; ev <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> filename <span class="operator">=</span> <span class="string">&quot;program_<span class="subst">\(<span class="keyword">self</span>.formatDate())</span>_<span class="subst">\(ev.program.id)</span>_<span class="subst">\(ev.behaviour.rawValue)</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> ev.isUnique &#123;</span><br><span class="line">                <span class="keyword">self</span>.storeProgram(ev.program, as: filename, in: <span class="keyword">self</span>.crashesDir)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.storeProgram(ev.program, as: filename, in: <span class="keyword">self</span>.duplicateCrashesDir)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册事件回调: 发现interesting prog时写入到磁盘中</span></span><br><span class="line">        fuzzer.registerEventListener(for: fuzzer.events.<span class="type">InterestingProgramFound</span>) &#123; ev <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> filename <span class="operator">=</span> <span class="string">&quot;program_<span class="subst">\(<span class="keyword">self</span>.formatDate())</span>_<span class="subst">\(ev.program.id)</span>&quot;</span></span><br><span class="line">            <span class="keyword">self</span>.storeProgram(ev.program, as: filename, in: <span class="keyword">self</span>.corpusDir)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，Fuzzer对象初始化完毕后回调模块中的<code>initialize()</code>方法，各个模块可以根据需求对Fuzzer进行一些修改以实现功能。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fuzzer.initialize()			<span class="comment">// fuzzer对象的初始化</span></span><br><span class="line">fuzzer.runStartupTests()	<span class="comment">// 进行fuzz loop启动前的测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the main fuzzing job.</span></span><br><span class="line">fuzzer.start(runUntil: exitCondition)</span><br></pre></td></tr></table></figure>

<p><code>Fuzzer::initial()</code>会调用所有依赖组件的<code>initialize()</code>方法，完成依赖组件的初始化，至此<code>Fuzzer</code>对象才算是初始化完毕；然后回调所有模块的初始化方法，完成模块的安装；最后发送<code>Initialized</code>事件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">initialize</span>() &#123;</span><br><span class="line">    dispatchPrecondition(condition: .onQueue(queue))</span><br><span class="line">    <span class="built_in">assert</span>(<span class="operator">!</span>isInitialized)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the script runner first so we are able to execute programs.</span></span><br><span class="line">    <span class="comment">// 初始化脚本执行器，这样就可以执行js脚本了</span></span><br><span class="line">    runner.initialize(with: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then initialize all components. 初始化所有组件</span></span><br><span class="line">    engine.initialize(with: <span class="keyword">self</span>)</span><br><span class="line">    evaluator.initialize(with: <span class="keyword">self</span>)</span><br><span class="line">    environment.initialize(with: <span class="keyword">self</span>)</span><br><span class="line">    corpus.initialize(with: <span class="keyword">self</span>)</span><br><span class="line">    minimizer.initialize(with: <span class="keyword">self</span>)</span><br><span class="line">    corpusGenerationEngine.initialize(with: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally initialize all modules. 初始化所有模块</span></span><br><span class="line">    <span class="keyword">for</span> module <span class="keyword">in</span> modules.values &#123;</span><br><span class="line">        module.initialize(with: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install a watchdog to monitor the utilization of this instance. 安装一个watchdog监控这个实例的使用情况</span></span><br><span class="line">    <span class="keyword">var</span> lastCheck <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">    timers.scheduleTask(every: <span class="number">1</span> <span class="operator">*</span> <span class="type">Minutes</span>) &#123;</span><br><span class="line">        <span class="comment">// Monitor responsiveness</span></span><br><span class="line">        <span class="keyword">let</span> now <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">        <span class="keyword">let</span> interval <span class="operator">=</span> now.timeIntervalSince(lastCheck)</span><br><span class="line">        lastCheck <span class="operator">=</span> now</span><br><span class="line">        <span class="keyword">if</span> interval <span class="operator">&gt;</span> <span class="number">180</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.logger.warning(<span class="string">&quot;Fuzzer appears unresponsive (watchdog only triggered after <span class="subst">\(Int(interval))</span>s instead of 60s).&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install a timer to monitor for faulty code generators and program templates. 安装一个计时器来监视错误的代码生成器和程序模板</span></span><br><span class="line">    timers.scheduleTask(every: <span class="number">5</span> <span class="operator">*</span> <span class="type">Minutes</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> generator <span class="keyword">in</span> <span class="keyword">self</span>.codeGenerators &#123;</span><br><span class="line">            <span class="keyword">if</span> generator.totalSamples <span class="operator">&gt;=</span> <span class="number">100</span> <span class="operator">&amp;&amp;</span> generator.correctnessRate <span class="operator">&lt;</span> <span class="number">0.05</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.logger.warning(<span class="string">&quot;Code generator <span class="subst">\(generator.name)</span> might be broken. Correctness rate is only <span class="subst">\(generator.correctnessRate <span class="operator">*</span> <span class="number">100</span>)</span>% after <span class="subst">\(generator.totalSamples)</span> generated samples&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> template <span class="keyword">in</span> <span class="keyword">self</span>.programTemplates &#123;</span><br><span class="line">            <span class="keyword">if</span> template.totalSamples <span class="operator">&gt;=</span> <span class="number">100</span> <span class="operator">&amp;&amp;</span> template.correctnessRate <span class="operator">&lt;</span> <span class="number">0.05</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.logger.warning(<span class="string">&quot;Program template <span class="subst">\(template.name)</span> might be broken. Correctness rate is only <span class="subst">\(template.correctnessRate <span class="operator">*</span> <span class="number">100</span>)</span>% after <span class="subst">\(template.totalSamples)</span> generated samples&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine our initial state if necessary.</span></span><br><span class="line">    <span class="built_in">assert</span>(state <span class="operator">==</span> .uninitialized <span class="operator">||</span> state <span class="operator">==</span> .corpusImport)</span><br><span class="line">    <span class="keyword">if</span> state <span class="operator">==</span> .uninitialized &#123;</span><br><span class="line">        <span class="keyword">let</span> isChildNode <span class="operator">=</span> modules.values.contains(where: &#123; <span class="variable">$0</span> <span class="keyword">is</span> <span class="type">DistributedFuzzingChildNode</span> &#125;)</span><br><span class="line">        <span class="keyword">if</span> isChildNode &#123;</span><br><span class="line">            <span class="comment">// We&#x27;re a child node, so wait until we&#x27;ve received some kind of corpus from our parent node.</span></span><br><span class="line">            <span class="comment">// We&#x27;ll change our state when we&#x27;re synchronized with our parent, see updateStateAfterSynchronizingWithParentNode() below.</span></span><br><span class="line">            changeState(to: .waiting)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Start with corpus generation.</span></span><br><span class="line">            <span class="built_in">assert</span>(corpus.isEmpty)</span><br><span class="line">            changeState(to: .corpusGeneration)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatchEvent(events.<span class="type">Initialized</span>)		<span class="comment">// 触发事件：Fuzzer已初始化</span></span><br><span class="line">    logger.info(<span class="string">&quot;Initialized&quot;</span>)</span><br><span class="line">    isInitialized <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过<code>fuzzer.start()</code>启动fuzz loop</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">start</span>(<span class="params">runUntil</span> <span class="params">exitCondition</span>: <span class="type">ExitCondition</span> <span class="operator">=</span> .none) &#123;</span><br><span class="line">    <span class="comment">// 线程安全检查</span></span><br><span class="line">    dispatchPrecondition(condition: .onQueue(queue))</span><br><span class="line">    <span class="comment">// 状态检查</span></span><br><span class="line">    <span class="built_in">assert</span>(isInitialized)</span><br><span class="line">	<span class="comment">// 设置退出条件</span></span><br><span class="line">    <span class="keyword">self</span>.exitCondition <span class="operator">=</span> exitCondition</span><br><span class="line">	</span><br><span class="line">    logger.info(<span class="string">&quot;Let&#x27;s go!&quot;</span>)</span><br><span class="line">	<span class="comment">// 调用FuzzOne，Fuzz一轮。和AFL++的Fuzz_one一样</span></span><br><span class="line">    fuzzOne()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>fuzzOne()</code>开始第一次fuzz，注意<code>fuzzer.sync&#123;...&#125;是同步任务，所以此时是主线程在执行fuzzOne()</code>，<code>Fuzzer:fuzzOne()</code>函数如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fuzzer</span> &#123;</span><br><span class="line">    <span class="comment">// fuzzOne()在主线程执行一次后会通过DispatchQueue在另一个线程不断循环调用自身, 实现fuzz事件循环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">fuzzOne</span>() &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="comment">// 检查是否fuzz结束</span></span><br><span class="line">        <span class="keyword">switch</span> exitCondition &#123;</span><br><span class="line">        <span class="keyword">case</span> .none:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .iterationsPerformed(<span class="keyword">let</span> maxIterations):   <span class="comment">// 迭代次数到达上限</span></span><br><span class="line">            <span class="keyword">if</span> iterations <span class="operator">&gt;</span> maxIterations &#123;</span><br><span class="line">                <span class="keyword">return</span> shutdown(reason: .finished)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .timeFuzzed(<span class="keyword">let</span> maxRuntime):   <span class="comment">// 执行时间到达上线</span></span><br><span class="line">            <span class="keyword">if</span> uptime() <span class="operator">&gt;</span> maxRuntime &#123;</span><br><span class="line">                <span class="keyword">return</span> shutdown(reason: .finished)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前fuzzer实例的状态进行处理, 真正干活的部分</span></span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .uninitialized:</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        <span class="keyword">case</span> .waiting:</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .corpusImport: <span class="comment">// 导入语料库, Fuzzer初始化完毕后就是该状态</span></span><br><span class="line">            <span class="keyword">let</span> program <span class="operator">=</span> currentCorpusImportJob.nextProgram()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentCorpusImportJob.numberOfProgramsImportedSoFar <span class="operator">%</span> <span class="number">500</span> <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Corpus import progress: imported <span class="subst">\(currentCorpusImportJob.numberOfProgramsImportedSoFar)</span> of <span class="subst">\(currentCorpusImportJob.totalNumberOfProgramsToImport)</span> programs&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> outcome <span class="operator">=</span> importProgram(program, origin: .corpusImport(mode: currentCorpusImportJob.importMode))    <span class="comment">// 导出语料</span></span><br><span class="line">            currentCorpusImportJob.notifyImportOutcome(outcome)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> currentCorpusImportJob.isFinished &#123;    <span class="comment">// 导入完毕</span></span><br><span class="line">                <span class="operator">...</span></span><br><span class="line">                dispatchEvent(events.<span class="type">CorpusImportComplete</span>)    <span class="comment">// 触发事件</span></span><br><span class="line">                changeState(to: .fuzzing)    <span class="comment">// 状态改变成.fuzzing</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .corpusGeneration: <span class="comment">// 在没有起始语料的情况下, 用于生成语料并进行fuzz</span></span><br><span class="line">            <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .fuzzing:  <span class="comment">// 使用生成的语料对引擎进行fuzz</span></span><br><span class="line">            iterations <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            engine.fuzzOne(fuzzGroup)   <span class="comment">// 使用fuzz引擎进行一轮的fuzz</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦本次迭代的相关任务都处理完毕, 就立刻发送任务进行下一次迭代</span></span><br><span class="line">        <span class="comment">// 一旦queue中的任务执行完毕, 就回调&#123;self.fuzzOne()&#125;从而再次执行</span></span><br><span class="line">        <span class="comment">// 这样就相当于通过DispatchGroup在另一个线程中开启了一个不断调用self.fuzzOne()的循环</span></span><br><span class="line">        fuzzGroup.notify(queue: queue) &#123;</span><br><span class="line">            <span class="keyword">self</span>.fuzzOne()  <span class="comment">// Fuzzer::fuzzOne</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要关注两点：</p>
<ol>
<li>Fuzzer对象的状态变化：在提供初始语料库的情况下，Fuzzer对象的状态变化为<code>unintialized</code>&#x3D;&gt;<code>corpusImport</code>&#x3D;&gt;<code>fuzzing</code>。<code>Fuzzer:fuzzOne()</code>会根据当前不同的状态做不同的处理</li>
<li>线程调度：<code>Fuzzer::fuzzOne()</code>每处理一次当前状态，都会调用<code>fuzzGroup.notify()</code>开启下一轮迭代。</li>
</ol>
<p>整体线程执行模型可以概况如下：</p>
<ul>
<li>第一次调用<code>fuzzOne()</code>时由主线程执行，会执行fuzz相关的任务，在处理过程中外部有可能向<code>queue</code>中添加异步任务<ul>
<li>本轮处理完毕后，主线程会执行<code>fuzzGroup.notify(queue)&#123;...&#125;</code>添加一个异步任务：在<code>queue</code>中所有的任务处理完毕后触发回调，执行<code>fuzzOne()</code>开启新一轮的fuzz。主线程不会阻塞在<code>fuzzGroup</code>上，而是直接返回，然后永久等待。</li>
<li>后续swift会自动从线程池中调用线程处理<code>queue</code>和<code>fuzzGroup</code>中的异步任务，因此第二次再执行<code>fuzzOne()</code>时就是其他进程了</li>
<li>第二次<code>fuzzOne()</code>的执行过程与上述类似，最后又会通过<code>fuzzGroup</code>开启新一轮的循环</li>
</ul>
</li>
</ul>
<p>接下来是一个多线程的操作以及工作实例的配置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> workerConfig <span class="operator">=</span> <span class="type">Configuration</span>(</span><br><span class="line">    arguments: <span class="type">CommandLine</span>.arguments,</span><br><span class="line">    timeout: <span class="type">UInt32</span>(timeout),</span><br><span class="line">    logLevel: .warning,  <span class="comment">// 比主实例更低的日志级别</span></span><br><span class="line">    startupTests: profile.startupTests,</span><br><span class="line">    minimizationLimit: minimizationLimit,</span><br><span class="line">    enableDiagnostics: <span class="literal">false</span>,  <span class="comment">// 禁用诊断（减少开销）</span></span><br><span class="line">    enableInspection: inspect,</span><br><span class="line">    staticCorpus: staticCorpus,</span><br><span class="line">    tag: tag</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>工作实例与之前的Fuzzer实例基本相同，<code>logLevel: .warning</code>减少日志输出，避免干扰。同时<code>enableDiagnostics: false</code>禁用调试功能，提升性能。接下来就是多线程工作实例的创建了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建多个从（子）Fuzzer对象</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">..&lt;</span>numJobs &#123;</span><br><span class="line">    <span class="keyword">let</span> worker <span class="operator">=</span> makeFuzzer(with: workerConfig)		<span class="comment">// 为其子worker创建Fuzzer对象</span></span><br><span class="line">    worker.async &#123;	<span class="comment">// 子worker异步初始化</span></span><br><span class="line">        <span class="comment">// Wait some time between starting workers to reduce the load on the main instance.</span></span><br><span class="line">        <span class="comment">// If we start the workers right away, they will all very quickly find new coverage</span></span><br><span class="line">        <span class="comment">// and send lots of (probably redundant) programs to the main instance.</span></span><br><span class="line">        <span class="comment">// 启动从Fuzzer对象(主进程的是主Fuzzer对象)前随机等待</span></span><br><span class="line">        <span class="keyword">let</span> minDelay <span class="operator">=</span> <span class="number">1</span> <span class="operator">*</span> <span class="type">Minutes</span>			</span><br><span class="line">        <span class="keyword">let</span> maxDelay <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> <span class="type">Minutes</span></span><br><span class="line">        <span class="keyword">let</span> delay <span class="operator">=</span> <span class="type">Double</span>.random(in: minDelay<span class="operator">...</span>maxDelay) <span class="comment">// 随机延迟（1 ~ 10min）</span></span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: delay)</span><br><span class="line"></span><br><span class="line">        worker.addModule(<span class="type">Statistics</span>())	<span class="comment">// 统计模块</span></span><br><span class="line">        worker.addModule(<span class="type">ThreadChild</span>(for: worker, parent: fuzzer))	<span class="comment">// 子线程模块，负责与主实例通信，将发现的新覆盖率程序或崩溃发送回主实例</span></span><br><span class="line">        worker.initialize()	<span class="comment">//Fuzzer对象初始化</span></span><br><span class="line">        worker.start()	<span class="comment">// 开始fuzz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，numJobs是参数中配置的（默认为1）。随后使用makeFuzzer创建Fuzzer实例，然后加入线程worker中。避免所有工作实例同时发现新覆盖率，导致主实例被大量程序同步淹没，随机延迟1~10分钟使得工作实例负载均匀分布。</p>
<p>最后是main.swift的结束：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RunLoop</span>.main.run()	<span class="comment">// 主线程持续运行，开始在主任务队列中调度任务</span></span><br></pre></td></tr></table></figure>

<p>这是Swift中用于启动主线程事件的循环核心方法，它会启动主线程的<code>RunLoop</code>，<code>RunLoop.main.run()</code>会阻塞主线程，并持续处理事件。</p>
<p>接下来进一步看一轮fuzz中所做的事。</p>
<p>之前看到<code>Fuzzer::fuzzOne()</code>会调用<code>engine.fuzzOne(fuzzGroup)</code>进行一轮fuzz，由于前面文档所说的三种Engine，这里我们选取最基本的<code>MutationEngine</code>为例子。也就是engine.fuzzOne(fuzzGroup)，engine是MutationEngine</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">fuzzOne</span>(<span class="keyword">_</span> <span class="params">group</span>: <span class="type">DispatchGroup</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> parent <span class="operator">=</span> fuzzer.corpus.randomElementForMutating()	<span class="comment">//从种子池中随机选择一个种子用于变异</span></span><br><span class="line">    parent <span class="operator">=</span> prepareForMutating(parent)		<span class="comment">// 进行变异前准备</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numConsecutiveMutations &#123;	<span class="comment">// 生成种子的数量，也就是变异轮次</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> factor out code shared with the HybridEngine?</span></span><br><span class="line">        <span class="keyword">var</span> mutator <span class="operator">=</span> fuzzer.mutators.randomElement()	<span class="comment">//随机选择一个变异器</span></span><br><span class="line">        <span class="keyword">let</span> maxAttempts <span class="operator">=</span> <span class="number">10</span>		<span class="comment">// 一个种子最多尝试变异次数为10次</span></span><br><span class="line">        <span class="keyword">var</span> mutatedProgram: <span class="type">Program</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>maxAttempts &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> result <span class="operator">=</span> mutator.mutate(parent, for: fuzzer) &#123;	<span class="comment">// 变异成功则停止</span></span><br><span class="line">                <span class="comment">// Success!</span></span><br><span class="line">                result.contributors.formUnion(parent.contributors)</span><br><span class="line">                mutator.addedInstructions(result.size <span class="operator">-</span> parent.size)</span><br><span class="line">                mutatedProgram <span class="operator">=</span> result</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Try a different mutator.</span></span><br><span class="line">                <span class="comment">// 变异失败，则重新随机选择一个变异器进行变异</span></span><br><span class="line">                mutator.failedToGenerate()</span><br><span class="line">                mutator <span class="operator">=</span> fuzzer.mutators.randomElement()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> program <span class="operator">=</span> mutatedProgram <span class="keyword">else</span> &#123;		<span class="comment">// 变异失败</span></span><br><span class="line">            logger.warning(<span class="string">&quot;Could not mutate sample, giving up. Sample:<span class="subst">\n</span><span class="subst">\(FuzzILLifter().lift(parent))</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(program <span class="operator">!==</span> parent)</span><br><span class="line">        <span class="keyword">let</span> outcome <span class="operator">=</span> execute(program)		<span class="comment">// 执行变异后的js程序</span></span><br><span class="line">        <span class="comment">// Mutate the program further if it succeeded.</span></span><br><span class="line">        <span class="keyword">if</span> .succeeded <span class="operator">==</span> outcome &#123;	<span class="comment">// 变异后的程序执行成功，那么就在该样本的基础上继续进行变异</span></span><br><span class="line">            parent <span class="operator">=</span> program</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现两点：</p>
<ul>
<li>随机从corpus中选取一个种子，如果该种子变异后执行成功，那么就会继续变异该种子<code>numConsecutiveMutations</code>次。即每次成功变异成功执行后，在现在的基础上再继续变异。</li>
<li>对一个种子变异时，会尝试<code>maxAttempts</code>次，直到成功一次为止，如果每次都失败则会抛弃该样本</li>
</ul>
<p><code>execute()</code>方法定义在<code>FuzzEngine</code>中，是所有fuzz引擎的公共方法。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/676661723">fuzzilli原理：基本架构</a></p>
<h3 id="覆盖率：由编译开始"><a href="#覆盖率：由编译开始" class="headerlink" title="覆盖率：由编译开始"></a>覆盖率：由编译开始</h3><h4 id="下载并构建V8引擎"><a href="#下载并构建V8引擎" class="headerlink" title="下载并构建V8引擎"></a>下载并构建V8引擎</h4><p><code>v8</code>使用名为<code>depot_tools</code>的脚本包来管理。</p>
<p><code>depot_tools</code>包括<code>gclient</code>，<code>gcl</code>，<code>git-cl</code>，<code>repo</code>等。可以通过以下方式安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=`pwd`/depot_tools:<span class="variable">$PATH</span>&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span>  ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>随后，通过fetch获取v8源码。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cd</span> fuzzilli/Targets/<span class="built_in">V8</span></span><br><span class="line"><span class="symbol">fetch</span> <span class="built_in">v8</span></span><br><span class="line"><span class="symbol">cd</span> <span class="built_in">v8</span></span><br><span class="line"><span class="symbol">git</span> checkout origin</span><br><span class="line"><span class="symbol">gclient</span> sync</span><br></pre></td></tr></table></figure>

<p>接下来构建和测试v8引擎，首先是安装构建依赖项。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="keyword">build</span>/install-<span class="keyword">build</span>-deps.sh</span><br></pre></td></tr></table></figure>

<p>再使用gn生成构建文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen <span class="keyword">out</span><span class="operator">/</span><span class="keyword">Release</span> &quot;--args=is_debug=false&quot;</span><br></pre></td></tr></table></figure>

<p>使用以下命令进行编译，编译成功后会在<code>out/Release</code>目录下生成可执行文件d8</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">ninja</span> <span class="operator">-</span><span class="built_in">C</span> <span class="variable">out</span><span class="operator">/</span><span class="built_in">Release</span></span><br></pre></td></tr></table></figure>

<p>测试一下d8是正常的：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/out/</span>Release<span class="regexp">/d8 ./</span>test<span class="regexp">/fuzzer/</span>parser/hello-world</span><br></pre></td></tr></table></figure>

<p>完事儿后再用脚本编译v8即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fuzzilli/Targets/V8/v8</span><br><span class="line">../fuzzbuild.sh</span><br></pre></td></tr></table></figure>

<p>编译成功后，会生成<code>./out/fuzzbuild/d8</code>文件，这就是目标文件，也就是v8的js shell。</p>
<h4 id="编译脚本参数分析"><a href="#编译脚本参数分析" class="headerlink" title="编译脚本参数分析"></a>编译脚本参数分析</h4><p>再简要分析编译过程，以下是fuzzilli编译V8的脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(uname)</span>&quot;</span> == <span class="string">&quot;Linux&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># See https://v8.dev/docs/compile-arm64 for instructions on how to build on Arm64</span></span><br><span class="line">    gn gen out/fuzzbuild --args=<span class="string">&#x27;is_debug=false dcheck_always_on=true v8_static_library=true v8_enable_verify_heap=true v8_fuzzilli=true sanitizer_coverage_flags=&quot;trace-pc-guard&quot; target_cpu=&quot;x64&quot;&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Unsupported operating system&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">ninja -C ./out/fuzzbuild d8</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gn gen</code>：使用GN(Generate Ninja)生成构建文件</li>
<li><code>out/fuzzbuild</code>：构建输出目录</li>
<li><code>--args</code>：构建参数配置：<ul>
<li><code>is_debug=false</code>：构建发布版本（非调试版本）</li>
<li><code>dcheck_always_on=true</code>：始终启用调试检查</li>
<li><code>v8_static_library=true</code>：构建静态库版本的V8</li>
<li><code>v8_enable_verify_heap</code>：启用堆验证</li>
<li><code>v8_fuzzilli=true</code>：启用Fuzzilli特定支持</li>
<li><code>sanitizer_coverage_flags=&quot;trace-pc-guard&quot;</code>：设置代码覆盖率检测</li>
<li><code>target_cpu=&quot;x64&quot;</code>：指定目标CPU架构为x86-64</li>
</ul>
</li>
</ul>
<p>最后的<code>ninjia -C ./out/fuzzbuild d8</code>指的是在指定目录进行构建，而<code>d8</code>表示构建目标为V8的开发者shell</p>
<p>重点关注：<code>v8_fuzzilli=true</code>和<code>sanitizer_coverage_flags=&quot;trace-pc-guard&quot;</code>参数</p>
<h5 id="v8-fuzzilli-true"><a href="#v8-fuzzilli-true" class="headerlink" title="v8_fuzzilli&#x3D;true"></a>v8_fuzzilli&#x3D;true</h5><p>当设置这个参数时，<code>BUILD.gn</code>会添加一个<code>V8_FUZZILLI</code>宏</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (v8_fuzzilli) &#123;</span><br><span class="line">    <span class="attribute">defines</span> += [ <span class="string">&quot;V8_FUZZILLI&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在编译时额外添加如下4个文件，这四个文件用于llvm覆盖率插桩函数</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (v8_fuzzilli) &#123;</span><br><span class="line">  <span class="attribute">sources</span> += [</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/cov.cc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/cov.h&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/fuzzilli.cc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/fuzzilli.h&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sanitizer-coverage-flags"><a href="#sanitizer-coverage-flags" class="headerlink" title="sanitizer_coverage_flags"></a>sanitizer_coverage_flags</h5><blockquote>
<p><code>.gni</code>后缀的文件是<strong>GN Build 系统的构建配置文件</strong>，通常用于**GN(Generage Ninja)**工具链。</p>
<ul>
<li>GN是一个由Google开发的元构建系统，用于生成Ninja构建文件（<code>build.ninja</code>）。</li>
<li><code>.gni</code>文件类似于<code>Makefile</code>或<code>CMakeLists.txt</code>，但语法更简洁，专为高性能构建涉及。</li>
</ul>
<p><code>.gni</code>文件的作用</p>
<ul>
<li>定义变量、模板和构建规则</li>
<li>被主<code>BUILD.gn</code>文件引用，用于模块化配置</li>
<li>在以下使用过程中，用来控制编译过程</li>
</ul>
</blockquote>
<p>根据文件<code>V8/v8/build/config/sanitizers/sanitizers.gni</code>中的描述：</p>
<ul>
<li>设置<code>sanitizer_coverage_flags</code>会用作<code>-fsanitize-coverage</code>的值</li>
<li>并且设置该标志会自动启用<code>use_sanitizer_coverage</code></li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Value for -fsanitize-coverage flag. Setting this causes </span></span><br><span class="line"><span class="comment"># use_sanitizer_coverage to be enabled.	设置它会使use_sanitizer_coverage被启用。</span></span><br><span class="line"><span class="comment"># This flag is not used for libFuzzer (use_libfuzzer=true). Instead, we use:</span></span><br><span class="line"><span class="comment">#     -fsanitize=fuzzer-no-link			这个标志不用于libFuzzer。相反，我们使用：-fsanitize=fuzz-no-link</span></span><br><span class="line"><span class="comment"># Default value when unset and use_fuzzing_engine=true:</span></span><br><span class="line"><span class="comment">#     trace-pc-guard						未设置且use_fuzzing_engine时的默认值：trace-pc-guard</span></span><br><span class="line"><span class="comment"># Default value when unset and use_sanitizer_coverage=true:</span></span><br><span class="line"><span class="comment">#     trace-pc-guard,indirect-calls</span></span><br><span class="line"><span class="comment"># 未设置且use_sanitizer_coverage=true时的默认值：trace-pc-guard，indirect-calls</span></span><br><span class="line"><span class="attr">sanitizer_coverage_flags</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于它会自动启用<code>use_sanitizer_coverage</code>，所以看看启用该参数的时候编译时会发生什么：</p>
<p>来到<code>V8/v8/build/config/sanitizers/BUILD.gn</code>，这个文件会引用<code>sanitizers.gni</code>文件来模块化配置。查看<code>use_sanitizer_coverage</code>部分：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">config(<span class="string">&quot;coverage_flags&quot;</span>) &#123;</span><br><span class="line">  cflags = []</span><br><span class="line">  if (use_sanitizer_coverage) &#123;</span><br><span class="line">    # <span class="symbol">Used</span> by sandboxing code to allow coverage dump to be written on the disk.</span><br><span class="line">    defines = [ <span class="string">&quot;SANITIZER_COVERAGE&quot;</span> ]</span><br><span class="line"></span><br><span class="line">    if (use_libfuzzer) &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cflags += [</span><br><span class="line">        <span class="string">&quot;-fsanitize-coverage=$sanitizer_coverage_flags&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-mllvm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-sanitizer-coverage-prune-blocks=1&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">      if (current_cpu == <span class="string">&quot;arm&quot;</span>) &#123;</span><br><span class="line">      	...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  if (use_centipede) &#123;</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数有三个：<code>-fsanitize-coverage</code>、<code>-mllvm</code>和<code>-sanitizer-coverage-prune-blocks</code>，分别表示：</p>
<ul>
<li><code>-fsanitize-coverage</code>与llvm覆盖率检测相关，后续会详细研究</li>
<li><code>-mllvm</code>表示把后面一个参数传递给LLVM</li>
<li><code>-sanitizer-coverage-prune-blocks</code>表示在编译时对basic block进行精简，删除不会被执行到的基本块，可以提高运行速度，缺点是可能会影响代码覆盖率的准确性</li>
</ul>
<h4 id="llvm的sanitizer-coverage"><a href="#llvm的sanitizer-coverage" class="headerlink" title="llvm的sanitizer coverage"></a>llvm的sanitizer coverage</h4><h5 id="桩回调函数"><a href="#桩回调函数" class="headerlink" title="桩回调函数"></a>桩回调函数</h5><p><code>-fsanitize-coverage=$sanitizer_coverage_flags</code>表示启用llvm内置的覆盖率检测，并且可以提供覆盖率报告和可视化。<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">llvm-SanitizerCoverage-官方文档</a></p>
<p>支持如下模式的覆盖率追踪，不同模式会调用不同的回调(call back)函数。</p>
<h6 id="trace-pc-guard"><a href="#trace-pc-guard" class="headerlink" title="trace-pc-guard"></a>trace-pc-guard</h6><p>该模式下编译器会在每一个edge插入如下代码</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">__sanitizer_cov_trace_pc_guard</span>(&amp;<span class="variable">guard_variable</span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>guard_variable</code>是一个32位无符号整数，它唯一标识一条边或者一个基本块，即每个<code>guard_variable</code>对应一个特定的代码路径。在执行过程中，SanitizerCoverage运行时可以通过修改<code>guard_variable</code>的值来标记该路径是否被执行过。</p>
</blockquote>
<p>每条边都有自己的<code>guard_variable (uint32_t)</code>。编译器也会在每一个模块的构造函数中插入如下调用</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The guards are [start, stop). 它的执行区间是[start, stop)，也就是stop地址处是不会被初始化的</span></span><br><span class="line"><span class="comment">// This function will be called at least once per DSO and may be called</span></span><br><span class="line"><span class="comment">// more than once with the same values of start/stop.</span></span><br><span class="line"><span class="comment">// 该函数将在每个DSO(动态库)中至少调用一次，并且可以使用相同的start/stop值多次调用。</span></span><br><span class="line">__sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译器会在每个模块（如共享库或可执行文件）的构造函数中插入<code>__sanitizer_cov_trace_pc_guard_init</code>；这个函数的目的是初始化所有的<code>guard_variable </code>，其参数的含义是：</p>
<ul>
<li><code>start</code>：指向该模块所有<code>guard_variable</code>数组的起始地址</li>
<li><code>stop</code>：指向该模块所有<code>guard_variable</code>数组的结束地址（即最后一个元素的下一个位置）</li>
</ul>
</blockquote>
<p>整个插装过程涉及到三部分</p>
<ul>
<li><code>guard section</code>：每一个二进制文件都会有一个guard section， guard section实际就是一个<code>uint32_t</code>组成的数组</li>
<li>在该二进制文件初始化时回调模块初始化函数触发，<code>__sanitizer_cov_trace_pc_guard_init(start, stop)</code>，<code>[start, stop)</code>就对应guard section的开始与结束</li>
<li>执行时，每一个边对应guard section中一个slot（一条边对应guard section数组的一个索引），会触发<code>__sanitizer_cov_trace_pc_guard(&amp;guard_variable)</code>，从而得知某条边被执行到了，并通过guard进行统计</li>
</ul>
<p>至此，可以修改这两个函数的实现可以让用户达到：</p>
<ul>
<li>控制每一个edge的guard的生成方式（<code>__sanitizer_cov_trace_pc_guard_init</code>）</li>
<li>控制每一个边被触发后的处理方式（<code>__sanitizer_cov_trace_pc_guard</code>）</li>
</ul>
<p>函数<code>__sanitizer_cov_trace_pc_*</code>可以被用户自定义，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace-pc-guard-cb.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sanitizer/coverage_interface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This callback is inserted by the compiler as a module constructor</span></span><br><span class="line"><span class="comment">// into every DSO. &#x27;start&#x27; and &#x27;stop&#x27; correspond to the</span></span><br><span class="line"><span class="comment">// beginning and end of the section with the guards for the entire</span></span><br><span class="line"><span class="comment">// binary (executable or DSO). The callback will be called at least</span></span><br><span class="line"><span class="comment">// once per DSO and may be called multiple times with the same parameters.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个回调会被编译器作为一个模块构造函数插入到每一个DSO中</span></span><br><span class="line"><span class="comment">	start和stop对应整个二进制文件(可执行文件 or 动态库)中guard段的开始和结束</span></span><br><span class="line"><span class="comment">	每一个动态库这个callback至少被调用一次, 并且有可能以相同的参数调用多次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start,</span><br><span class="line">                                                    <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint64_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once. 只初始化一次</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1. 给[start, stop)中的guard_variable赋值，从1开始。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This callback is inserted by the compiler on every edge in the</span></span><br><span class="line"><span class="comment">// control flow (some optimizations apply).</span></span><br><span class="line"><span class="comment">// Typically, the compiler will emit the code like this:</span></span><br><span class="line"><span class="comment">//    if(*guard)</span></span><br><span class="line"><span class="comment">//      __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="comment">// But for large functions it will emit a simple call:</span></span><br><span class="line"><span class="comment">//    __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个回调函数会被编译器插入到控制流的每一个边中</span></span><br><span class="line"><span class="comment">	通常来说编译器会生成如下代码</span></span><br><span class="line"><span class="comment">	if(*guard)</span></span><br><span class="line"><span class="comment">            __sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="comment">    但是对于某些大函数会生成一个简单的调用, 所以callbak内部需要进行二次检查</span></span><br><span class="line"><span class="comment">     	__sanitizer_cov_trace_pc_guard(guard);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">  <span class="comment">// If you set *guard to 0 this code will not be called again for this edge.</span></span><br><span class="line">  <span class="comment">// Now you can get the PC and do whatever you want:</span></span><br><span class="line">  <span class="comment">//   store it somewhere or symbolize it and print right away.</span></span><br><span class="line">  <span class="comment">// The values of `*guard` are as you set them in</span></span><br><span class="line">  <span class="comment">// __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive</span></span><br><span class="line">  <span class="comment">// and use them to dereference an array or a bit vector.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	如果设置*guard为0, 那么对于这个边该代码就不会被调用了。</span></span><br><span class="line"><span class="comment">  	现在你可以得到PC并做任何你想做的事情：将它存储在某个地方或将其标记并立即打印。</span></span><br><span class="line"><span class="comment">  	*guard就是之前__sanitizer_cov_trace_pc_guard_init()中设置的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">// This function is a part of the sanitizer run-time.</span></span><br><span class="line">  <span class="comment">// To use it, link with AddressSanitizer or other sanitizer.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	这是sanitizer run-time函数的一部分, 可以获取pc相关信息</span></span><br><span class="line"><span class="comment">  	为了使用它需要与AddressSanitizer或者其他sanitizer链接到一起</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __sanitizer_symbolize_pc(PC, <span class="string">&quot;%p %F %L&quot;</span>, PcDescr, <span class="keyword">sizeof</span>(PcDescr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是被插桩的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace-pc-guard-example.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行编译命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译example.cc, 会为每个边生成guard并插入对于__sanitizer_cov_trace_pc*()的调用</span></span><br><span class="line">clang++ -g  <span class="attribute">-fsanitize-coverage</span>=trace-pc-guard trace-pc-guard-example.cc -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接, 获取__sanitizer_cov_trace_pc*()的实现</span></span><br><span class="line">clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o <span class="attribute">-fsanitize</span>=address</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line"><span class="attribute">ASAN_OPTIONS</span>=strip_path_prefix=`pwd`/ ./a.out</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INIT</span>: <span class="number">0</span>x71bcd0 <span class="number">0</span>x71bce0</span><br><span class="line"><span class="attribute">guard</span>: <span class="number">0</span>x71bcd4 <span class="number">2</span> PC <span class="number">0</span>x4ecd5b in main trace-pc-guard-example.cc:<span class="number">2</span></span><br><span class="line"><span class="attribute">guard</span>: <span class="number">0</span>x71bcd8 <span class="number">3</span> PC <span class="number">0</span>x4ecd9e in main trace-pc-guard-example.cc:<span class="number">3</span>:<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>执行（带参数）：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A<span class="attr">SAN_OPTIONS</span><span class="operator">=</span>strip_path_prefix<span class="operator">=</span>`pwd`<span class="symbol">/</span> <span class="symbol">./a.out</span> <span class="keyword">with</span>-foo</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INIT</span>: <span class="number">0</span>x71bcd0 <span class="number">0</span>x71bce0</span><br><span class="line"><span class="attribute">guard</span>: <span class="number">0</span>x71bcd4 <span class="number">2</span> PC <span class="number">0</span>x4ecd5b in main trace-pc-guard-example.cc:<span class="number">3</span></span><br><span class="line"><span class="attribute">guard</span>: <span class="number">0</span>x71bcdc <span class="number">4</span> PC <span class="number">0</span>x4ecdc7 in main trace-pc-guard-example.cc:<span class="number">4</span>:<span class="number">17</span></span><br><span class="line"><span class="attribute">guard</span>: <span class="number">0</span>x71bcd0 <span class="number">1</span> PC <span class="number">0</span>x4ecd20 in foo() trace-pc-guard-example.cc:<span class="number">2</span>:<span class="number">14</span></span><br></pre></td></tr></table></figure>

<h6 id="Inline-8bit-counters"><a href="#Inline-8bit-counters" class="headerlink" title="Inline 8bit-counters"></a>Inline 8bit-counters</h6><p><code>-fsanitize-coverage=inline-8bit-counters</code>将在每个edge插入内联计数器增量。这同上面的插装类似，但是只检测不回调处理。用户需要实现一个函数来在启动时捕获计数器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_8bit_counters_init(<span class="type">char</span> *start, <span class="type">char</span> *end) &#123;</span><br><span class="line">  <span class="comment">// [start,end) is the array of 8-bit counters created for the current DSO.</span></span><br><span class="line">  <span class="comment">// Capture this array in order to read/modify the counters.</span></span><br><span class="line">  <span class="comment">// [start，end]是为当前DSO创建的8位计数器数组。捕获该数组以便读取/修改计数器。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余的就不看了，对当前而言意义不大。</p>
<h5 id="插桩方式"><a href="#插桩方式" class="headerlink" title="插桩方式"></a>插桩方式</h5><p>sanitizer coverage提供不同程度的插桩</p>
<ul>
<li>edge：对控制流的边插桩</li>
<li>bb：对基本块插桩</li>
<li>func：对函数入口处插桩</li>
</ul>
<p>用它的方法也很简单：将其和<code>trace-pc</code>或<code>trace-pc-guard</code>一起用，例如：<code>-fsanitize-coverage=func,trace-pc-guard</code>，那么就会使用函数级插桩，回调函数用的是<code>trace-pc-guard</code></p>
<blockquote>
<p>当使用edge或者bb时, 如果有些插桩被认为是冗余的, 那么就会进行精简, 所以有些edge或者block可能没有被插桩, 可以使用<code>no-prune</code>标志来禁止精简, 比如<code>-fsanitize-coverage=bb,no-prune,trace-pc-guard</code></p>
</blockquote>
<h6 id="Edge-coverage"><a href="#Edge-coverage" class="headerlink" title="Edge coverage"></a>Edge coverage</h6><p>对于代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> *a)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    *a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含三个基本块（很容易判断，if前的语句，满足条件的语句，不满足条件的语句构成三个基本块）</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="string">|\</span></span><br><span class="line"><span class="string">| \</span></span><br><span class="line"><span class="string">|  B</span></span><br><span class="line"><span class="string">| /</span></span><br><span class="line"><span class="string">|/</span></span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>如果三个块都被覆盖了, 那么就可以确定<code>A=&gt;B</code>和<code>B=&gt;C</code>这两个边被执行了, 但是我们无法得知<code>A=&gt;C</code>是否执行. CFG中这样的edge被称为关键边 critical edge. edge-level的覆盖率会通过引入新的dummy block分割所有的critical edge, 然后插桩这些block:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="string">|\</span></span><br><span class="line"><span class="string">| \</span></span><br><span class="line">D  B</span><br><span class="line"><span class="string">| /</span></span><br><span class="line"><span class="string">|/</span></span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h6 id="Tracing-data-flow"><a href="#Tracing-data-flow" class="headerlink" title="Tracing data flow"></a>Tracing data flow</h6><p>目前支持如下数据流相关插桩方式, 以支持数据流引导的fuzzing。</p>
<ul>
<li>使用<code>-fsanitize-coverage=trace-cmp</code>标志, 编译器会在<strong>比较和switch语句</strong>周围进行额外的插桩,</li>
<li><code>-fsanitize-coverage=trace-div</code>标志会对<strong>整数除法</strong>进行插桩</li>
<li><code>-fsanitize-coverage=trace-gep</code>会对<strong>LLVM GEP(Get Element Ptr)指令</strong>进行插桩</li>
<li><code>-fsanitize-coverage=trace-loads</code>会对<strong>load指令</strong>进行插桩</li>
<li><code>-fsanitize-coverage=trace-stores</code>会对<strong>store指令</strong>进行插桩</li>
</ul>
<p>目前，这些标志本身不能工作-它们需要<code>-fsanize-coverage=&#123;trace-pc,inline-8bit-counters，inline-bool&#125;</code>标志之一才能工作。</p>
<h6 id="Tracing-control-flow"><a href="#Tracing-control-flow" class="headerlink" title="Tracing control flow"></a>Tracing control flow</h6><p>使用<code>-fsanizize-coverage=control-flow</code>，编译器将创建一个表来收集每个函数的控制流。更具体地说，对于函数中的每个基本块，将填充两个列表。一个列表用于基本块的后继程序，另一个列表用于非内部调用的函数。</p>
<p>每一个表行包含基本块的地址, 后面跟着后继和callee的null-ended列表。</p>
<h6 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h6><p>sanitizer runtime（AddressSanitizer、MemorySanitizer 等）提供了一些覆盖回调的默认实现。可以使用此实现将覆盖率转储到进程出口的磁盘上。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">% cat -n cov.cc</span><br><span class="line">     <span class="number">1</span>  <span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line">     <span class="number">2</span>  __attribute__((noinline))</span><br><span class="line">     <span class="number">3</span>  <span class="function"><span class="keyword">void</span> <span class="title">foo</span>()</span> &#123; printf(<span class="string">&quot;foo\n&quot;</span>); &#125;</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>  <span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">     <span class="number">6</span>    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">     <span class="number">7</span>      foo();</span><br><span class="line">     <span class="number">8</span>    printf(<span class="string">&quot;main\n&quot;</span>);</span><br><span class="line">     <span class="number">9</span>  &#125;</span><br><span class="line"></span><br><span class="line">% clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard</span><br><span class="line"></span><br><span class="line">% ASAN_OPTIONS=coverage=<span class="number">1</span> ./a.<span class="keyword">out</span>; wc -c *.sancov</span><br><span class="line">main</span><br><span class="line">SanitizerCoverage: ./a.<span class="keyword">out</span><span class="number">.7312</span>.sancov <span class="number">2</span> PCs written</span><br><span class="line"><span class="number">24</span> a.<span class="keyword">out</span><span class="number">.7312</span>.sancov</span><br><span class="line"></span><br><span class="line">% ASAN_OPTIONS=coverage=<span class="number">1</span> ./a.<span class="keyword">out</span> foo ; wc -c *.sancov</span><br><span class="line">foo</span><br><span class="line">main</span><br><span class="line">SanitizerCoverage: ./a.<span class="keyword">out</span><span class="number">.7316</span>.sancov <span class="number">3</span> PCs written</span><br><span class="line"><span class="number">24</span> a.<span class="keyword">out</span><span class="number">.7312</span>.sancov</span><br><span class="line"><span class="number">32</span> a.<span class="keyword">out</span><span class="number">.7316</span>.sancov</span><br></pre></td></tr></table></figure>

<h5 id="桩回调函数cov-cc"><a href="#桩回调函数cov-cc" class="headerlink" title="桩回调函数cov.cc"></a>桩回调函数cov.cc</h5><p>根据<code>fuzzilli</code>的编译条件：<code>sanitizer_coverage_flags=&quot;trace-pc-guard&quot;</code>，没有修改插桩方式，也就是默认的<code>Edge</code>插桩。llvm通过插入用户自定义回调的方式来收集覆盖率, 而编译中额外插入的<code>src/fuzzilli/cov.cc</code>就是桩回调函数的实现, 下面研究下fuzzilli是如何实现这些callback的。还记得参数分析的时候有<code>v8_fuzzilli=true</code>吗？那时候有四个文件分别为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (v8_fuzzilli) &#123;</span><br><span class="line">  <span class="attribute">sources</span> += [</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/cov.cc&quot;</span>,	// 这四个文件是V8自带的，而不是fuzzilli中的</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/cov.h&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/fuzzilli.cc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/fuzzilli/fuzzilli.h&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>cov.cc</code>桩回调函数的实现，接下来分析<code>cov.cc</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 0x100000				<span class="comment">// 共享内存的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EDGES ((SHM_SIZE - 4) * 8)	<span class="comment">// 一个边对应u char edges[]中的一个bit，因此最大边得*8</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shmem_data</span> &#123;						<span class="comment">// 该结构体大小为SHM_SIZE</span></span><br><span class="line">  <span class="type">uint32_t</span> num_edges;					<span class="comment">// 表示边的数量</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> edges[];				<span class="comment">// 存储每条边，每个bit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shmem_data</span>* shmem;				<span class="comment">// 执行共享内存的全局指针</span></span><br></pre></td></tr></table></figure>

<p>在模块初始化时会调用<code>__sanitizer_cov_trace_pc_guard_init()</code>。该方法获取共享内存后会调用<code>sanitizer_cov_reset_edgeguards()</code>对guard section进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sanitizer_cov_reset_edgeguards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span>* x = edges_start; x &lt; edges_stop &amp;&amp; N &lt; MAX_EDGES; x++)</span><br><span class="line">        *x = ++N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span>* start,</span><br><span class="line">                                                    <span class="type">uint32_t</span>* stop) &#123;</span><br><span class="line">    <span class="comment">// We should initialize the shared memory region only once. We can initialize</span></span><br><span class="line">    <span class="comment">// it multiple times if it&#x27;s the same region, which is something that appears</span></span><br><span class="line">    <span class="comment">// to happen on e.g. macOS. If we ever see a different region, we will likely</span></span><br><span class="line">    <span class="comment">// overwrite the previous one, which is probably not intended and as such we</span></span><br><span class="line">    <span class="comment">// fail with an error.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	我们应该只初始化共享内存区域一次。如果它在同一个区域，我们可以对它进行多次初始化，这在macOS上似乎是会发生的。</span></span><br><span class="line"><span class="comment">  	如果我们看到一个不同的区域，我们可能会覆盖之前的区域，这可能不是我们想要的，因此我们会失败并出现错误。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">if</span> (shmem) &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">// Already initialized. 已经初始化过了就返回。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Map the shared memory region</span></span><br><span class="line">    <span class="comment">// 通过环境变量获取共享内存key</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* shm_key = <span class="built_in">getenv</span>(<span class="string">&quot;SHM_ID&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!shm_key) &#123;	<span class="comment">//如果没有，则自己映射一片内存自己用</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[COV] no shared memory bitmap available, skipping\n&quot;</span>);</span><br><span class="line">        shmem = (<span class="keyword">struct</span> shmem_data*)v8::base::<span class="built_in">Malloc</span>(SHM_SIZE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 存在SHM_ID</span></span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">shm_open</span>(shm_key, O_RDWR, S_IREAD | S_IWRITE);	<span class="comment">// 获取共享内存的fd</span></span><br><span class="line">        <span class="keyword">if</span> (fd &lt;= <span class="number">-1</span>) &#123; <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[COV] Failed to open shared memory region\n&quot;</span>);</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 映射到本进程的地址空间中</span></span><br><span class="line">        shmem = (<span class="keyword">struct</span> shmem_data*)<span class="built_in">mmap</span>(<span class="number">0</span>, SHM_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line">                                         MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shmem == MAP_FAILED) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[COV] Failed to mmap shared memory region\n&quot;</span>);</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edges_start = start;		<span class="comment">// guard section的起始位置</span></span><br><span class="line">    edges_stop = stop;		<span class="comment">// guard section的结束位置</span></span><br><span class="line">    <span class="built_in">sanitizer_cov_reset_edgeguards</span>();	<span class="comment">// 调用sanitizer_cov_reset_edgeguards，初始化每条edge的guard_variable</span></span><br><span class="line"></span><br><span class="line">    shmem-&gt;num_edges = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(stop - start);	<span class="comment">// 初始化num_edges，也就是共享内存中的edge数量</span></span><br><span class="line">    builtins_start = <span class="number">1</span> + shmem-&gt;num_edges;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">            <span class="string">&quot;[COV] edge counters initialized. Shared memory: %s with %u edges\n&quot;</span>,</span><br><span class="line">            shm_key, shmem-&gt;num_edges);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>sanitizer_cov_reset_edgeguards()</code>会为<code>[start,stop)</code>从1开始连续赋值，如果超过了<code>MAX_EDGES</code>，那么超出部分的边就不会被初始化。紧接着看一下<code>__sanitizer_cov_trace_pc_guard()</code>回调函数，前文提及过，它会在边被执行时触发。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span>* guard) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s a small race condition here: if this function executes in two</span></span><br><span class="line">    <span class="comment">// threads for the same edge at the same time, the first thread might disable</span></span><br><span class="line">    <span class="comment">// the edge (by setting the guard to zero) before the second thread fetches</span></span><br><span class="line">    <span class="comment">// the guard value (and thus the index). However, our instrumentation ignores</span></span><br><span class="line">    <span class="comment">// the first edge (see libcoverage.c) and so the race is unproblematic.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	这里有一个小的竞争条件：如果这个函数在两个线程中同时对同一条边执行，那么在第二个线程获取保护值（从而获取索引）之前，</span></span><br><span class="line"><span class="comment">  	第一个线程可能会禁用该边（通过将保护设置为零）。然而，我们的检测忽略了第一条边（参见libcoverage.c），</span></span><br><span class="line"><span class="comment">  	因此竞争是没有问题的。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="type">uint32_t</span> index = *guard;		<span class="comment">// 获取边对应的唯一标识</span></span><br><span class="line">    shmem-&gt;edges[index / <span class="number">8</span>] |= <span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>);	<span class="comment">// 设置shmem-&gt;edges中第index个bit为1，表示该边已被执行</span></span><br><span class="line">    *guard = <span class="number">0</span>;			<span class="comment">// 再将这条边置为0，因此再次执行时，就不会触发callback了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以看出, <code>shmem-&gt;edges</code>是一个bit map（位图）, 就好像一个二维码一样, 记录着对于某个样本所有执行到的边。</p>
<p>这里会有一个问题, <code>shmem-&gt;edges</code>能记录的边的数量是有限的, 最大为<code>MAX_EDGES</code>, 等于<code>(0x100000-4)*8 = 8388576</code>, 够用么?</p>
<p>答案是够用, 实际执行时最多要记录<code>1367283</code>条边, 小于<code>MAX_EDGES</code>, 因此不会有边被忽略掉。 这个1367283从何而来呢？<code>shmem-&gt;num_edges</code>会记录下来，因此可以拿到所有的边。</p>
<p>这个边的数量比想象中要少，为什么呢？因为编译器会对插桩进行优化：</p>
<ul>
<li><strong>SanitizerCoverage 的优化</strong>：编译器会避免对某些低风险代码（如简单算术运算）插桩，减少边数量。</li>
<li>即使 V8 是一个复杂项目，其 <strong>控制流图（CFG）的边数量</strong> 仍受以下因素限制：<ul>
<li><strong>函数数量</strong>：V8 的核心功能（如解析、编译、执行）的代码路径是有限的。</li>
<li><strong>循环和分支的复杂度</strong>：大多数函数的控制流不会无限膨胀。</li>
</ul>
</li>
</ul>
<p>如果目标更庞大，一个超大型代码库呢？</p>
<p>起始，我们所做的就是一个超大型代码库的一部分。Chromium 浏览器是十分庞大的，但是可以经过功能拆解，分成许多子模块进行测试，比如我们测试的v8 Js引擎。倘若真是一个很大的目标程序，也可以选择扩大共享内存（例如，libFuzzer的<code>-shm_base_size</code>参数）。</p>
<p>接下来看看<code>cov.cc</code>中其他的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">sanitizer_cov_count_discovered_edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> on_edges_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">1</span>; i &lt; builtins_start; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> byteIndex = i &gt;&gt; <span class="number">3</span>;  <span class="comment">// 找到当前边i对应的字节在数组中的位置。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> bitIndex = i &amp; <span class="number">7</span>;  <span class="comment">// 找到当前边在字节中的具体位置。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shmem-&gt;edges[byteIndex] &amp; (<span class="number">1</span> &lt;&lt; bitIndex)) &#123;	<span class="comment">// 边存在的话</span></span><br><span class="line">            ++on_edges_counter;		<span class="comment">// 计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> on_edges_counter; <span class="comment">// 返回统计结果。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sanitizer_cov_count_discovered_edges()</code>会遍历所有边，统计已经被执行过的代码路径（edges）的数量。接下来是内置函数的边初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cov_init_builtins_edges</span><span class="params">(<span class="type">uint32_t</span> num_edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num_edges + shmem-&gt;num_edges &gt; MAX_EDGES) &#123;	<span class="comment">// 检查共享内存剩余空间是否能容纳新增的边</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                <span class="string">&quot;[COV] Error: Insufficient amount of edges left for builtins &quot;</span></span><br><span class="line">                <span class="string">&quot;coverage.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builtins_edge_count = num_edges;				<span class="comment">// 保存新增的内置函数边数量</span></span><br><span class="line">    builtins_start = <span class="number">1</span> + shmem-&gt;num_edges;		<span class="comment">// 内置函数的边从当前总边数+1开始。</span></span><br><span class="line">    shmem-&gt;num_edges += builtins_edge_count;		<span class="comment">// 更新总边数</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[COV] Additional %d edges for builtins initialized.\n&quot;</span>,</span><br><span class="line">            num_edges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>num_edges</code>为内置函数新增的边的数量。这样做是为了分隔内置函数与用户代码，以便单独启用&#x2F;禁用内置函数的覆盖率检测。<strong>内置函数是指由语言或引擎本身预先实现并提供给用户直接调用的核心功能函数。</strong> 它们通常是语言标准的一部分，无需用户手动定义即可实现。</p>
<p>接下来是最后一个函数，更新内置函数的基本块覆盖率信息到共享内存中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function is ran once per REPRL loop. In case of crash the coverage of</span></span><br><span class="line"><span class="comment">// crash will not be stored in shared memory. Therefore, it would be useful, if</span></span><br><span class="line"><span class="comment">// we could store these coverage information into shared memory in real time.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个函数在每个REPRL循环中运行一次。在崩溃的情况下，崩溃的覆盖将不会存储在共享内存中。因此，如果我们能够实时地将这些覆盖</span></span><br><span class="line"><span class="comment">	率信息存储到共享内存中，这将是非常有用的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cov_update_builtins_basic_block_coverage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">bool</span>&gt;&amp; cov_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cov_map.<span class="built_in">size</span>() != builtins_edge_count) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[COV] Error: Size of builtins cov map changed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cov_map.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cov_map[i]) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">uint32_t</span> byteIndex = (i + builtins_start) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            <span class="type">const</span> <span class="type">uint32_t</span> bitIndex = (i + builtins_start) &amp; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">            shmem-&gt;edges[byteIndex] |= (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数是为了将内置函数的覆盖率信息及时写入共享内存，即使发送Crash也能保存已经探索的路径。</p>
<h4 id="JavaScriptCore引擎的编译分析"><a href="#JavaScriptCore引擎的编译分析" class="headerlink" title="JavaScriptCore引擎的编译分析"></a>JavaScriptCore引擎的编译分析</h4><p>以下是JSC引擎编译的脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> WEBKIT_OUTPUTDIR=FuzzBuild	<span class="comment"># 设置WebKit构建输出目录为&quot;FuzzBuild&quot;，这样所有构建生成是文件都会放在这个目录下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(uname)</span>&quot;</span> == <span class="string">&quot;Linux&quot;</span> ]; <span class="keyword">then</span>	<span class="comment"># 检测操作系统是否为Linux</span></span><br><span class="line">    ./Tools/Scripts/build-jsc --jsc-only --debug --cmakeargs=<span class="string">&quot;-DENABLE_STATIC_JSC=ON -DCMAKE_C_COMPILER=&#x27;/usr/bin/clang&#x27; -DCMAKE_CXX_COMPILER=&#x27;/usr/bin/clang++&#x27; -DCMAKE_CXX_FLAGS=&#x27;-fsanitize-coverage=trace-pc-guard -O3 -lrt&#x27;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Unsupported operating system&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>调用<code>./Tools/Scripts/build-jsc</code>构建脚本，参数：<code>--jsc-only</code>，只构建JavaScriptCore（不构建整个webKit）。<code>--debug</code>：构建调试版本。<code>--cmakeargs</code>：传递给CMake的额外参数。如下：</p>
<figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;-DENABLE_STATIC_JSC=ON -DCMAKE_C_COMPILER=<span class="string">&#x27;/usr/bin/clang&#x27;</span> -DCMAKE_CXX_COMPILER=<span class="string">&#x27;/usr/bin/clang++&#x27;</span> -DCMAKE_CXX_FLAGS=<span class="string">&#x27;-fsanitize-coverage=trace-pc-guard -O3 -lrt&#x27;</span>&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-DENABLE_STATIC_JSC=ON</code>：启用静态链接的JSC构建</li>
<li><code>-DCMAKE_C_COMPILER=&#39;/usr/bin/clang&#39;</code>：指定使用Clang作为C编译器</li>
<li><code>-DCMAKE_CXX_COMPILER=&#39;/usr/bin/clang++&#39;</code>：指定使用Clang++作为C++编译器</li>
<li><code>-DCMAKE_CXX_FLAGS=...</code>：设置C++编译标志<ul>
<li><code>-fsanitize-coverage=trace-pc-guard</code>：启用代码覆盖率检测（用于模糊测试）</li>
<li><code>-03</code>：最高级别优化</li>
<li><code>-lrt</code>：链接实时库（Linux特定）</li>
</ul>
</li>
</ul>
<p>其实逻辑是一致的，回调函数的定义在<code>./webkit/Source/JavaScriptCore/fuzzilli/Fuzzilli.cpp</code>，当边被执行时，guard被触发，其逻辑是一致的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span>* guard)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// There&#x27;s a small race condition here: if this function executes in two threads for the same</span></span><br><span class="line">    <span class="comment">// edge at the same time, the first thread might disable the edge (by setting the guard to zero)</span></span><br><span class="line">    <span class="comment">// before the second thread fetches the guard value (and thus the index). However, our</span></span><br><span class="line">    <span class="comment">// instrumentation ignores the first edge (see libcoverage.c) and so the race is unproblematic.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> index = *guard;</span><br><span class="line">WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN</span><br><span class="line">    Fuzzilli::sharedData-&gt;edges[index / <span class="number">8</span>] |= <span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>);</span><br><span class="line">WTF_ALLOW_UNSAFE_BUFFER_USAGE_END</span><br><span class="line"></span><br><span class="line">    *guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及初始化guard section也是一致的，不过它选择让<code>initializeCoverage()</code>执行初始化<code>guard_variable</code>的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span>* start, <span class="type">uint32_t</span>* stop);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span>* start, <span class="type">uint32_t</span>* stop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Avoid duplicate initialization.</span></span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Fuzzilli::<span class="built_in">initializeCoverage</span>(start, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SUPPRESS_COVERAGE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fuzzilli::initializeCoverage</span><span class="params">(<span class="type">uint32_t</span>* start, <span class="type">uint32_t</span>* stop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RELEASE_ASSERT_WITH_MESSAGE</span>(!edgesStart &amp;&amp; !edgesStop, <span class="string">&quot;Coverage instrumentation is only supported for a single module&quot;</span>);</span><br><span class="line"></span><br><span class="line">    edgesStart = start;</span><br><span class="line">    edgesStop = stop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> <span class="type">char</span>* shmKey = <span class="built_in">getenv</span>(<span class="string">&quot;SHM_ID&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int32_t</span> fd = <span class="built_in">shm_open</span>(shmKey, O_RDWR, S_IREAD | S_IWRITE);</span><br><span class="line">        <span class="built_in">RELEASE_ASSERT_WITH_MESSAGE</span>(fd &gt;= <span class="number">0</span>, <span class="string">&quot;Failed to open shared memory region: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">        sharedData = <span class="built_in">static_cast</span>&lt;SharedData*&gt;(<span class="built_in">mmap</span>(<span class="number">0</span>, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">RELEASE_ASSERT_WITH_MESSAGE</span>(sharedData != MAP_FAILED, <span class="string">&quot;Failed to mmap shared memory region&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dataLogLn</span>(<span class="string">&quot;[COV] edge counters initialized. Shared memory: %s with %zu edges.&quot;</span>, shmKey, edgesStop - edgesStart);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        sharedData = <span class="built_in">static_cast</span>&lt;SharedData*&gt;(<span class="built_in">malloc</span>(SHM_SIZE));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">resetCoverageEdges</span>();</span><br><span class="line"></span><br><span class="line">    sharedData-&gt;numEdges = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(edgesStop - edgesStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同v8的逻辑一致。但是JSC会多一些REPRL相关的接口。</p>
<h3 id="执行器：由REPRL-swift开始"><a href="#执行器：由REPRL-swift开始" class="headerlink" title="执行器：由REPRL.swift开始"></a>执行器：由REPRL.swift开始</h3><p>在目标引擎执行生成的脚本时，执行速度对于fuzzer的性能至关重要。因此实现了两个机制以减少启动新进程时的开销</p>
<ol>
<li>forkserver：与AFL中使用的类似</li>
<li>REPRL：本质上与libFuzzer中实现的进程内fuzz类似</li>
</ol>
<blockquote>
<p>libFuzzer是在单个进程中执行的fuzzer。libFuzzer不会为每个测试用例启动新进程，而是在同一个进程内存中直接处理数据，这减少了启动进程的开销。</p>
</blockquote>
<p>forkserver的核心思想是：节省execve或类似系统调用的大量开销。在目标程序初始化完毕后添加一段代码，等待新的输入样例，每有一个新样例到来都会执行fork()系统调用，由子进程执行输入样例，以避免重复的初始化。</p>
<p>另一种模式称为”Read-Eval-Print-Repeat-Loop”，检测REPRL，该模式会对多个输入重用现有进程，无需fork一个子进程。本质上他修改了引擎，以便从预定义的fd中读入测试样例然后执行，执行完毕后会重置引擎的内部状态并等待下一个程序，这样就可以避免引擎初始化的大量开销。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/676850332">Fuzzilli原理: REPRL - 知乎</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Lobo Q1ng</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2025 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Hello~,<strong>DESTINY</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Fuzz/"># Fuzz</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/03/21/%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">装载与动态链接</a>
            
            
            <a class="next" rel="next" href="/2025/03/12/CVE-2020-9802-JSC%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">CVE-2020-9802 JSC编译优化漏洞复现</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Lobo Q1ng | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>