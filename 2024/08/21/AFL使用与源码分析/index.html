

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/Pi.png">
  <link rel="icon" href="/img/Pi.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lobo Q1ng">
  <meta name="keywords" content="">
  
    <meta name="description" content="AFL基于覆盖率为导向的模糊测试工具 fuzzing 101exercise 1   CVE-2019-13288学习AFL工具的基础使用 123456789101112131415161718192021222324252627# AFL工具下载sudo apt-get updatesudo apt-get install -y build-essential python3-dev autom">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL使用与源码分析">
<meta property="og:url" content="https://loboq1ng.github.io/2024/08/21/AFL%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Q1ng&#39;s blog">
<meta property="og:description" content="AFL基于覆盖率为导向的模糊测试工具 fuzzing 101exercise 1   CVE-2019-13288学习AFL工具的基础使用 123456789101112131415161718192021222324252627# AFL工具下载sudo apt-get updatesudo apt-get install -y build-essential python3-dev autom">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-21T05:59:49.000Z">
<meta property="article:modified_time" content="2025-03-30T09:06:18.179Z">
<meta property="article:author" content="Lobo Q1ng">
<meta property="article:tag" content="Fuzz">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>AFL使用与源码分析 - Q1ng&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"loboq1ng.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Q1ng&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/Townscaper.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="AFL使用与源码分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-21 13:59" pubdate>
          2024年8月21日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          291 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">AFL使用与源码分析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h1><p>基于覆盖率为导向的模糊测试工具</p>
<h2 id="fuzzing-101"><a href="#fuzzing-101" class="headerlink" title="fuzzing 101"></a>fuzzing 101</h2><h3 id="exercise-1-CVE-2019-13288"><a href="#exercise-1-CVE-2019-13288" class="headerlink" title="exercise 1   CVE-2019-13288"></a>exercise 1   CVE-2019-13288</h3><p>学习AFL工具的基础使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">AFL工具下载</span><br>sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools<br>sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-dev<br><br>cd $HOME<br>git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus<br>export LLVM_CONFIG=&quot;llvm-config-12&quot;<br>make distrib		#网络不好可能会报错，部分模式可能用不了，例如unicorn<br>sudo make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用afl-gcc编译目标程序，这是因为通过afl编译，会在目标程序中插桩，反馈程序运行状态信息。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">去到目标程序目录</span><br>export LLVM_CONFIG=&quot;llvm-config-12&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">C程序编译器选择为afl-clang-fast C++程序编译器选择为afl-clang-fast++ --prefix选项是选择编译后可执行文件及依赖存放的位置</span><br>CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;<br>make<br>make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用Afl开始进行fuzz</span><br>afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果出现<span class="hljs-string">&quot;core_pattern&quot;</span> 错误</span><br>sudo su<br>echo core &gt;/proc/sys/kernel/core_pattern<br>exit<br></code></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：</p>
<p>-i	指示输入文件目录</p>
<p>-o	指示存储变异文件的目录，包括crash等等</p>
<p>-s	指示要使用的静态随机种子</p>
<p>@@	</p>
</blockquote>
<p>gdb的使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译时加相关参数</span><br>CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install&quot;<br>make<br>make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">gdb调试</span><br>gdb --args &lt;调试的程序名&gt; &lt;输入&gt;<br></code></pre></td></tr></table></figure>



<h3 id="exercise-2-CVE-2009-3895"><a href="#exercise-2-CVE-2009-3895" class="headerlink" title="exercise 2 CVE-2009-3895"></a>exercise 2 CVE-2009-3895</h3><p>学习AFL++的lto模式</p>
<blockquote>
<p>LTO模式需要LLVM和clang版本大于11，该模式通常是最佳的。随后依次是afl-clang-fast&#x2F;afl-clang-fast++和afl-gcc-fast&#x2F;afl-g++-fast。关于为什么LTO模式通常是最佳的，在未来源码阅读时应该能解释。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">同样的过程，只不过在编译插桩时，使用afl-clang-lto进行编译即可</span><br></code></pre></td></tr></table></figure>



<h3 id="exercise-3-CVE-2017-13028"><a href="#exercise-3-CVE-2017-13028" class="headerlink" title="exercise 3 CVE-2017-13028"></a>exercise 3 CVE-2017-13028</h3><p>使用ASan</p>
<blockquote>
<p>ASan时AddressSanitizer的一个C和C++的内存错误检查工具，包含一个编译器插桩模块和一个运行时库，可以发现对堆、栈和全局对象的越界访问、释放后重利用、双重释放和内存泄漏等错误。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用ASan</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定AFL_USE_ASAN=1 编译选项再使用afl-clang-lto即可</span><br>AFL_USE_ASAN=1 CC=$HOME/AFLplusplus/afl-clang-lto ./configure --prefix=$HOME/fuzzing_tcpdump/tcpdump_install/<br>AFL_USE_ASAN=1 make<br>AFL_USE_ASAN=1 make install<br></code></pre></td></tr></table></figure>

<blockquote>
<p>ASan这个工具，对于FUZZ来说其实是一个负面的作用，因为它的存在，再进行插桩时会造成内存的严重消耗。但是它的主要作用是在crash分析上，我们可以无需经过动态调试(gdb)，就可以得到cransh的相关信息和数据。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意，在运行afl-fuzz的时候，如果开启了ASan，那么就需要使用参数-m none</span><br>afl-fuzz -m none -i $HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/tests/ -o $HOME/fuzzing_tcpdump/out/ -s 123 -- $HOME/fuzzing_tcpdump/tcpdump_install/sbin/tcpdump -vvvvXX -ee -nn -r @@<br></code></pre></td></tr></table></figure>

<blockquote>
<p>-m none是取消内存限制，因为ASan会使用大量的内存</p>
</blockquote>
<p>使用ASan后，gdb调试时就不需要再编译了，直接把crash文件作为参数传入即可</p>
<h3 id="exercise-4-CVE-2016-9297"><a href="#exercise-4-CVE-2016-9297" class="headerlink" title="exercise 4 CVE-2016-9297"></a>exercise 4 CVE-2016-9297</h3><p>lcov工具的使用</p>
<blockquote>
<p>lcov是gcc测试覆盖率的前端图形展示工具。它通过收集多个源文件的行、函数和分支的代码覆盖信息（程序执行之后生成gcda、gcno文件）并且将收集后的信息生成HTML页眉。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一步是需要在编译时，选择参数 --coverage</span><br>CFLAGS=&quot;--coverage&quot; LDFLAGS=&quot;--coverage&quot; ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared<br>make<br>make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二步是利用lcov生成覆盖率信息</span><br>cov --zerocounters --directory ./<br>lcov --capture --initial --directory ./ --output-file app.info<br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w <span class="hljs-variable">$HOME</span>/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</span><br>lcov --no-checksum --directory ./ --capture --output-file app2.info<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>lcov --zerocounters --directory ./</code> : 重置之前的计数</li>
<li><code>lcov --capture --initial --directory ./ --output-file app.info</code> : -c捕获，-i初始化,-d应用的目录，-o输出文件</li>
<li><code>$HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w $HOME/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</code>：执行目标程序，以及目标程序的输入文件。</li>
<li><code>lcov --no-checksum --directory ./ --capture --output-file app2.info</code>：将当前覆盖状态保存到app2.info中</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">最后使用genhtml将覆盖率信息转为html文件</span><br>genhtml --highlight --legend -output-directory ./html-coverage/ ./app2.info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后打开这个html文件，即可看到更直观的代码覆盖率信息</span><br></code></pre></td></tr></table></figure>



<h3 id="exercise-5-CVE-2017-9048"><a href="#exercise-5-CVE-2017-9048" class="headerlink" title="exercise 5 CVE-2017-9048"></a>exercise 5 CVE-2017-9048</h3><p>多实例进行fuzz</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">master instance</span><br>./afl-fuzz -i afl_in -o afl_out -M Master -- ./program @@<br><span class="hljs-meta prompt_"># </span><span class="language-bash">N-1 number of slaves</span><br>./afl-fuzz -i afl_in -o afl_out -S Slave1 -- ./program @@<br>./afl-fuzz -i afl_in -o afl_out -S Slave2 -- ./program @@<br>...<br>./afl-fuzz -i afl_in -o afl_out -S SlaveN -- ./program @@<br></code></pre></td></tr></table></figure>

<p>afl的字典功能——dictionary</p>
<blockquote>
<p>字典就是告诉AFL应该基于什么模板去进行变异，变异后的数据要符合模板的相关结构。这样能大大提高变异后数据有效性</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">afl使用-x指定字典</span><br>afl-fuzz -m none -i ./afl_in -o afl_out -s 123 -x $HOME/AFLplusplus/dictionaries/xml.dict -D -M master -- ./xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@<br></code></pre></td></tr></table></figure>



<h3 id="exercise-6-CVE-2016-4994"><a href="#exercise-6-CVE-2016-4994" class="headerlink" title="exercise 6 CVE-2016-4994"></a>exercise 6 CVE-2016-4994</h3><p>afl的persistent模式</p>
<blockquote>
<p>在persistent模式下，AFL++在单个fork进程中对目标进行多次模糊测试，而不是为每次模糊测试执行fork一个新进程。该模式可以将模糊测试速度提高20倍。</p>
</blockquote>
<h3 id="exercise-8-CVE-2019-14776"><a href="#exercise-8-CVE-2019-14776" class="headerlink" title="exercise 8 CVE-2019-14776"></a>exercise 8 CVE-2019-14776</h3><p>之前都是白盒，有源码的。现在使用afl的qemu-mode对可执行文件进行fuzz</p>
<blockquote>
<p>-Q 选项开启QEMU mode</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#x27;/opt/Adobe/Reader9/Reader/intellinux/lib&#x27; afl-fuzz -Q -i ./afl_in/ -o ./afl_out/ -t 2000 -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript @@<br></code></pre></td></tr></table></figure>





<h2 id="AFL-Source-Code-Analysis"><a href="#AFL-Source-Code-Analysis" class="headerlink" title="AFL Source Code Analysis"></a>AFL Source Code Analysis</h2><h3 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h3><p>第一个函数为<code>find_as</code></p>
<blockquote>
<ul>
<li>AFL_PATH环境变量存在，检查其目录下&#x2F;as文件是否可以访问。可访问则赋值给as_path</li>
<li>AFL_PATH环境变量不存在，检查argv[0]参数（存储afl-gcc.c的文件目录+文件名称），取目录为dir，并且检查dir&#x2F;afl-as是否可访问，若可访问则dir赋值给as_path</li>
</ul>
</blockquote>
<p>第二个函数为<code>edit_params</code></p>
<blockquote>
<p>该函数的主要作用是设置参数，设置编译器(gcc&#x2F;g++&#x2F;clang&#x2F;clang++)。对各个参数进行设置，例如如果存在-fsanitize&#x3D;address，就设置asan_set为1</p>
</blockquote>
<p><code>main</code>函数</p>
<blockquote>
<p>调用以上函数，并调用execvp函数来执行目标文件。</p>
</blockquote>
<h3 id="Assembly-Language-x86"><a href="#Assembly-Language-x86" class="headerlink" title="Assembly Language x86"></a>Assembly Language x86</h3><p>汇编文件后缀.s，用汇编器(Assembler)<code>as</code>把汇编程序中的助记符翻译成机器指令，随机生成目标文件后缀.o。之后使用链接器(linker)将目标文件链接成可执行文件。</p>
<blockquote>
<p><code>#</code>	注释</p>
<p><code>.section</code>	在汇编程序中由<code>.</code>开头的名称并不是助记符，不会被编译成机器指令，而是用于给汇编器一些指令，称为<strong>汇编指示</strong>或<strong>伪操作</strong>。其中<code>section</code>是用于便于汇编器将程序分段，之后被操作系统加载到不同的页，给不同的段设置不同的权限。</p>
<p><code>.data</code>	用于声明变量的，相当于C语言中的全局变量。</p>
<p><code>.text</code>	是用于存放代码的段，是只读、可执行的。其后的指令都属于<code>.text</code>段</p>
<p><code>.globl _start</code>	声明了一个符号，<code>_start</code>是一个符号，符号在汇编语言中代表一个地址，可以用在指令中，在汇编之后所有的符号都会被替换为相应的地址，就像在C语言中我们用变量名来访问变量，其实就是在访问变量所在的地址，调用函数，就是跳转到函数的第一条指令所在的地址，所以变量名和函数名都是符号，代表相应的地址。<code>.globl</code>指示是用于告诉汇编器，<code>_start</code>要被链接器用到，所以在目标文件的表中标记它是一个全局符合。<code>_start</code>就相当于C语言中的main函数，是程序的入口，需要使用<code>.globl</code>声明，链接器在链接过程中要去寻找<code>_start</code>作为程序入口。如果一个符号没有用<code>.globl</code>声明，那么就不会被链接器用到。</p>
<p><code>_start:</code>	程序入口</p>
</blockquote>
<h3 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h3><p>afl-as是afl使用的汇编器，主要是用来给代码插桩。</p>
<p>第一个函数为<code>edit_params</code></p>
<blockquote>
<p>检查并修改参数传递给as。主要是设置as_params的值，以及use_64bit&#x2F;modified_file的值</p>
</blockquote>
<p>第二个函数为<code>add_instrumentation</code></p>
<blockquote>
<p>明确一点，插桩只在<code>.text</code>部分才会进行。插桩是为了反应程序执行状态，所以必须放在汇编<code>.text</code>部分，才能被执行，插桩才是有效的。</p>
<p>而这个函数主要是读取汇编程序，然后逐行分析，是否该行后是否需要插桩。而插桩的条件十分简单粗暴</p>
</blockquote>
<p>插桩的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">^func:			- 函数入口点<br>^.L0:			- GCC 的分支标签<br>^.LBB0_0:		- calng 的分支标签<br>^\tjnz foo		- 条件分支语句，例如循环，判断语句等<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通过判断汇编的前导符号&#x2F;标签来判断这是否是一个分支或者函数，然后插入instrumentation trampoline.</p>
</blockquote>
<p><code>main</code>函数</p>
<blockquote>
<p>设置inst_ratio_str，控制插桩密度等</p>
<p>主要作用是设置各种环境变量</p>
</blockquote>
<h3 id="afl-clang-fast-c"><a href="#afl-clang-fast-c" class="headerlink" title="afl-clang-fast.c"></a>afl-clang-fast.c</h3><p>afl-clang-fast.c其实就是clang的一层封装(wrapper)，与之前的afl-gcc一样，指示定义了一些宏，传递了一些参数给真正的clang而已。</p>
<p>因为AFL对于之前afl-gcc的插桩做法不建议，并提供了更好的工具afl-clang-fast，通过llvm pass来插桩。</p>
<p>第一个函数<code>find_obj</code></p>
<blockquote>
<p>主要是调用afl-clang-fast，三种方式：</p>
<ul>
<li>获取环境变量AFL_PATH的值，如果存在则读取AFL_PATH&#x2F;afl-llvm-rt.o，如果可以访问该文件则设置该目录为obj_path</li>
<li>如果没有环境变量，则检查arg0是否存在<code>/</code>，因为通过终端形式调用afl-clang-fast也很常见。读取该目录下afl-llvm-rt.o文件，此时认为最后一个&#x2F;之前的目录为obj_path。</li>
<li>默认的AFL的MakeFile在编译时会定义一个名为AFL_PATH的宏，其指向&#x2F;usr&#x2F;local&#x2F;lib&#x2F;afl，则在此处寻找afl-llvm-rt.o文件，如果能够访问，同理设置obj_path。</li>
</ul>
<p>三种方式行不通，则抛出异常<code>Unable to find &#39;afl-llvm-rt.o&#39; or &#39;afl-llvm-pass.so&#39;. Please set AFL_PATH</code></p>
</blockquote>
<p>第二个函数<code>edit_params</code></p>
<blockquote>
<p>根据环境变量，用户指定参数来设置参数、宏等。</p>
</blockquote>
<p><code>main</code>函数</p>
<p>寻找obj_path路径</p>
<p>编辑cc_params参数：选择clang,clang++等</p>
<h1 id="AFL-1"><a href="#AFL-1" class="headerlink" title="AFL++"></a>AFL++</h1><h2 id="CmpLog"><a href="#CmpLog" class="headerlink" title="CmpLog"></a>CmpLog</h2><p>To Finish… </p>
<h2 id="记一次Fuzzing-使用ShapFuzz-Debug"><a href="#记一次Fuzzing-使用ShapFuzz-Debug" class="headerlink" title="记一次Fuzzing(使用ShapFuzz) - Debug"></a>记一次Fuzzing(使用ShapFuzz) - Debug</h2><p>一次完整的Fuzzing过程，从main函数处打断点。执行记录如下</p>
<p>调用afl-common.c文件中的get_map_size()</p>
<blockquote>
<p>这个函数通过获取环境变量中的”AFL_MAP_SIZE”和”AFL_MAPSIZE”的值并将其返回。本次运行时，map_size的值为<code>0x800000</code></p>
</blockquote>
<p>调用完成，回到主函数，继续获取环境变量中的”AFL_NO_COLOR”和”AFL_NO_COLOUR”</p>
<blockquote>
<p>switch colored console output off    关闭彩色控制台输出。</p>
</blockquote>
<p>随后调用afl-common.c文件中的argv_cpy_dup(argc,argv_orig);用一个char **ret存储了所有的argv。最后返回ret。</p>
<p>使用<code>calloc</code>给<code>afl_state_t</code>类型的变量指针变量*afl开辟空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//指针afl指向一个afl_state_t的内存块，该内存块大小为sizeof(afl_state_t)</span><br><span class="hljs-type">afl_state_t</span> *afl = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">afl_state_t</span>));<br></code></pre></td></tr></table></figure>

<p>随后调用函数afl-common.c文件中的<code>get_afl_env()</code>来判断”AFL_DEBUG”环境变量是否被设置，若被设置，那么<code>debug=afl-&gt;debug=1</code>。</p>
<p>随后调用afl-fuzz-state.c文件中的<code>afl_state_init(afl,map_size)</code>对afl_state_t这个结构体进行初始化。</p>
<blockquote>
<p>先执行<code>memset(afl, 0, sizeof(afl_state_t));</code>对afl指向的地址块赋0；</p>
<p><code>afl-&gt;shm.map_size = map_size?map_size:MAP_SIZE</code>对结构体的shm.map_size进行赋值操作。选取map_size和全局变量MAP_SIZE中较大的那个。</p>
<p><code>afl-&gt;w_init=0.9;afl-&gt;w_end=0.3;afl-&gt;g_max=5000;afl-&gt;period_pilot_tmp=5000.0</code>初始化这些变量，现在还不知道它们干嘛的。</p>
<p><code>afl-&gt;schedule = FAST;</code>能量调度方式，默认为FAST</p>
<p><code>afl-&gt;havoc_max_mult = HAVOC_MAX_MULT;</code>havoc变异时，每个字节的最大修改次数。</p>
<p>剩余的初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;clear_screen = <span class="hljs-number">1</span>;                <span class="hljs-comment">/* Window resized?                  */</span><br>afl-&gt;havoc_div = <span class="hljs-number">1</span>;                   <span class="hljs-comment">/* Cycle count divisor for havoc    */</span><br>afl-&gt;stage_name = <span class="hljs-string">&quot;init&quot;</span>;             <span class="hljs-comment">/* Name of the current fuzz stage   */</span><br>afl-&gt;splicing_with = <span class="hljs-number">-1</span>;              <span class="hljs-comment">/* Splicing with which test case?   */</span><br>afl-&gt;cpu_to_bind = <span class="hljs-number">-1</span>;<br>afl-&gt;havoc_stack_pow2 = HAVOC_STACK_POW2; <span class="hljs-comment">//控制havoc变异策略用于存储变异操作的栈的大小。</span><br>afl-&gt;hang_tmout = EXEC_TIMEOUT;<br>afl-&gt;exit_on_time = <span class="hljs-number">0</span>;<br>afl-&gt;stats_update_freq = <span class="hljs-number">1</span>;<br>afl-&gt;stats_avg_exec = <span class="hljs-number">0</span>;<br>afl-&gt;skip_deterministic = <span class="hljs-number">1</span>;<br>afl-&gt;cmplog_lvl = <span class="hljs-number">2</span>;<br>afl-&gt;min_length = <span class="hljs-number">1</span>;<br>afl-&gt;max_length = MAX_FILE;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_SPLICING</span><br>afl-&gt;use_splicing = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>afl-&gt;q_testcase_max_cache_size = TESTCASE_CACHE_SIZE * <span class="hljs-number">1048576UL</span>;<br>afl-&gt;q_testcase_max_cache_entries = <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;<br><br></code></pre></td></tr></table></figure>

<p><code>HAVOC_STACK_POW2</code>：havoc变异策略会对输入数据进行一系列的随机修改，以生成新的测试用例。为了提高效率，AFL++会在havoc过程中维护一个栈，用于存储一系列的变异操作。而HAVOC_STACK_POW2可控制着这个栈的大小，这个栈的大小决定了AFL++在一次havoc变异过程中可以执行的变异操作的最大数量。</p>
<p><code>TESTCASE_CACHE_SIZE</code>:AFL++中用于控制测试用例缓存大小的环境变量。AFL++使用了一个缓存来存储已经执行过的测试用例，以便在下次执行时快速检索，避免重复执行。默认值是8MB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;virgin_bits = ck_alloc(map_size);<br>afl-&gt;virgin_tmout = ck_alloc(map_size);<br>afl-&gt;virgin_crash = ck_alloc(map_size);<br>afl-&gt;var_bytes = ck_alloc(map_size);	<span class="hljs-comment">// 存储在fuzzing过程中用到的变异字节数据，一个u8类型数组的指针。</span><br>afl-&gt;top_rated = ck_alloc(map_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)); <span class="hljs-comment">// 存储经过排序的测试用例的指针</span><br>afl-&gt;clean_trace = ck_alloc(map_size);<br>afl-&gt;clean_trace_custom = ck_alloc(map_size);<br>afl-&gt;first_trace = ck_alloc(map_size);<br>afl-&gt;map_tmp_buf = ck_alloc(map_size);<br><br>afl-&gt;fsrv.use_stdin = <span class="hljs-number">1</span>;<br>afl-&gt;fsrv.map_size = map_size;<br><span class="hljs-comment">// afl_state_t is not available in forkserver.c</span><br>afl-&gt;fsrv.afl_ptr = (<span class="hljs-type">void</span> *)afl;<br>afl-&gt;fsrv.add_extra_func = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span> *, u8 *, u32)) &amp; add_extra;<br>afl-&gt;fsrv.exec_tmout = EXEC_TIMEOUT;<br>afl-&gt;fsrv.mem_limit = MEM_LIMIT;<br>afl-&gt;fsrv.dev_urandom_fd = <span class="hljs-number">-1</span>;<br>afl-&gt;fsrv.dev_null_fd = <span class="hljs-number">-1</span>;<br>afl-&gt;fsrv.child_pid = <span class="hljs-number">-1</span>;<br>afl-&gt;fsrv.out_dir_fd = <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure>

<p>virgin_bits，virgin_tmout,virgin_crash分别是初始状态下，目标程序执行过程中覆盖的代码分支，目标程序的执行时间和目标程序是否崩溃。</p>
<p><code>afl-&gt;fsrv_t</code>结构体，用于管理AFL++的Fork Server。</p>
<p><code>fsrv_t</code> 结构体包含了 Fork Server 的各种配置和状态信息，包括：</p>
<ul>
<li><strong><code>use_stdin</code>:</strong>  表示是否使用标准输入 (stdin) 来接收测试用例，默认为 1。</li>
<li><strong><code>map_size</code>:</strong> 表示用于存储执行路径信息的映射表的大小。</li>
<li><strong><code>afl_ptr</code>:</strong> 指向 <code>afl_state_t</code> 结构体的指针，用于在 Fork Server 中访问 <code>afl_state_t</code> 结构体中的信息。</li>
<li><strong><code>add_extra_func</code>:</strong> 指向一个函数指针，用于添加额外的测试用例。</li>
<li><strong><code>exec_tmout</code>:</strong> 表示每个测试用例的执行超时时间。</li>
<li><strong><code>mem_limit</code>:</strong> 表示目标程序的内存使用限制。</li>
<li><strong><code>dev_urandom_fd</code>:</strong>  表示随机数设备文件的描述符。</li>
<li><strong><code>dev_null_fd</code>:</strong>  表示空设备文件的描述符。</li>
<li><strong><code>child_pid</code>:</strong>  表示子进程的进程 ID。</li>
<li><strong><code>out_dir_fd</code>:</strong>  表示输出目录的文件描述符。</li>
</ul>
</blockquote>
<p>随后会调用<code>read_afl_environment()</code>函数，根据诸多环境对afl_state_t这个结构体进行初始化赋值。</p>
<p>doc_path被初始化为：<code>$(PREFIX)/share/doc/afl</code>。然后调用<code>gettimeofday(&amp;tv,&amp;tz)</code>获取当前时间，并存入<code>tv</code>和<code>tz</code>两个结构体中。</p>
<p>执行<code>rand_set_seed(afl, tv.tv_sec ^ tv.tv_usec ^ getpid());</code>该函数在afl-performance.c文件。基于时间生成随机数，存于<code>afl-&gt;init_seed,afl-&gt;rand_seed[0,1,2]</code>中。</p>
<p>再设置<code>afl-&gt;shmem_testcase_mode</code>为1，默认使用共享内存来传递测试用例。</p>
<p>随后是一个循环，调用getopt函数解析命令行参数，并根据参数设置相应的配置选项。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<br>(opt = getopt(<br>  argc, argv,<br>  <span class="hljs-string">&quot;+Ab:B:c:CdDe:E:hi:I:f:F:g:G:l:L:m:M:nNOo:p:RQs:S:t:T:UV:WXx:YZwku&quot;</span>)) &gt;<br>      <span class="hljs-number">0</span>) &#123;<br></code></pre></td></tr></table></figure>

<p><code>&quot;+Ab:B:c:CdDe:E:hi:I:f:F:g:G:l:L:m:M:nNOo:p:RQs:S:t:T:UV:WXx:YZwku&quot;</code>字符串用于指定命令行参数的选项和参数类型。getopt函数每次调用都会解析下一个命令行参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;in_dir <span class="hljs-comment">// 种子池</span><br>afl-&gt;out_dir <span class="hljs-comment">// 输出文件夹</span><br>afl-&gt;fixed_seed <span class="hljs-comment">// 默认值为0，即AFL++使用随机种子，每次运行fuzzing时，都会产生不同的变异序列。为1时，AFL++使用固定的种子，每次运行fuzzing时都会产生相同的变异序列。</span><br>afl-&gt;fsrv.mem_limit <span class="hljs-comment">//为0取消内存限制，其余值即限制内存大小（单位为字节）</span><br></code></pre></td></tr></table></figure></blockquote>
<p>跳出循环后，使用unlikely判断<code>afl-&gt;afl_env.afl_persistent_record</code>是否为空指针。若不为空则FATAL错误。</p>
<blockquote>
<p>afl_persistent_record指针指向<code>afl_persistent_record_t</code>结构体，通过这个指针，AFL++可以访问和更新持久化数据，持久化的意思是，下次启动AFL++能继续使用。此外，通过这个指针还能恢复执行状态，记录Crash等。</p>
</blockquote>
<p>随后调用函数<code>parse_afl_kill_signal_env()</code>函数用来分析终止信号环境变量，FATALs和ERROR等，如果未设置env,则将信号处理程序的env设置未default。并返回default_signal。</p>
<blockquote>
<p>终止进程，当AFL++主进程需要终止process时，它会向fsrv模块发送终止命令，fsrv会使用kill_signal中存储的信号值来终止相应的process。</p>
</blockquote>
<p>执行<code>setup_signal_handlers()</code>函数，也就是信号处理函数，保证了AFL++能够对各种信号进行适当的处理。执行<code>check_asan_opts()</code>函数，设置内存检测工具ASAN。设置<code>afl-&gt;power_name</code>为FAST（默认）。随后同步模式运行AFL++，将<code>auto_sync</code>设置为1，设置<code>afl-&gt;sync_id</code>为default，表示这是一个自动配置的同步示例。<code>afl-&gt;is_secondary_node=1</code>表示这是一个次级节点，用于接收来自主节点的同步信息。</p>
<p>判断是否禁用测试用例的“修剪功能”，即<code>afl-&gt;disable_trim=1</code>禁用。</p>
<blockquote>
<p>测试用例修剪：在AFL++中，测试用例修剪是指通过分析测试用例的执行过程，移除那些对代码覆盖率没有影响的部分，从而所见测试用例的大小，提高模糊测试的效率。当afl-&gt;disable_trim&#x3D;1是，表示禁用修剪功能，AFL++不会对测试用例进行修剪，而是使用完整的测试用例进行模糊测试。</p>
</blockquote>
<p>若<code>afl-&gt;afl_env.afl_statsd</code>不为空，则调用<code>statsd_setup_format(afl)</code>函数。</p>
<blockquote>
<p><code>afl-&gt;afl_env.afl_statsd</code>是AFLpp中用来配置StatsD统计数据发送的变量，用户可以将AFL++的统计数据发送到StatsD服务器，方便监控和分析模糊测试过程，提高模糊测试效率。</p>
<p>而statsd_setup_format()函数根据<code>AFL_STATSD_TAGS_FLAVOR</code>环境变量的标签类型，选择相应的格式，以便AFL++可以将统计数据以正确的格式发送到StatsD服务器。格式有：<code>dogstatsd</code>，<code>librato</code>，<code>influxdb</code>，<code>signalfx</code>等。</p>
</blockquote>
<p><code>afl-&gt;use_banner</code>值默认为True，控制着是否在启动时显示欢迎信息。</p>
<p>随后判断是否为AFLFast~RARE模式之间，是的话，对<code>afl-&gt;n_fuzz</code>进行开辟空间。</p>
<p>随后，又是一波环境变量初始化操作。接下来是判断是否启用自动恢复功能，自动恢复功能是指当AFL++进程意外终止时，它会尝试恢复之前的运行状态，例如恢复测试用例队列、代码覆盖率信息以及其他相关数据。当<code>afl-&gt;afl_env.afl_autoresume</code>为true时，启用自动恢复功能。</p>
<p>然后也是一系列的初始化值，初始化时都默认为0所以都跳过了。</p>
<blockquote>
<p><code>afl-&gt;afl_env.afl_max_det_extras</code>用来控制AFL++在执行确定性模糊测试时，最多生成多少个额外的测试用例。AFL++可以执行两种类型的模糊测试：随机模糊测试和确定性模糊测试。确定性模糊测试会系统地尝试所有可能的变异操作，以确保覆盖所有可能的输入数据。额外的测试用例是指在执行确定性模糊测试时，除了初始的测试用例之外，还会生成一些额外的测试用例，用于覆盖一些特殊的输入情况。</p>
<p>如果没设置这个变量的话，那么会默认为256个。</p>
</blockquote>
<p>由于进行基本的Fuzzing，那么初始化时<code>afl-&gt;afl_env</code>的成员变量全被赋值为0，因此大部分初始化操作都会跳过。 执行到生成fuzz data时，需要开辟缓存空间。使用AFL_BUF_PARAM宏定义，用于定义测试用例缓冲区大小。<code>afl_realloc(AFL_BUF_PARAM(in_scratch), min_alloc);</code>这个语句的作用是使用afl_realloc()函数，为in_scratch指向的测试用例缓冲区重新分配内存，分配的内存大小为min_alloc。</p>
<p>后续也是一系列初始化行动。执行至<code>setup_custom_mutators()</code>，该函数负责从用户指定的库文件或命令行参数中加载自定义变异器，并将它们添加到AFL++的变异器列表中。随后的<code>write_setup_file()</code>通过将当前模糊测试的环境变量和命令行参数写入fuzzer_setup文件，记录当前模糊测试的配置信息。<code>fuzzer_cmdline()</code>函数是将当前命令行参数写入文件中。<code>read_testcases()</code>函数用于从输入目录读取所有测试用例，并将它们排队等待测试。<code>pivot_inputs()</code>函数的主要作用是为输入测试用例创建硬链接，并根据需要调整文件名。</p>
<p>随后的<code>if (!afl-&gt;fsrv.out_file) </code>语句内容，是在命令行参数中查找包含”@@”的参数，并根据需要设置输出文件路径。<code>check_binary(afl, argv[optind]);</code>这个函数的主要目的是确保目标二进制文件存在且可执行，并且在某些模式下跳过进一步的检查。<code>  setup_testcase_shmem(afl)</code>函数是为AFL++配置共享内存，以便在模糊测试过程中使用共享内存来存储和传递测试用例数据。</p>
<p>跳过一些初始化空间以及为一些模式做初始化的操作后（本次测试并未启用任何其他模式）</p>
<p>后续检查共享内存的大小，如果小于等于全局变量<code>DEFAULT_SHMEM_SIZE</code>，将其设置为共享内存大小，并将其值存储在环境变量<code>AFL_MAP_SIZE</code>中。<code>load_auto(afl)</code>用于加载字典。<code>deunicode_extras()</code>函数旨在处理额外数据。（此次运行并没有额外数据）</p>
<p><code>afl-&gt;in_bitmap</code>记录已经测试过的输入数据的特征信息，其实际也是一个位图，每个位代表一个特定的输入特征。当AFL++测试一个新的输入数据时，会根据该输入数据计算出一些特征信息，并将对应的位图设置为1，表示该特征已经被测试过。AFL++能够根据<code>afl-&gt;in_bitmap</code>来判断新的输入数据是否已经测试过，避免重复测试或类似的输入数据，从而提高测试效率。</p>
<p>而<code>afl-&gt;virgin_bits</code>是一个用来记录程序尚未覆盖的执行路径的位图。它是一个字节数组，每个字节代表8个不同的执行路径分支。当AFL++执行一个测试用例时，它会根据程序执行的路径更新<code>afl-&gt;virgin_bits</code>，将对应路径的位设置为0，表示该路径已经被覆盖。初始化时，其被设置为255。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">perform_dry_run(afl);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">函数首先遍历afl数据结构中的所有队列项，对于每一项检查该项是否被有效且未被禁用。如果该项有效，尝试打开与测试用例关联的文件并将其内容读入内存。然后关闭文件，使用`calibrate_case`函数校准测试用例。</span><br><span class="hljs-comment">通过dry_run，确保所有初始测试用例都已正确处理，并为后续的fuzzing做好准备。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>随后，为缓存数组<code>afl-&gt;q_testcase_cache</code>分配一个大小为<code>afl-&gt;q_testcase_max_cache_entries</code>的内存块。</p>
<p>执行<code>cull_queue</code>函数通过标记和优化队列中的测试用例，确保在模糊测试过程中优先处理那些对覆盖率有贡献的测试用例。</p>
<blockquote>
<p>cull_queue首先检查<code>afl-&gt;score_changed</code>是否为0，如果为0 则直接返回，表明未发生改变。否则，执行cull_queue，首先初始化变量，重置所有队列项的favored标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; afl-&gt;queued_itedms; i++)&#123;<br>afl-&gt;queue_buf[i]-&gt;favored = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>标记新的favored条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">遍历afl-&gt;fsrv.map_size中的每个字节。如果afl-&gt;top_rated[i]存在且temp_v中对应的位被设置，则将afl-&gt;top_rated[i]标记为favored，并更新temp_v，移除当前条目对应的所有位。</span><br><span class="hljs-comment">*/</span>		<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; afl-&gt;fsrv.map_size; ++i)&#123;<br><span class="hljs-keyword">if</span> (afl-&gt;top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="hljs-number">3</span>] &amp; (<span class="hljs-number">1</span> &lt;&lt; (i &amp; <span class="hljs-number">7</span>)))) &#123;<br>	u32 j = len;<br>	<span class="hljs-keyword">while</span> (j--) &#123;<br>	<span class="hljs-keyword">if</span> (afl-&gt;top_rated[i]-&gt;trace_mini[j]) &#123;<br>	temp_v[j] &amp;= ~afl-&gt;top_rated[i]-&gt;trace_mini[j];<br>	&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!afl-&gt;top_rated[i]-&gt;favored) &#123;<br>afl-&gt;top_rated[i]-&gt;favored = <span class="hljs-number">1</span>;<br>++afl-&gt;queued_favored;<br><span class="hljs-keyword">if</span> (!afl-&gt;top_rated[i]-&gt;was_fuzzed) &#123; ++afl-&gt;pending_favored; &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>标记冗余条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; afl-&gt;queued_items; i++) &#123;<br><span class="hljs-keyword">if</span> (likely(!afl-&gt;queue_buf[i]-&gt;disabled)) &#123;<br>mark_as_redundant(afl, afl-&gt;queue_buf[i], !afl-&gt;queue_buf[i]-&gt;favored);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 遍历所有队列项，如果队列项未被禁用，则调用mark_as_redundant()函数，将其标记为冗余或者非冗余，具体取决于其favored标志。</span><br></code></pre></td></tr></table></figure></blockquote>
<p>随后循环queue_buf，确保存在一个合法(没有被禁用)种子。</p>
<p>函数<code>show_init_stat</code>主要目的是在AFL++ 处理输入目录后，显示一些统计信息和警告，调整一些参数以优化模糊测试执行。接下来是判断是否有上一次种子的选择。此次执行为全新执行，因此无。且后续判断是否为恢复执行，也无。</p>
<p>随后会记录状态，执行函数<code>write_stats_file</code>，更新统计文件。它记录了各种运行时的统计数据，包括执行次数，覆盖率，稳定性等。并在调试模式下记录额外的信息。</p>
<p>执行函数<code>maybe_update_plot_file</code>，更新AFL的plot file，记录各种统计数据。包括相对时间、周期数、当前条目、队列项数、未模糊测试的项数、保存的Crashes、保存的挂起数、最大深度、每秒执行次数等。</p>
<p>随后调用函数<code>save_auto</code>，这个函数保存自动生成的额外输入。本次执行无额外输入，即进入函数则返回。</p>
<p>随后进入Fuzzing的主体循环。<code>while(likely(!afl-&gt;stop_soon))</code>，likely是一个宏，用于优化代码的执行效率，它告诉编译器，循环条件很有可能为true。编译器会根据这个提示对代码进行优化。</p>
<blockquote>
<p><code>afl-&gt;stop_soon</code>是AFL++中用于控制模糊测试过程是否停止的标志位。允许用户根据需要手动停止模糊测试，或设置时间限制和目标漏洞等条件，从而更有效地进行模糊测试。</p>
</blockquote>
<p>循环第一行执行一个<code>cull_queue(afl)</code>。第一次循环，<code>afl-&gt;score_changed</code>依然为1，因此不执行cull_queue主体。直接返回。</p>
<p>接下来是<code>if (unlikely((!afl-&gt;old_seed_selection &amp;&amp; runs_in_current_cycle &gt; afl-&gt;queued_items) || (afl-&gt;old_seed_selection &amp;&amp; !afl-&gt;queue_cur)))</code>一个判断，</p>
<blockquote>
<p>条件<code>!afl-&gt;old_seed_selection &amp;&amp; runs_in_current_cycle &gt; afl-&gt;queued_items</code>：如果没有使用旧的种子选择策略，并且当前循环中的运行周期超过了队列中的种子数量。则进入执行体。</p>
<p>条件<code>afl-&gt;old_seed_selection &amp;&amp; !afl-&gt;queue_cur</code>：如果使用了旧的种子选择策略，并且当前队列指针为空的话，那么进入执行体。</p>
<p>unlikely说明这个条件很少为真。</p>
</blockquote>
<p>本次执行，第一个条件为真，进入执行体。</p>
<p>紧接着是第二个if语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 第一个条件afl-&gt;last_sync_cycle &lt; afl-&gt;queue_cycle:如果上次同步周期小于当前队列周期 !afl-&gt;queue_cycle &amp;&amp; afl-&gt;afl_env.afl_import_first:如果当前队列周期为0，并且环境变量afl_import_first被设置。两个条件都被满足即进入执行体。</span><br><span class="hljs-comment">// 第二个条件 afl-&gt;sync_id:同步id是否存在。</span><br><span class="hljs-keyword">if</span> (unlikely((afl-&gt;last_sync_cycle &lt; afl-&gt;queue_cycle ||<br>                (!afl-&gt;queue_cycle &amp;&amp; afl-&gt;afl_env.afl_import_first)) &amp;&amp;<br>               afl-&gt;sync_id)) &#123;<br>    sync_fuzzers(afl);<br>&#125;<br><span class="hljs-comment">// 这个同步id应该是多个afl++进程被执行时需要同步。</span><br><span class="hljs-comment">// 本次执行只有一个afl++主体， 因此不用执行。</span><br><span class="hljs-comment">// sync_fuzzers(afl)是用来同步fuzzers的函数</span><br></code></pre></td></tr></table></figure>

<p>进入后续if执行体，紧接着是几个赋值语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 更新队列周期和重置变量</span><br>++afl-&gt;queue_cycle;<br>runs_in_current_cycle = (u32)<span class="hljs-number">-1</span>;<br>afl-&gt;cur_skipped_items = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>随后是一个if语句处理旧的种子选择策略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-keyword">if</span> (unlikely(afl-&gt;old_seed_selection)) &#123;<br>        afl-&gt;current_entry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (unlikely(afl-&gt;current_entry &lt; afl-&gt;queued_items &amp;&amp;<br>                        afl-&gt;queue_buf[afl-&gt;current_entry]-&gt;disabled)) &#123;<br>          ++afl-&gt;current_entry;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (afl-&gt;current_entry &gt;= afl-&gt;queued_items) &#123; afl-&gt;current_entry = <span class="hljs-number">0</span>; &#125;<br>        afl-&gt;queue_cur = afl-&gt;queue_buf[afl-&gt;current_entry];<br>        <span class="hljs-keyword">if</span> (unlikely(seek_to)) &#123;<br>          <span class="hljs-keyword">if</span> (unlikely(seek_to &gt;= afl-&gt;queued_items)) &#123;<br>            <span class="hljs-comment">// This should never happen.</span><br>            FATAL(<span class="hljs-string">&quot;BUG: seek_to location out of bounds!\n&quot;</span>);<br>          &#125;<br>          afl-&gt;current_entry = seek_to;<br>          afl-&gt;queue_cur = afl-&gt;queue_buf[seek_to];<br>          seek_to = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br><span class="hljs-comment">//主要是更新`current_entry`和`queue_cur`</span><br></code></pre></td></tr></table></figure>

<p>接下来是一个if语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(afl-&gt;not_on_tty)) &#123;<br><br>  ACTF(<span class="hljs-string">&quot;Entering queue cycle %llu.&quot;</span>, afl-&gt;queue_cycle);<br>  fflush(<span class="hljs-built_in">stdout</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这个语句会先判断<code>afl-&gt;not_on_tty</code>，也就是当其值为true时，表示AFL++不是在tty终端上运行。在环境变量AFL_NO_UI的值，如果为真，则设置<code>not_on_tty</code>为true.</p>
</blockquote>
<p>本次由于在调试环境，因此也没有开启UI，所以此值为1，进入执行体，将输出当前周期。接下来是一个大的if语句。外层循环如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果整个队列循环结束后都没有发现新的测试用例，那么接下来尝试使用重组策略。</span><br><span class="hljs-keyword">if</span> (unlikely(afl-&gt;queued_items == prev_queued<br>             <span class="hljs-comment">/* FIXME TODO <span class="hljs-doctag">BUG:</span> &amp;&amp; (get_cur_time() - afl-&gt;start_time) &gt;= 3600 */</span><br>             ))<br><span class="hljs-comment">// 这个判断条件即是，如果当前队列项（种子池中的种子数量）== 先前队列项。那么进入执行体。</span><br></code></pre></td></tr></table></figure>

<p>由于这是第一次执行，因此<code>pre_queued</code>的值为0，而初始种子数量为2，当前<code>afl-&gt;queued_items</code>为2。因此会跳过这个if。来到else部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> &#123;<br><br>        afl-&gt;cycles_wo_finds = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 即一个完整的队列周期内发现了新的测试用例，则将`cycles_wo_finds`计数器置0</span><br></code></pre></td></tr></table></figure>

<p>接下来是判断<code>cycle_schedules,          /* cycle power schedules?      */</code>，其值为0；那么跳过这个执行体。跳过能量调度策略的选择。</p>
<p>这个大if的执行体最后一个语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将当前种子池的种子数量赋给prev_queued，用来判断下次循环时，是否生成新的测试用例。</span><br>prev_queued = afl-&gt;queued_items;<br></code></pre></td></tr></table></figure>

<p>跳出if后，执行<code>++runs_in_current_cycle;</code>这个runs_in_current_cycle的值初始化为<code>(u32)-1</code>，那么经过加1后，变成了<code>0</code>。</p>
<p>接下来是一个<code>do-while</code>循环体。第一段代码为一个if判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检查是否使用旧的种子选择策略。      </span><br><span class="hljs-keyword">if</span> (likely(!afl-&gt;old_seed_selection)) &#123;<br>    <span class="hljs-comment">// 如果有新的测试实例，或者需要重新初始化alias 表。</span><br>    <span class="hljs-keyword">if</span> (unlikely(prev_queued_items &lt; afl-&gt;queued_items || afl-&gt;reinit_table)) &#123;<br>        <span class="hljs-comment">// we have new queue entries since the last run, recreate alias table</span><br>        prev_queued_items = afl-&gt;queued_items; <span class="hljs-comment">// 更新prev_queued_items</span><br>        create_alias_table(afl); <span class="hljs-comment">// 新建alias_table</span><br>    &#125;<br>    <span class="hljs-comment">// 选择下一个队列条目</span><br>    afl-&gt;current_entry = select_next_queue_entry(afl);<br>    <span class="hljs-comment">// 更新当前队列条目指针</span><br>    afl-&gt;queue_cur = afl-&gt;queue_buf[afl-&gt;current_entry];<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>select_next_queue_entry</code>是一个内联函数，用于从队列中选择下一个条目。它使用了一种称为别名方法(alias method)的算法来实现快速选择。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* select next queue entry based on alias algo - fast! */</span><br><span class="hljs-keyword">inline</span> u32 <span class="hljs-title function_">select_next_queue_entry</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl)</span> &#123;<br><span class="hljs-comment">// 生成一个在[0,afl-&gt;queue_items-1]范围内的随机数s，表示初步选择的队列条目索引。</span><br>u32    s = rand_below(afl, afl-&gt;queued_items);<br><span class="hljs-comment">// 生成一个在[0.0, 1.0]范围内的随机浮点数p，表示一个随机概率。</span><br><span class="hljs-type">double</span> p = rand_next_percent(afl);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">fprintf(stderr, &quot;select: p=%f s=%u ... p &lt; prob[s]=%f ? s=%u : alias[%u]=%u&quot;</span><br><span class="hljs-comment">&quot; ==&gt; %u\n&quot;, p, s, afl-&gt;alias_probability[s], s, s, afl-&gt;alias_table[s], p &lt;</span><br><span class="hljs-comment">afl-&gt;alias_probability[s] ? s : afl-&gt;alias_table[s]);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// afl-&gt;alias_probability[s]这是一个概率数组，存储了每个条目的选择概率。</span><br><span class="hljs-comment">// afl-&gt;alias_table[s]这是一个别名数组，存储了每个条目的别名索引</span><br><span class="hljs-comment">// 如果随机概率p小于s条目的选择概率，则返回s；否则返回s条目的别名索引</span><br><span class="hljs-keyword">return</span> (p &lt; afl-&gt;alias_probability[s] ? s : afl-&gt;alias_table[s]);<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<p>随后进入fuzzing函数<code>fuzz_one_original(afl)</code>，这个函数是afl-fuzz-one.c中的函数。这个函数很长…</p>
<p>执行完一些变量的初始化后，来到该函数的第一个if判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// afl-&gt;custom_mutators_count 是一个整数变量，用于记录用户自定义变异器的数量。</span><br><span class="hljs-keyword">if</span>(unlikely(afl-&gt;custom_mutators_count))&#123;<br><span class="hljs-comment">/* The custom mutator will decide to skip this test case or not. */</span><br>LIST_FOREACH(&amp;afl-&gt;custom_mutator_list, <span class="hljs-keyword">struct</span> custom_mutator, &#123;<br>    <span class="hljs-keyword">if</span> (el-&gt;afl_custom_queue_get &amp;&amp;<br>        !el-&gt;afl_custom_queue_get(el-&gt;data, afl-&gt;queue_cur-&gt;fname)) &#123;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125;<br><br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 本次执行没有custom_mutators，因此会跳过这个执行体。</span><br></code></pre></td></tr></table></figure>

<p>接下来就是第二个if判断<code>pending_favored,          /* Pending favored paths </code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// afl-&gt;pending_favored用于统计当前待处理的优先测试用例数量，也就是favored的还未测试的测试用例数量，这里为2。</span><br><span class="hljs-keyword">if</span> (likely(afl-&gt;pending_favored)) &#123;<br><br>    <span class="hljs-comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span><br><span class="hljs-comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span><br><span class="hljs-comment">       cases. */</span><br>	<span class="hljs-comment">// afl-&gt;queue_cur-&gt;fuzz_level:当前条目的模糊迭代次数。如果这个值为非零，表示该条目已经被模糊测试过。</span><br>    <span class="hljs-comment">// afl-&gt;queue_cur-&gt;favored:当前队列条目是否为优先。如果这个值为真，表示该条目是优先条目。</span><br>    <span class="hljs-comment">// 生成一个0-99的整数，并检查它是否小于SKIP_TO_NEW_PROB(这个宏指跳到新条目的概率)</span><br>    <span class="hljs-keyword">if</span> ((afl-&gt;queue_cur-&gt;fuzz_level || !afl-&gt;queue_cur-&gt;favored) &amp;&amp;<br>        likely(rand_below(afl, <span class="hljs-number">100</span>) &lt; SKIP_TO_NEW_PROB)) &#123;<br>        <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<p>这个if的逻辑是，如果当前条目已经被模糊测试过，或者（当前条目不是优先条目，且生成的随机数小于SKIP_TO_NEW_PROB），则返回1，表示跳过当前条目，可能跳到一个新的优先条目。在本次执行中，<code>afl-&gt;queue_cur-&gt;fuzz_level</code>为0，且当前队列条目为优先。会跳过这个if。跳过后，没有其他语句，上一层<code>if (likely(afl-&gt;pending_favored))</code>便也结束了。</p>
<p>接下来，来到<code>if(unlikely(afl-&gt;not_on_tty))</code>判断，也就是继续往终端输出一些信息了。</p>
<p>信息输入完成后，执行语句<code>orig_in = in_buf = queue_testcase_get(afl, afl-&gt;queue_cur);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> u8 *<span class="hljs-title function_">queue_testcase_get</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl, <span class="hljs-keyword">struct</span> queue_entry *q)</span> &#123;<br>    <span class="hljs-comment">// 保存队列条目q的长度</span><br>    u32 len = q-&gt;len;<br>    <span class="hljs-comment">/* first handle if no testcase cache is configured */</span><br>    <span class="hljs-comment">// afl-&gt;q_testcase_max_cache_size表示测试用例缓存的最大大小。如果未配置缓存（即为0），则进入这个分支。</span><br>    <span class="hljs-keyword">if</span> (unlikely(!afl-&gt;q_testcase_max_cache_size)) &#123;<br>        <span class="hljs-comment">// buf:用于存储测试用例数据的缓冲区指针</span><br>        u8 *buf;<br>        <span class="hljs-comment">// 如果当前队列条目是afl-&gt;queue_cur，则重新分配afl-&gt;testcase_buf</span><br>        <span class="hljs-keyword">if</span> (unlikely(q == afl-&gt;queue_cur)) &#123;<br>            <span class="hljs-comment">// testcase_buf用于存储当前测试用例数据</span><br>            buf = afl_realloc((<span class="hljs-type">void</span> **)&amp;afl-&gt;testcase_buf, len);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则，重新分配afl-&gt;splicecase_buf</span><br>            <span class="hljs-comment">// splicecase_buf用于 存储拼接后的测试用例数据</span><br>            buf = afl_realloc((<span class="hljs-type">void</span> **)&amp;afl-&gt;splicecase_buf, len);<br>        &#125;<br>        <span class="hljs-comment">// 检查内存是否分配成功</span><br>        <span class="hljs-keyword">if</span> (unlikely(!buf)) &#123;<br>            PFATAL(<span class="hljs-string">&quot;Unable to malloc &#x27;%s&#x27; with len %u&quot;</span>, q-&gt;fname, len);<br>    &#125;<br>    <span class="hljs-comment">// 打开文件并读取数据</span><br>    <span class="hljs-type">int</span> fd = open(q-&gt;fname, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (unlikely(fd &lt; <span class="hljs-number">0</span>)) &#123; PFATAL(<span class="hljs-string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname); &#125;<br>    <span class="hljs-comment">// 从文件描述符fd中取len字节的数据到缓冲区buf中</span><br>    ck_read(fd, buf, len, q-&gt;fname);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来是记录当前队列的长度<code>len = afl-&gt;queue_cur-&gt;len</code>；随后给out_buf 分配len长度的空间。</p>
<p>再重置<code>afl-&gt;subseq_tmouts=0</code>；subseq_tmouts的值记录着连续超时的次数。如果一个测试用例运行超时，计数器会增加。</p>
<p><code>afl-&gt;cur_depth = afl-&gt;queue_cur-&gt;depth;</code>afl-&gt;cur_depth这个成员变量表示当前测试用例在输入队列中的深度。而afl-&gt;queue_cur-&gt;depth是当前队列条目的深度，每个队列条目代表一个测试用例，depth表示该测试用例在输入队列中的深度。当前执行的测试用例的深度赋值给afl的全局变量，为后续测试方便使用这个深度信息。</p>
<p>接下来是一个if语句<code>if (unlikely(afl-&gt;queue_cur-&gt;cal_failed))</code>，对于成员变量<code>afl-&gt;queue_cur-&gt;cal_failed</code>，其中<code>afl-queue_cur</code>是一个指向当前正在处理的队列条目的指针。每个队列条目代表一个测试用例。cal_failed是一个布尔类型成员变量，用于指示当前测试用例的校准是否失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> (unlikely(afl-&gt;queue_cur-&gt;cal_failed)) &#123;<br>   <span class="hljs-comment">// 初始化一个变量res为FSRV_RUN_TMOUT，表示运行超时</span><br>   u8 res = FSRV_RUN_TMOUT;<br>   <span class="hljs-comment">// 检查校准失败的次数是否小于预定义的阈值CAL_CHANCES</span><br>   <span class="hljs-keyword">if</span> (afl-&gt;queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;<br><span class="hljs-comment">// 如果失败次数小于阈值，则将当前队列项的执行校验和重置</span><br>     afl-&gt;queue_cur-&gt;exec_cksum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 调用calibrate_case函数重新校准，将结果存在res中。</span><br>     res =<br>         calibrate_case(afl, afl-&gt;queue_cur, in_buf, afl-&gt;queue_cycle - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 如果再次校准失败，则报错。</span><br>     <span class="hljs-keyword">if</span> (unlikely(res == FSRV_RUN_ERROR)) &#123;<br><br>       FATAL(<span class="hljs-string">&quot;Unable to execute target application&quot;</span>);<br><br>     &#125;<br><br>   &#125;<br><span class="hljs-comment">// 检查是否需要停止fuzzing或者校准结果是否与afl-&gt;crash_mode一致。</span><br>   <span class="hljs-keyword">if</span> (unlikely(afl-&gt;stop_soon) || res != afl-&gt;crash_mode) &#123;<br><span class="hljs-comment">// 增加跳过测试实例数量</span><br>     ++afl-&gt;cur_skipped_items;<br>   <span class="hljs-comment">// 跳转到abandon_entry标签</span><br>     <span class="hljs-keyword">goto</span> abandon_entry;<br><br>   &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure>

<p>随后是“修剪”操作，接下来的if语句判断是否需要对当前队列进行修剪操作。修剪操作用于减少输入的大小，同时保持其有效性，以提高模糊测试效率。以下对这个if语句进行详细解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// afl-&gt;non_instrumented_mode 为1表示处于非插桩模式，0表示处于插桩模式</span><br><span class="hljs-comment">// afl-&gt;queue_cur-&gt;trim_done 为1表示当前队列项已经完成修剪，0表示未完成</span><br><span class="hljs-comment">// afl-&gt;disable_trim 为1表示禁用修剪操作，0表示启用修剪操作</span><br><span class="hljs-keyword">if</span> (unlikely(!afl-&gt;non_instrumented_mode &amp;&amp; !afl-&gt;queue_cur-&gt;trim_done &amp;&amp;<br>               !afl-&gt;disable_trim)) &#123;<br>	<span class="hljs-comment">// 当前模式是插桩模式，当前队列项没有完成修剪，修剪操作是启用状态，则执行循环体。</span><br>    <span class="hljs-comment">// 保存当前队列项的长度（当前测试实例的长度）</span><br>    u32 old_len = afl-&gt;queue_cur-&gt;len;<br>	<span class="hljs-comment">// 调用trim_case函数执行修剪操作，下面有对trim_case的详细说明</span><br>    u8 res = trim_case(afl, afl-&gt;queue_cur, in_buf);<br>    orig_in = in_buf = queue_testcase_get(afl, afl-&gt;queue_cur);<br><br>    <span class="hljs-keyword">if</span> (unlikely(res == FSRV_RUN_ERROR)) &#123;<br><br>      FATAL(<span class="hljs-string">&quot;Unable to execute target application&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (unlikely(afl-&gt;stop_soon)) &#123;<br><br>      ++afl-&gt;cur_skipped_items;<br>      <span class="hljs-keyword">goto</span> abandon_entry;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* Don&#x27;t retry trimming, even if it failed. */</span><br><br>    afl-&gt;queue_cur-&gt;trim_done = <span class="hljs-number">1</span>;<br><br>    len = afl-&gt;queue_cur-&gt;len;<br><br>    <span class="hljs-comment">/* maybe current entry is not ready for splicing anymore */</span><br>    <span class="hljs-comment">// 如果当前测试实例的长度小于或等于4并且修剪前的长度大于4，那么，当前条目不进行拼接变异。</span><br>    <span class="hljs-keyword">if</span> (unlikely(len &lt;= <span class="hljs-number">4</span> &amp;&amp; old_len &gt; <span class="hljs-number">4</span>)) --afl-&gt;ready_for_splicing_count;<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如何进行“修剪”操作？trim_case函数做了什么？</p>
<p>trim_case函数很长，大概步骤如下：</p>
<ol>
<li><p>保存原始长度</p>
</li>
<li><p>自定义变异器修剪</p>
<p>如果，<code>afl-&gt;custom_mutators_count&gt;=1</code>则尝试使用用户自定义的变异器进行修剪。如果修剪成功，返回修剪结果。</p>
<p>trimmed_case用于存储修剪结果，custom_trimmed用于标记是否进行了自定义变异器修剪。随后遍历自定义变异器列表，检查并调用自定义修剪函数trim_case_custom。</p>
<p>这里就是对于每个自定义变异器，检查其是否实现了afl_custom_trim函数，如果实现了，调用trim_case_custom函数进行修剪，并将结果存储在trimmed_case中，同时将custom_trimmed标记为true。然后，如果自定义变异器的修剪成功，恢复原始测试用例，返回修剪结果。</p>
</li>
<li><p>处理初始种子长度小于5的情况</p>
<p>对满足条件的种子，为map分配空间，并初始化。为mutated_pos分配空间，并初始化。</p>
</li>
<li><p>对测试实例进行修剪</p>
<p>循环执行，直到<code>remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, (u32)TRIM_MIN_BYTES)</code>；其中，remove_len表示要移除的字节数，len_p2是大于等于<code>q-&gt;len</code>的最小2的幂次方。TRIM_END_STEPS是一个常量，表示修剪开始时的步长。TRIM_MIN_BYTES表示修建时的最小字节数。</p>
<p>随后初始化remove_pos为remove_len，表示从这个位置开始尝试删除数据。下一步进入内层循环<code>while(remove_pos &lt; q-&gt;len)</code>，进入内层循环遍历输入数据，尝试从remove_pos开始删除remove_len字节的数据。写入带有间隙的数据：<code>write_with_gap(afl, in_buf, q-&gt;len, remove_pos, trim_avail);</code>将输入数据写入目标程序，带有间隙（即删除部分的数据不写入目标程序）。再调用<code>fuzz_run_target</code>函数运行目标程序。随后检查运行结果，如果发生错误或需要停止，则跳转到<code>abort_trimming</code>标签进行放弃修剪。若正常运行，则计算执行路径的哈希值<code>cksum=hash64(afl-&gt;fsrv.trace_bits, afl-&gt;fsrv.map_size, HASH_CONST);</code>。然后使用该hash值与测试实例的hash值进行比对，如果相同，代表删除数据后的执行路径与原始路径相同，则认为删除是有效的，更新输入数据和相关信息。</p>
<p>随后，减少删除长度<code>remove_len &gt;&gt;= 1;</code>，每次循环结束后，进入新循环前，将remove_len减半，以便在下次循环中尝试删除更小的数据块。</p>
</li>
<li><p>修剪结束后，检查是否需要写回操作</p>
<p>也就是if语句的判断条件<code>needs_write</code>；如果needs_write为真，表示in_buf已经被修改，需要更新磁盘上的测试用例文件。也就是上述修剪成功后更新输入数据的操作改变in_buf。相应地，需要修改磁盘上的文件。但是这其中调用<code>update_bitmap_score</code>函数进行更新位图和得分。是为啥？</p>
<p>关于<code>update_bitmap_score()</code>函数逻辑作如下说明：</p>
<ol>
<li><p>首先定义三个变量</p>
<p><code>i</code>:用于循环遍历AFL的位图；<code>fav_factor</code>:当前路径的评分因子；<code>fuzz_p2</code>:当前路径的模糊测试优先级。</p>
</li>
<li><p>计算<code>fuzz_p2</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(afl-&gt;schedule &gt;= FAST &amp;&amp; afl-&gt;schedule &lt; RARE))<br>  fuzz_p2 = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Skip the fuzz_p2 comparison</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unlikely(afl-&gt;schedule == RARE))<br>  fuzz_p2 = next_pow2(afl-&gt;n_fuzz[q-&gt;n_fuzz_entry]);<br><span class="hljs-keyword">else</span><br>  fuzz_p2 = q-&gt;fuzz_level;<br></code></pre></td></tr></table></figure>

<p>根据AFL的调度策略，计算fuzz_p2。如果调度策略在FAST和RARE之间，跳过fuzz_p2比较。设置为0.如果调度策略是RARE，使用next_pow2函数计算fuzz_p2。其他所有情况下的fuzz_p2设置为<code>q-&gt;fuzz_level</code>；</p>
</li>
<li><p>计算<code>fuzz_factor</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(afl-&gt;schedule &gt;= RARE) || unlikely(afl-&gt;fixed_seed)) &#123;<br>  fav_factor = q-&gt;len &lt;&lt; <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  fav_factor = q-&gt;exec_us * q-&gt;len;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据调度策略和是否使用固定种子（<code>afl-&gt;fixed_seed</code>），计算<code>fav_factor</code>。如果调度策略是RARE或使用固定种子，fav_factor为<code>q-&gt;len &lt;&lt; 2</code>。其他所有情况下的fav_factor设置为<code>q-&gt;exec_us * q-&gt;len</code>。</p>
</li>
<li><p>for循环遍历<code>afl-&gt;fsrv.trace_bits</code>数组</p>
<p>遍历<code>trace_bits</code>数组，当满足<code>trace_bits[i]&gt;=1</code>时，也就是这条分支被覆盖了。当满足<code>afl-&gt;top_rated[i]&gt;=1</code>时，执行接下来的执行体：根据<code>afl-&gt;schedule</code>和<code>afl-&gt;fixed_seed</code>的值计算<code>top_rated_fav_factor</code>和<code>top_rated_fuzz_p2</code>。</p>
<blockquote>
<p>对<code>trace_bits</code>数组和<code>top_rated</code>数组作如下解释：</p>
<ul>
<li>trace_bits数组的每一位对应一个分支的映射关系。其通过插桩代码来实现，具体来说，AFL的编译工具在编译被测试程序时，会在每个分支处插入代码，每个分支都有一个唯一ID，这个ID会被用来计算trace_bits数组的索引。当程序执行到某个分支时，插桩代码会更具该分支的ID计算出trace_bits数组的索引，并设置相应的位。</li>
<li>top_rated数组存储每个分支（路径）上最有价值的测试用例。具体来说，它记录了在模糊测试过程中，每个分支覆盖率最高或发现路径最多的测试用例。top_rated是一个指向<code>queue_entry</code>结构体的指针数组。每个数组元素对应一个分支，存储的是在该分支上最有价值的测试用例。当一个新的测试用例发现新的路径或覆盖更多的分支时，如果新的测试用例比当前存储的测试用例更有价值，AFL会将新的测试用例存储到top_rated数组中。</li>
</ul>
</blockquote>
<p>计算结束后，比较fuzz_p2和top_fuzz_p2的值，如果相等的话，根据<code>afl-&gt;schedule</code>和<code>afl-&gt;fixed_seed</code>的值，进一步比较<code>fav_factor</code>和<code>afl-&gt;top_rated[i]</code>的属性值。</p>
<p>更新top_rated[i]的trace_mini变量，将当前测试用例q插入最后插入新的top_rated，增加其引用计数。如果<code>q-&gt;trace_mini</code>为空或0，则分配内存并最小化<code>trace_bits</code>数组，最后，设置<code>afl-&gt;score_changed</code>为1.</p>
</li>
<li><p>循环结束</p>
</li>
</ol>
</li>
</ol>
<p>trim函数结束后，是<code>queue_testcase_get()</code>函数，这个函数的主要功能是从文件中读取测试用例，并根据是否配置了缓存来决定是直接读取还是从缓存中读取。如果缓存已经满，则会驱逐一个旧的缓存条目以腾出空间。</p>
</blockquote>
<p>随后来到<code>afl-&gt;queue_cur-&gt;trim_done=1;</code>表明当前队列条目已经完成修剪，无论其是否修剪成功，不再执行修剪。至此，修剪的第一个if语句结束。</p>
<p><code>memcpy(out_buf, in_buf, len);</code>将in_buf中长度为len的内容复制到out_buf中。</p>
<p><code> u64 fuzz_time = ((afl-&gt;prev_run_time + get_cur_time() - afl-&gt;start_time) / 1000);</code>计算fuzz_time。</p>
<p>随后，执行以下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果队列中的种子数量大于中心种子数量，并且队列中的种子数量大于等于两倍的中心相关种子数量</span><br><span class="hljs-keyword">if</span>(afl-&gt;queued_items &gt; afl-&gt;centers_num &amp;&amp; (afl-&gt;queued_items &gt;= <span class="hljs-number">2</span> * afl-&gt;last_centers_realted_seeds))&#123;<br>    <span class="hljs-comment">// 执行kmeans_main函数，进行聚类分析</span><br>    kmeans_main(afl);<br>	<span class="hljs-comment">// 更新中心相关种子为当前队列中的种子数量</span><br>    afl-&gt;last_centers_realted_seeds = afl-&gt;queued_items;<br>    <span class="hljs-comment">// 更新中心相关种子生成时间为当前模糊测试时间</span><br>    afl-&gt;centers_gen_time = fuzz_time;<br>	<span class="hljs-comment">// 遍历队列中的每个种子</span><br>    <span class="hljs-keyword">for</span> (u32 c = <span class="hljs-number">0</span>; c &lt; afl-&gt;queued_items; c++) &#123;<br>        <span class="hljs-comment">// queue_buf存储模糊测试队列中的所有条目，它是一个动态增长的数组，可以根据需要增加大小。</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span> * <span class="hljs-title">cur_node</span> =</span> afl-&gt;queue_buf[c];<br>        <span class="hljs-comment">// 如果当前种子的初始种子存在并且当前种子经过变异。</span><br>      <span class="hljs-keyword">if</span>(cur_node-&gt;initial_seed &amp;&amp; cur_node-&gt;mutated_pos_num != <span class="hljs-number">-1</span>)&#123;<br>          <span class="hljs-comment">// 那么变异当前种子的每一个字节</span><br>        <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; cur_node-&gt;len;i++)&#123;<br>            <span class="hljs-comment">// 判断当前种子第i个字节是否发生变异</span><br>          <span class="hljs-keyword">if</span>(cur_node-&gt;mutated_pos[i].flag &gt;= <span class="hljs-number">1</span>)&#123;<br>              <span class="hljs-comment">// 如果发生变异，则释放该字节的A和b矩阵（这是CMAB中的内容）</span><br>            M_free(cur_node-&gt;mutated_pos[i].A);<br>            M_free(cur_node-&gt;mutated_pos[i].b);<br>			  <span class="hljs-comment">// 重新分配A,b的资源</span><br>              <span class="hljs-comment">// A即是一个初始化为1，长宽都为centers_num的矩阵</span><br>              <span class="hljs-comment">// b即是一个初始化为0，长宽都为centers_num的矩阵</span><br>            cur_node-&gt;mutated_pos[i].A = M_I(afl-&gt;centers_num);<br>            cur_node-&gt;mutated_pos[i].b = M_Zeros(afl-&gt;centers_num,<span class="hljs-number">1</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>上述是Shapfuzz中添加的代码，本次执行由于是第一次，输入只有两个种子。因此会跳过。来到下述代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果中心种子的生成时间（在执行聚类函数后生成）大于当前队列中向量更新时间  </span><br><span class="hljs-keyword">if</span>(afl-&gt;centers_gen_time &gt; afl-&gt;queue_cur-&gt;vec_update_time)&#123;<br>    <span class="hljs-comment">// 初始化cur数组</span><br>    u32 map_size = afl-&gt;fsrv.map_size;<br>    <span class="hljs-type">float</span>* cur = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br>    <span class="hljs-built_in">memset</span>(cur, <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br>	<span class="hljs-comment">// 执行模糊测试</span><br>    common_fuzz_stuff(afl, out_buf, len);<br>    u32 j = <span class="hljs-number">0</span>;<br>    u8 *src = afl-&gt;fsrv.trace_bits;<br>    <span class="hljs-comment">// 填充cur数组</span><br>    <span class="hljs-comment">// 遍历位图数组，将非0值转换为浮点数并存储于cur数组中。</span><br>    <span class="hljs-keyword">while</span> (j &lt; map_size) &#123;<br>      u8 v = *src;<br>      <span class="hljs-keyword">if</span>(v)&#123;<br>        cur[j] = (<span class="hljs-type">float</span>)v;<br>      &#125;<br>      src++;<br>      ++j;<br>    &#125;<br>	<span class="hljs-comment">// 计算距离并更新特征向量</span><br>    <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;centers_num;i++)&#123;<br>        <span class="hljs-comment">// 遍历中心节点（种子）数组，计算cur数组与每个中心的距离，并将结果存储在当前队列条目的特征向量中。</span><br>      <span class="hljs-type">double</span> distance = (<span class="hljs-type">double</span>)cal_distance(cur, afl-&gt;centers[i], map_size);<br>      afl-&gt;queue_cur-&gt;feature_vec-&gt;data[i] = distance;<br>    &#125;<br>	<span class="hljs-comment">// 更新向量更新时间</span><br>    afl-&gt;queue_cur-&gt;vec_update_time = afl-&gt;centers_gen_time;<br>    <br>  &#125;<br></code></pre></td></tr></table></figure>

<p>由于本次为Fuzzing的第一轮，因此<code>afl-&gt;centers_gen_time</code>为0，且<code>afl-&gt;queue_cur-&gt;vec_update_time</code>也为0。因此上述执行体会被跳过，来到以下执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果当前队列长度大于afl已知的最大长度  </span><br><span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;len &gt; afl-&gt;max_len)&#123;<br>    <span class="hljs-comment">// 如果历史变异序列不为空</span><br>    <span class="hljs-keyword">if</span>(afl-&gt;history_mutation_sequence)&#123;<br>        <span class="hljs-comment">// 则释放以下两个数组的空间</span><br>      <span class="hljs-built_in">free</span>(afl-&gt;history_mutation_sequence);<br>      <span class="hljs-built_in">free</span>(afl-&gt;new_mutation_sequence);<br>    &#125;<br>	<span class="hljs-comment">// 重新分配历史和新变异序列的内存</span><br>    afl-&gt;history_mutation_sequence = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>    afl-&gt;new_mutation_sequence = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>	<span class="hljs-comment">// 如果afl-&gt;max_len不为0</span><br>    <span class="hljs-keyword">if</span>(afl-&gt;max_len != <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 释放以下数组内存</span><br>      <span class="hljs-built_in">free</span>(afl-&gt;dataset_reward);<br>      <span class="hljs-built_in">free</span>(afl-&gt;hit_nums);<br>      <span class="hljs-built_in">free</span>(afl-&gt;tmp_mutated_pos);<br>      <span class="hljs-built_in">free</span>(afl-&gt;tmp_mutated_pos_flag);<br>    &#125;<br>    <span class="hljs-comment">// 为以下数组开辟新的空间</span><br>    afl-&gt;dataset_reward = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>    afl-&gt;hit_nums = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>    afl-&gt;tmp_mutated_pos = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>    afl-&gt;tmp_mutated_pos_flag = (u8 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u8));<br><br>    afl-&gt;max_len = afl-&gt;queue_cur-&gt;len;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 将dataset_reward等数组重置</span><br>    <span class="hljs-built_in">memset</span>(afl-&gt;dataset_reward, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>    <span class="hljs-built_in">memset</span>(afl-&gt;hit_nums, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>    <span class="hljs-built_in">memset</span>(afl-&gt;tmp_mutated_pos_flag, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(u8));<br>  &#125;<br><span class="hljs-comment">// 初始化一些成员变量</span><br>  afl-&gt;history_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>  afl-&gt;new_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>  afl-&gt;tmp_mutated_pos_idx = <span class="hljs-number">0</span>;<br>  afl-&gt;from_splicing = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>Shapfuzz部分代码结束，接下来对当前队列进行性能评分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断是否使用旧的种子选择策略</span><br><span class="hljs-keyword">if</span> (likely(!afl-&gt;old_seed_selection))<br>    <span class="hljs-comment">// 直接给两个变量赋值，当前队列的性能分数</span><br>    orig_perf = perf_score = afl-&gt;queue_cur-&gt;perf_score;  <br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 否则，则调用caculate_score函数重新计算当前队列条目的性能评分，并将其赋值给afl-&gt;queue_cur-&gt;perf_score</span><br>    afl-&gt;queue_cur-&gt;perf_score = orig_perf = perf_score =<br>        calculate_score(afl, afl-&gt;queue_cur);<br></code></pre></td></tr></table></figure>

<p>接下来是判断当前队列是否放弃，即性能分数小于等于零并且队列活跃种子数量大于1，则放弃当前队列。</p>
<p>本次执行不会放弃，来到后续的cmplog功能判断，由于未开启cmplog因此，不会执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果当前队列条目已经通过了确定性测试 或者 跳过确定性测试的全局变量被设置 或者 当前队列条目的性能分数小于某个阈值，这个阈值是MIN(当前队列深度的30倍，Havoc阶段的最大倍数)</span><br><span class="hljs-keyword">if</span> (likely(afl-&gt;queue_cur-&gt;passed_det) || likely(afl-&gt;skip_deterministic) ||<br>    likely(perf_score &lt;<br>           (afl-&gt;queue_cur-&gt;depth * <span class="hljs-number">30</span> &lt;= afl-&gt;havoc_max_mult * <span class="hljs-number">100</span><br>                ? afl-&gt;queue_cur-&gt;depth * <span class="hljs-number">30</span><br>                : afl-&gt;havoc_max_mult * <span class="hljs-number">100</span>))) &#123;<br><span class="hljs-comment">// 满足条件则跳转到`custom_mutator_stage`标签，从而跳过确定性测试阶段。</span><br>  <span class="hljs-keyword">goto</span> custom_mutator_stage;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行来到<code>custom_mutator_stage</code>标签处，第一句为<code>if (likely(!afl-&gt;custom_mutators_count)) &#123; goto havoc_stage; &#125;</code>，因此再次跳转到havoc_stage阶段。</p>
<blockquote>
<p>havoc变异阶段主要用于对输入数据进行大量随机变异，以发现潜在的漏洞。</p>
</blockquote>
<p><code>afl-&gt;stage_cur_byte = -1;</code>初始化当前字节位置为-1，表示还没有开始变异。随后判断是否在拼接文件周期内，需要生成相应的描述，本次不在splice 变异中，因此执行一些指纹操作。其中有<code>  afl-&gt;stage_max = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) * perf_score / afl-&gt;havoc_div / 100;</code>根据是否在进行确定性测试，设置stage_max，即最大变异次数。</p>
<p>接下来就是对最大变异次数做一个判断：<code>if (afl-&gt;stage_max &lt; HAVOC_MIN) &#123; afl-&gt;stage_max = HAVOC_MIN; &#125;</code>本次执行，stage_max值为0x100。而<code>Havoc_MIN=12U</code>，因此不会执行赋值操作。然后，接下去是初始化一些变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">temp_len = len; <span class="hljs-comment">// 记录长度</span><br><br>orig_hit_cnt = afl-&gt;queued_items + afl-&gt;saved_crashes; <span class="hljs-comment">// 记录种子池种子+Crash数量</span><br><br>havoc_queued = afl-&gt;queued_items; <span class="hljs-comment">// 种子池中种子数量</span><br></code></pre></td></tr></table></figure>

<p>接下来是一个if语句，用于处理自定义变异器的变异频率，本次执行不会执行。跳过后，计算r_max，一个随机选择的最大范围，根据不同的条件动态调整这个范围值。接下来又是Shapfuzz中的内容。初始化一些变量后，第一个判断<code>if(afl-&gt;history_mode &amp;&amp; afl-&gt;queue_cur-&gt;ancestor_seed &amp;&amp; afl-&gt;from_splicing == 0 &amp;&amp; afl-&gt;queue_cur-&gt;vec_update_time)</code>其中，<code>afl-&gt;queue_cur-&gt;vec_update_time</code>为0，因此跳过。</p>
<p>第二个判断<code>if(afl-&gt;new_mode &amp;&amp; afl-&gt;queue_cur-&gt;related_num &amp;&amp; afl-&gt;from_splicing == 0)</code>，前两个条件都为0，因此跳过。</p>
<p>接下来执行一个循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (afl-&gt;stage_cur = <span class="hljs-number">0</span>; afl-&gt;stage_cur &lt; afl-&gt;stage_max; ++afl-&gt;stage_cur) &#123;<br>  &#123;<br>    history_mode = <span class="hljs-number">0</span>;<br>    new_mode = <span class="hljs-number">0</span>;<br>    random_mode = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> decrease = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 计算decrease</span><br>    <span class="hljs-keyword">if</span>(per_exec_global &gt; <span class="hljs-number">0</span> &amp;&amp; afl-&gt;stats_avg_exec &gt; <span class="hljs-number">0</span> &amp;&amp; per_exec_global &gt;  <span class="hljs-number">2</span> * afl-&gt;stats_avg_exec)&#123;<br>      <br>      decrease = <span class="hljs-number">1.0</span> * (per_exec_global - afl-&gt;stats_avg_exec) / per_exec_global;<br>      <span class="hljs-keyword">if</span>(decrease &gt; <span class="hljs-number">0.3</span>) decrease = <span class="hljs-number">0.3</span>; <span class="hljs-comment">// 限定decrease的值最大为0.3</span><br>    &#125;<br>      <span class="hljs-comment">// 根据`history_able`和`new_able`的值，代码被分为四种情况</span><br>      <span class="hljs-comment">// 情况一：history_able == 0 &amp;&amp; new_able == 0</span><br>    <span class="hljs-keyword">if</span>(history_able == <span class="hljs-number">0</span> &amp;&amp; new_able == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 计算average和weight_random</span><br>      <span class="hljs-type">double</span> average = <span class="hljs-number">1.0</span> * afl-&gt;found_all / afl-&gt;exec_all;<br>      weight_random = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_random / afl-&gt;queue_cur-&gt;exec_random;<br>      <span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;initial_seed == <span class="hljs-number">0</span> &amp;&amp; weight_random &lt; average * (<span class="hljs-number">0.7</span> + decrease))&#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <br>      random_mode = <span class="hljs-number">1</span>;<br>    &#125;<br>      <span class="hljs-comment">// 情况二：history_able == 0 &amp;&amp; new_able == 1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(history_able == <span class="hljs-number">0</span> &amp;&amp; new_able == <span class="hljs-number">1</span>)&#123;<br>      weight_new = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_new / afl-&gt;queue_cur-&gt;exec_new;<br>      weight_random = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_random / afl-&gt;queue_cur-&gt;exec_random;<br><br>      <span class="hljs-type">double</span> average = <span class="hljs-number">1.0</span> * afl-&gt;found_all / afl-&gt;exec_all;<br>      <span class="hljs-keyword">if</span>(weight_new &lt; average * (<span class="hljs-number">0.7</span> + decrease) &amp;&amp; weight_random &lt; average * (<span class="hljs-number">0.7</span> + decrease))&#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <br><br>      new_line = weight_new;<br>      random_line = new_line + weight_random;<br><br>      <span class="hljs-type">double</span> tmp = ((<span class="hljs-type">double</span>)rand()/RAND_MAX) * random_line;<br>      <span class="hljs-keyword">if</span>(tmp &lt; weight_new) new_mode = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> random_mode = <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 情况三：history_able == 1 &amp;&amp; new_able == 0</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(history_able == <span class="hljs-number">1</span> &amp;&amp; new_able == <span class="hljs-number">0</span>)&#123;<br>      weight_history = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_history / afl-&gt;queue_cur-&gt;exec_history;<br>      weight_random = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_random / afl-&gt;queue_cur-&gt;exec_random;<br><br>      <span class="hljs-type">double</span> average = <span class="hljs-number">1.0</span> * afl-&gt;found_all / afl-&gt;exec_all;<br>      <span class="hljs-keyword">if</span>(weight_history &lt; average * (<span class="hljs-number">0.7</span> + decrease) &amp;&amp; weight_random &lt; average * (<span class="hljs-number">0.7</span> + decrease))&#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <br><br>      history_line = weight_history;<br>      random_line = history_line + weight_random;<br><br>      <span class="hljs-type">double</span> tmp = ((<span class="hljs-type">double</span>)rand()/RAND_MAX) * random_line;<br>      <span class="hljs-keyword">if</span>(tmp &lt; weight_history) history_mode = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> random_mode = <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 情况四：history_able == 1 &amp;&amp; new_able == 1</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(history_able &amp;&amp; new_able)&#123;<br>      weight_history = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_history / afl-&gt;queue_cur-&gt;exec_history;<br>      weight_new = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_new / afl-&gt;queue_cur-&gt;exec_new;<br>      weight_random = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_random / afl-&gt;queue_cur-&gt;exec_random;<br><br>      <span class="hljs-type">double</span> average = <span class="hljs-number">1.0</span> * afl-&gt;found_all / afl-&gt;exec_all;<br>      <span class="hljs-keyword">if</span>(weight_history &lt; average * (<span class="hljs-number">0.7</span> + decrease) &amp;&amp; weight_new &lt; average * (<span class="hljs-number">0.7</span> + decrease) &amp;&amp; weight_random &lt; average * (<span class="hljs-number">0.7</span> + decrease))&#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <br><br>      history_line = weight_history;<br>      new_line = weight_history + weight_new;<br>      random_line = new_line + weight_random;<br><br>      <span class="hljs-type">double</span> tmp = ((<span class="hljs-type">double</span>)rand()/RAND_MAX) * random_line;<br>      <span class="hljs-keyword">if</span>(tmp &lt; weight_history) history_mode = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &lt; weight_new) new_mode = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> random_mode = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>这段for循环，有那么点抽象，从逻辑上来看，每次都貌似只会执行一次；本次执行只执行了一次，就break了。这段循环执行后，来到各种模式的判断。结果是<code>history_mode,new_mode,random_mode</code>全为0.则全跳过。</p>
<p>随后，设置<code>afl-&gt;use_splice_mutator = 0;</code>即不使用拼接变异。生成一个随机的2的幂次方值，将其存储于<code>afl-&gt;stage_cur_val</code>中。再<code>afl-&gt;splice_num=0;</code>不使用拼接变异。随后通过之前for循环后对模式的判定，将<code>afl-&gt;record_flag</code>置0或1。本次执行置为0.随后一个很长的<strong>for循环</strong>进行随机选择变异器进行变异，变异次数由<code>using_stacking</code>控制，也就是之前的<code>1&lt;&lt;(1+rand_below(afl, afl-&gt;havoc_stack_pow2));</code>生成的一个区间在[2,2*afl-&gt;havoc_stack_pow2]中的随机数。本次执行，这个随机数为8，接下来会对一个种子进行8次变异。</p>
<p>跳过第一个if语句，对自定义变异器的使用。接下来初始化一个r：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// 如果使用改变长度的变异器，则r是一个[0,r_max-1]的值，否则是一个[0,46]的值</span><br><span class="hljs-keyword">if</span>(afl-&gt;time_to_use_length_mutator == <span class="hljs-number">0</span>)&#123;<br>     r = rand_below(afl, <span class="hljs-number">47</span>);<br>   &#125;<span class="hljs-keyword">else</span>&#123;<br>     r = rand_below(afl, r_max);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>最后执行下来，r的值为0x11。接下来是一个switch语句，对r做出区间划分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-number">0</span> ... <span class="hljs-number">3</span>: &#123;<br><br>  <span class="hljs-comment">/* Flip a single bit somewhere. Spooky! */</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INTROSPECTION</span><br>  <span class="hljs-built_in">snprintf</span>(afl-&gt;m_tmp, <span class="hljs-keyword">sizeof</span>(afl-&gt;m_tmp), <span class="hljs-string">&quot; FLIP_BIT1&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(afl-&gt;mutation, afl-&gt;m_tmp);<br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">// 如果启用了using_feature_mode和history_mode则执行以下代码</span><br>  <span class="hljs-keyword">if</span>(using_feature_mode &amp;&amp; history_mode)&#123;<br>      <span class="hljs-comment">// 根据概率分布，选择种子的一个字节位置</span><br>    pos_tmp = select_position_based_on_distribution(afl);<br>      <span class="hljs-comment">// 计算要翻转的bit位置</span><br>    tmp = (pos_tmp &lt;&lt; <span class="hljs-number">3</span>) + rand_below(afl, <span class="hljs-number">8</span>);<br>      <span class="hljs-comment">// 将选中的位置进行相应更新</span><br>    update(afl, pos_tmp);<br>  &#125; <span class="hljs-comment">// 如果启用了using_feature_mode和new_mode</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(using_feature_mode &amp;&amp; new_mode)&#123;<br>    pos_tmp = afl-&gt;cur_mutation_sequence[rand_below(afl, afl-&gt;cur_mutation_sequence_idx)];<br>      <span class="hljs-comment">// 计算要翻转的bit位置</span><br>    tmp = (pos_tmp &lt;&lt; <span class="hljs-number">3</span>) + rand_below(afl, <span class="hljs-number">8</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    tmp = rand_below(afl, temp_len &lt;&lt; <span class="hljs-number">3</span>);<br>  &#125;<br>    <span class="hljs-comment">// 翻转比特位</span><br>  FLIP_BIT(out_buf, tmp);<br>    <span class="hljs-comment">// 缓冲区已经更改 标志位</span><br>  buf_changed = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">break</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>剩余的情况分别为：</p>
<ul>
<li><p>r 在 4 … 7区间内</p>
<p>将pos_tmp位置的字节进行修改。</p>
</li>
<li><p>r 在 8 … 9区间内</p>
<p>将(outbuf+pos_tmp)位置的字节进行修改。</p>
<p><code>*(u16 *)(out_buf + pos_tmp) = interesting_16[rand_below(afl, sizeof(interesting_16) &gt;&gt; 1)];</code></p>
</li>
<li><p>r 在 10 … 11区间内</p>
<p>将(outbuf+pos_tmp)位置的字节进行修改。</p>
<p><code>*(u16 *)(out_buf + pos_tmp) = SWAP16(interesting_16[rand_below(afl, sizeof(interesting_16) &gt;&gt; 1)]);</code></p>
</li>
<li><p>r 还有很多区间，不同的是Shapfuzz将改变长度的变异器都放在r值在47以后的区间了。</p>
</li>
</ul>
<p>对一个种子变异结束后，执行<code>common_fuzz_stuff(afl, out_buf, temp_len);</code></p>
<blockquote>
<p>common_fuzz_stuff()会写入一个变异后的测试用例，运行目标程序，并处理结果。</p>
<p>write_to_testcase()函数，写入测试用例，因为启用shm模式，所以会将变异后的测试用例写入共享内存中。</p>
<p>fuzz_run_target()函数，调用afl_fsrv_run_target()函数进行执行，并接受返回结果。</p>
<p>afl_fsrv_run_target()函数，执行目标程序，监控是否超时。返回反馈信息。并且在执行时，会自动更新位图。</p>
<p>save_if_interesting()函数，如果测试实例是”interesting”的，那么就保存到种子池。</p>
</blockquote>
<p>接下来对<code>save_if_interesting()</code>函数进行详细解释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果有发现新的边，并且当前测试实例有原始种子，并且from_splicing==0，并且启用的变异器中有拼接变异器，并且没有启动mini_mode</span><br><span class="hljs-keyword">if</span>(afl-&gt;new_edges_found_idx &amp;&amp; afl-&gt;queue_cur-&gt;ancestor_seed &amp;&amp; afl-&gt;from_splicing == <span class="hljs-number">0</span> &amp;&amp; afl-&gt;use_splice_mutator == <span class="hljs-number">1</span> &amp;&amp; afl-&gt;mini_mode == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 保存长度和当前测试实例于init_len和init</span><br>      u32 init_len = len;<br>      u8* init = ck_alloc(len);<br>      <span class="hljs-built_in">memcpy</span>(init, (u8*)mem, len);<br>	  <span class="hljs-comment">// 给afl-&gt;out_test分配内存，指针*u8_mem也指向这块内存，并将当前测试实例copy给u8_mem</span><br>      u8 *u8_mem = afl_realloc(AFL_BUF_PARAM(out_test), init_len);<br>      <span class="hljs-keyword">if</span> (unlikely(!u8_mem)) &#123; PFATAL(<span class="hljs-string">&quot;alloc&quot;</span>); &#125;<br>      u32 len_test = init_len;<br>      <span class="hljs-built_in">memcpy</span>(u8_mem, (u8*)mem, init_len);<br>	  <span class="hljs-comment">// i == 拼接次数 - 1</span><br>      <span class="hljs-type">int</span> i = afl-&gt;splice_num - <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 当存在拼接变异，根据拼接栈，进行复原。也就是将更改种子长度的变异操作给撤销。</span><br>      <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)<br>      &#123;<br>          <br>        u32 type = afl-&gt;splice_stack[i][<span class="hljs-number">0</span>];<br>        u32 start = afl-&gt;splice_stack[i][<span class="hljs-number">1</span>];<br>        u32 mutation_length = afl-&gt;splice_stack[i][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>)&#123; <br>          u32 del_from = start;<br>          u32 del_len = mutation_length;<br>          memmove(u8_mem + del_from, u8_mem + del_from + del_len,<br>                  len_test - del_from - del_len);<br><br>          len_test -= del_len;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          u32 clone_to = start;<br>          u32 clone_len = mutation_length;<br>          u8* clone_from = (u8*)(&amp;(afl-&gt;splice_stack[i][<span class="hljs-number">3</span>]));<br>          u8 *new_buf =<br>              afl_realloc(AFL_BUF_PARAM(out_scratch), len_test + clone_len);<br>          <span class="hljs-keyword">if</span> (unlikely(!new_buf)) &#123; PFATAL(<span class="hljs-string">&quot;alloc&quot;</span>); &#125;<br>          <span class="hljs-built_in">memcpy</span>(new_buf, u8_mem, clone_to);<br>          <span class="hljs-built_in">memcpy</span>(new_buf + clone_to, clone_from, clone_len);<br>          <span class="hljs-built_in">memcpy</span>(new_buf + clone_to + clone_len, u8_mem + clone_to,<br>                  len_test - clone_to);<br><br>          u8_mem = new_buf;<br>          afl_swap_bufs(AFL_BUF_PARAM(out_test), AFL_BUF_PARAM(out_scratch));<br>          len_test += clone_len;<br>        &#125;<br><br>        i--;<br>      &#125;<br>		<span class="hljs-comment">// 经过撤销后，现在种子的长度与初始种子的长度一致，处于同一个family中。</span><br>      u8 new_fault;<br>    	<span class="hljs-comment">// 再将这个撤销操作后的测试实例执行</span><br>      len_test = write_to_testcase(afl, u8_mem, len_test, <span class="hljs-number">0</span>);<br>      new_fault = fuzz_run_target(afl, &amp;afl-&gt;fsrv, afl-&gt;hang_tmout);<br>        <span class="hljs-comment">// 判断是否发现新路径</span><br>      classify_counts(&amp;afl-&gt;fsrv);<br><br>      u8 unchanged = <span class="hljs-number">1</span>;<br>    	<br>      <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;new_edges_found_idx;i++)&#123;<br>        u32 cur_edge = afl-&gt;new_edges_found[i];<br>          <span class="hljs-comment">// 检查所有发现的新边，对于撤销长度变异后的执行结果，只要有没发现上次发现的边，则置0</span><br>        <span class="hljs-keyword">if</span>(!(afl-&gt;fsrv.trace_bits)[cur_edge]) unchanged = <span class="hljs-number">0</span>;<br>      &#125;<br>		<span class="hljs-comment">// unchanged为1，说明撤销长度变异，不改变覆盖结果</span><br>    	<span class="hljs-comment">// 那么将保存撤销长度变异后的测试实例</span><br>      <span class="hljs-keyword">if</span>(unchanged &amp;&amp; len_test == afl-&gt;queue_cur-&gt;len)&#123;<br>        afl-&gt;use_splice_mutator = <span class="hljs-number">0</span>;<br>        <br>        u8 *new_buf = afl_realloc(AFL_BUF_PARAM(out), len_test);<br>        <span class="hljs-keyword">if</span> (unlikely(!new_buf)) &#123; PFATAL(<span class="hljs-string">&quot;alloc&quot;</span>); &#125;<br>        <span class="hljs-built_in">memcpy</span>(new_buf, u8_mem, len_test);<br>        len = len_test;<br>        mem = new_buf;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-comment">// 说明撤销长度变异无法到达之前的结果</span><br>          <span class="hljs-comment">// 将撤销长度变异前，也就是当前测试实例保存于mem中</span><br>        u8 *new_buf = afl_realloc(AFL_BUF_PARAM(out), init_len);<br>        <span class="hljs-keyword">if</span> (unlikely(!new_buf)) &#123; PFATAL(<span class="hljs-string">&quot;alloc&quot;</span>); &#125;<br>        len = init_len;<br>        <span class="hljs-built_in">memcpy</span>(new_buf, init, init_len);<br>        mem = new_buf;<br>		<span class="hljs-comment">// 将reset置1</span><br>        u8 reset = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;new_edges_found_idx;i++)&#123;<br>          u32 cur_edge = afl-&gt;new_edges_found[i];<br>            <span class="hljs-comment">// 遍历所有新发现的边，如果这条自新边重置次数大于8次，那么不再重置</span><br>          <span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;ancestor_seed-&gt;reset_times[cur_edge] &gt; <span class="hljs-number">8</span>) reset = <span class="hljs-number">0</span>;<br>        &#125;<br>			<span class="hljs-comment">// 重置操作</span><br>        <span class="hljs-keyword">if</span>(reset)&#123;<br>          u8 new_fault;<br>            <span class="hljs-comment">// 将测试实例写入共享内存</span><br>          len = write_to_testcase(afl, mem, len, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 运行目标程序</span><br>          new_fault = fuzz_run_target(afl, &amp;afl-&gt;fsrv, afl-&gt;hang_tmout);<br>          classify_counts(&amp;afl-&gt;fsrv);<br>            <span class="hljs-comment">// 当前队列不为空 并且 当前测试实例存在原始种子 并且 afl-&gt;from_splicing为0</span><br>          <span class="hljs-keyword">if</span>(afl-&gt;queue_cur &amp;&amp; !(afl-&gt;queue_cur-&gt;ancestor_seed == <span class="hljs-literal">NULL</span> || afl-&gt;from_splicing))&#123;<br>              <span class="hljs-comment">// 则获取原始种子的virgin_bits，再遍历所有自新边</span><br>            u8* virgin_local = (u8 *)afl-&gt;queue_cur-&gt;ancestor_seed-&gt;virgin_bits;<br>            <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;new_edges_found_idx;i++)&#123;<br>                <span class="hljs-comment">// 将所有自新边的重置次数+1</span><br>              u32 cur_edge = afl-&gt;new_edges_found[i];<br>              afl-&gt;queue_cur-&gt;ancestor_seed-&gt;reset_times[cur_edge]++;<br>                <span class="hljs-comment">// 这个数组与位图每一字节进行“或”的操作</span><br>              virgin_local[cur_edge] |= (afl-&gt;fsrv.trace_bits)[cur_edge];<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>随后在打印一些数据后，执行open函数打开一个文件句柄,执行<code>ck_write(fd, mem, len, queue_fn);</code>将测试实例给保存起来。随后有两个if，分别是new_bits&#x3D;&#x3D;2的情况，以及AFLFast调度下，更新n_fuzz的queue_entry。随后计算一个<code>afl-&gt;queue_top-&gt;exec_cksum</code>哈希值。然后调用函数<code>calibrate_case</code>，该函数通过多次运行测试用例，检测其稳定性和变量行为，并更新相关的统计信息和状态。随后是执行<code>queue_testcase_store_mem()</code>函数，将当前队列顶部的测试实例加入到缓存中。</p>
<p>接下来就是对传入的fault进行判断，也就是本函数接收的，上一层经过执行的结果。对结果进行判断。根据fault的结果进入不同的分支：</p>
<ul>
<li><code>FAULT_TMOUT</code><ul>
<li>设置total_tmouts计数器加一。如果unique_hangs的个数超过能保存的最大数量<code>KEEP_UNIQUE_HANG</code>，就直接返回keeping的值，如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整。如果没有发现新的超时路径，就直接返回keeping，否则，代表发现了新的超时路径，unique_tmouts计数器加一</li>
<li>如果hang_tmout大于exec_tmout，则以hang_tmout为timeout，重新执行一次runt_targe<ul>
<li>如果结果不是<code>FAULT_TMOUT</code>，就返回keeping，否则就使<code>unique_hangs</code>计数器加一，然后更新last_hang_time的值，并保存到<code>alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir, unique_hangs, describe_op(0))</code>文件。</li>
<li>如果结果为<code>FAULT_CRASH</code>，就跳转到keep_as_crash</li>
</ul>
</li>
</ul>
</li>
<li><code>FAULT_CRASH</code></li>
<li><code>FAULT_ERROR</code></li>
<li>其他情况，直接返回keeping，也就是1。</li>
</ul>
<p>至此，<code>save_if_interesting</code>函数结束，回到<code>common_fuzz_stuff</code>函数处执行。调用<code>show_stats(afl)</code>函数。该函数刷新screen；至此，common_fuzz_stuff执行完成。</p>
<p>执行完成后，执行<code>stat_analysis</code>函数，该函数主要做的工作是，计算reward，也就是收益R。根据发现的自新边，统计必要字节数量，最后计算字节Shapley值。</p>
<p>执行<code>stat_analysis()</code>后，恢复out_buf的初始状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-built_in">memset</span>(afl, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">afl_state_t</span>));<br><br>  afl-&gt;shm.map_size = map_size ? map_size : MAP_SIZE;<br><br>  afl-&gt;w_init = <span class="hljs-number">0.9</span>;<br>  afl-&gt;w_end = <span class="hljs-number">0.3</span>;<br>  afl-&gt;g_max = <span class="hljs-number">5000</span>;<br>  afl-&gt;period_pilot_tmp = <span class="hljs-number">5000.0</span>;<br>  afl-&gt;schedule = FAST;                 <span class="hljs-comment">/* Power schedule (default: FAST)   */</span><br>  afl-&gt;havoc_max_mult = HAVOC_MAX_MULT;<br><br>  afl-&gt;clear_screen = <span class="hljs-number">1</span>;                <span class="hljs-comment">/* Window resized?                  */</span><br>  afl-&gt;havoc_div = <span class="hljs-number">1</span>;                   <span class="hljs-comment">/* Cycle count divisor for havoc    */</span><br>  afl-&gt;stage_name = <span class="hljs-string">&quot;init&quot;</span>;             <span class="hljs-comment">/* Name of the current fuzz stage   */</span><br>  afl-&gt;splicing_with = <span class="hljs-number">-1</span>;              <span class="hljs-comment">/* Splicing with which test case?   */</span><br>  afl-&gt;cpu_to_bind = <span class="hljs-number">-1</span>;<br>  afl-&gt;havoc_stack_pow2 = HAVOC_STACK_POW2;<br>  afl-&gt;hang_tmout = EXEC_TIMEOUT;<br>  afl-&gt;exit_on_time = <span class="hljs-number">0</span>;<br>  afl-&gt;stats_update_freq = <span class="hljs-number">1</span>;<br>  afl-&gt;stats_avg_exec = <span class="hljs-number">0</span>;<br>  afl-&gt;skip_deterministic = <span class="hljs-number">1</span>;<br>  afl-&gt;cmplog_lvl = <span class="hljs-number">2</span>;<br>  afl-&gt;min_length = <span class="hljs-number">1</span>;<br>  afl-&gt;max_length = MAX_FILE;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NO_SPLICING</span><br>  afl-&gt;use_splicing = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  afl-&gt;q_testcase_max_cache_size = TESTCASE_CACHE_SIZE * <span class="hljs-number">1048576UL</span>;<br>  afl-&gt;q_testcase_max_cache_entries = <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_AFFINITY</span><br>  afl-&gt;cpu_aff = <span class="hljs-number">-1</span>;                    <span class="hljs-comment">/* Selected CPU core                */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>                                                     <span class="hljs-comment">/* HAVE_AFFINITY */</span></span><br><br>  afl-&gt;virgin_bits = ck_alloc(map_size);<br>  afl-&gt;virgin_tmout = ck_alloc(map_size);<br>  afl-&gt;virgin_crash = ck_alloc(map_size);<br>  afl-&gt;var_bytes = ck_alloc(map_size);<br>  afl-&gt;top_rated = ck_alloc(map_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>  afl-&gt;clean_trace = ck_alloc(map_size);<br>  afl-&gt;clean_trace_custom = ck_alloc(map_size);<br>  afl-&gt;first_trace = ck_alloc(map_size);<br>  afl-&gt;map_tmp_buf = ck_alloc(map_size);<br><br>  afl-&gt;fsrv.use_stdin = <span class="hljs-number">1</span>;<br>  afl-&gt;fsrv.map_size = map_size;<br>  <span class="hljs-comment">// afl_state_t is not available in forkserver.c</span><br>  afl-&gt;fsrv.afl_ptr = (<span class="hljs-type">void</span> *)afl;<br>  afl-&gt;fsrv.add_extra_func = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span> *, u8 *, u32)) &amp; add_extra;<br>  afl-&gt;fsrv.exec_tmout = EXEC_TIMEOUT;<br>  afl-&gt;fsrv.mem_limit = MEM_LIMIT;<br>  afl-&gt;fsrv.dev_urandom_fd = <span class="hljs-number">-1</span>;<br>  afl-&gt;fsrv.dev_null_fd = <span class="hljs-number">-1</span>;<br>  afl-&gt;fsrv.child_pid = <span class="hljs-number">-1</span>;<br>  afl-&gt;fsrv.out_dir_fd = <span class="hljs-number">-1</span>;<br><br>  init_mopt_globals(afl);<br><br>  list_append(&amp;afl_states, afl);<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __linux__</span><br>  fsrv-&gt;nyx_handlers = <span class="hljs-literal">NULL</span>;<br>  fsrv-&gt;out_dir_path = <span class="hljs-literal">NULL</span>;<br>  fsrv-&gt;nyx_mode = <span class="hljs-number">0</span>;<br>  fsrv-&gt;nyx_parent = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;nyx_standalone = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;nyx_runner = <span class="hljs-literal">NULL</span>;<br>  fsrv-&gt;nyx_id = <span class="hljs-number">0xFFFFFFFF</span>;<br>  fsrv-&gt;nyx_bind_cpu_id = <span class="hljs-number">0xFFFFFFFF</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">// this structure needs default so we initialize it if this was not done</span><br>  <span class="hljs-comment">// already</span><br>  fsrv-&gt;out_fd = <span class="hljs-number">-1</span>;<br>  fsrv-&gt;out_dir_fd = <span class="hljs-number">-1</span>;<br>  fsrv-&gt;dev_null_fd = <span class="hljs-number">-1</span>;<br>  fsrv-&gt;dev_urandom_fd = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">/* Settings */</span><br>  fsrv-&gt;use_stdin = <span class="hljs-literal">true</span>;<br>  fsrv-&gt;no_unlink = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;exec_tmout = EXEC_TIMEOUT;<br>  fsrv-&gt;init_tmout = EXEC_TIMEOUT * FORK_WAIT_MULT;<br>  fsrv-&gt;mem_limit = MEM_LIMIT;<br>  fsrv-&gt;out_file = <span class="hljs-literal">NULL</span>;<br>  fsrv-&gt;kill_signal = SIGKILL;<br><br>  <span class="hljs-comment">/* exec related stuff */</span><br>  fsrv-&gt;child_pid = <span class="hljs-number">-1</span>;<br>  fsrv-&gt;map_size = get_map_size();<br>  fsrv-&gt;real_map_size = fsrv-&gt;map_size;<br>  fsrv-&gt;use_fauxsrv = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;last_run_timed_out = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;debug = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;uses_crash_exitcode = <span class="hljs-literal">false</span>;<br>  fsrv-&gt;uses_asan = <span class="hljs-literal">false</span>;<br><br>  fsrv-&gt;init_child_func = fsrv_exec_child;<br>  list_append(&amp;fsrv_list, fsrv);<br><br></code></pre></td></tr></table></figure>



<h2 id="difference-between-Shapfuzz-and-AFLpp"><a href="#difference-between-Shapfuzz-and-AFLpp" class="headerlink" title="difference between Shapfuzz and AFLpp"></a>difference between Shapfuzz and AFLpp</h2><h3 id="afl-state-init"><a href="#afl-state-init" class="headerlink" title="afl_state_init()"></a>afl_state_init()</h3><p>来到初始化afl_state_t数据结构，也就是调用函数afl_state_init()，有shapfuzz以下成员变量被额外初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"> afl-&gt;new_edges_found_idx = <span class="hljs-number">0</span>;<br> afl-&gt;read_flag = <span class="hljs-number">1</span>;<br> afl-&gt;write_flag = <span class="hljs-number">0</span>;<br> afl-&gt;mini_mode = <span class="hljs-number">0</span>;<br> afl-&gt;time_to_use_length_mutator = <span class="hljs-number">0</span>;<br><br> afl-&gt;cur_mutation_sequence_idx = <span class="hljs-number">0</span>;<br> afl-&gt;cmp_states = ck_alloc(<span class="hljs-number">65536</span>);<br> <span class="hljs-built_in">memset</span>(afl-&gt;cmp_states, <span class="hljs-number">0</span>, <span class="hljs-number">65536</span>);<br><br> afl-&gt;exec_history_all = <span class="hljs-number">0</span>;<br> afl-&gt;found_by_history_all = <span class="hljs-number">0</span>;<br> afl-&gt;exec_new_all = <span class="hljs-number">0</span>;<br> afl-&gt;found_by_new_all = <span class="hljs-number">0</span>;<br> afl-&gt;exec_random_all = <span class="hljs-number">0</span>;<br> afl-&gt;found_by_random_all = <span class="hljs-number">0</span>;<br> afl-&gt;exec_all = <span class="hljs-number">0</span>;<br> afl-&gt;found_all = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 中心节点的数量</span><br> afl-&gt;centers_num = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 存储着各个中心节点</span><br> afl-&gt;centers = ck_alloc(afl-&gt;centers_num * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span> *));<br> <span class="hljs-built_in">memset</span>(afl-&gt;centers, <span class="hljs-number">0</span>, afl-&gt;centers_num * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span> *));<br><br> afl-&gt;exist_centers = <span class="hljs-number">0</span>;<br> afl-&gt;centers_gen_time = <span class="hljs-number">0</span>;<br> afl-&gt;last_centers_realted_seeds = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 特征图</span><br> afl-&gt;feature_map = ck_alloc(map_size * <span class="hljs-keyword">sizeof</span>(u32));<br><span class="hljs-comment">// 置0</span><br> <span class="hljs-built_in">memset</span>(afl-&gt;feature_map, <span class="hljs-number">0</span>, map_size * <span class="hljs-keyword">sizeof</span>(u32));<br> afl-&gt;num_edge = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 收益R</span><br> afl-&gt;dataset_reward = <span class="hljs-literal">NULL</span>;<br> afl-&gt;hit_nums = <span class="hljs-literal">NULL</span>;<br> afl-&gt;tmp_mutated_pos = <span class="hljs-literal">NULL</span>;<br> afl-&gt;tmp_mutated_pos_flag = <span class="hljs-literal">NULL</span>;<br> afl-&gt;tmp_mutated_pos_idx = <span class="hljs-number">0</span>;<br> afl-&gt;cur_n_fuzz_idx = <span class="hljs-number">0</span>;<br> afl-&gt;dataset_size = <span class="hljs-number">0</span>;<br> afl-&gt;record_flag = <span class="hljs-number">0</span>;<br> afl-&gt;last_show_time = <span class="hljs-number">0</span>;<br><br> afl-&gt;history_mutation_sequence = <span class="hljs-literal">NULL</span>;<br> afl-&gt;history_mutation_sequence_idx = <span class="hljs-number">0</span>;<br> afl-&gt;new_mutation_sequence = <span class="hljs-literal">NULL</span>;<br> afl-&gt;new_mutation_sequence_idx = <span class="hljs-number">0</span>;<br> afl-&gt;max_len = <span class="hljs-number">0</span>;<br><br> afl-&gt;before = <span class="hljs-number">0</span>;<br><br> afl-&gt;family_record_time = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h3 id="afl-fsrv-init"><a href="#afl-fsrv-init" class="headerlink" title="afl_fsrv_init"></a>afl_fsrv_init</h3><p>初始化afl-&gt;fsrv的成员变量</p>
<h3 id="read-afl-environment"><a href="#read-afl-environment" class="headerlink" title="read_afl_environment()"></a>read_afl_environment()</h3><p>将原本aflpp中的AFL_PIZZA_MODE删除。删除部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(env, <span class="hljs-string">&quot;AFL_PIZZA_MODE&quot;</span>, afl_environment_variable_len)) &#123;<br>    afl-&gt;afl_env.afl_pizza_mode =atoi((u8 *)get_afl_env(afl_environment_variables[i]));<br>    <span class="hljs-keyword">if</span> (afl-&gt;afl_env.afl_pizza_mode == <span class="hljs-number">0</span>) &#123;<br>        afl-&gt;afl_env.afl_pizza_mode = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        afl-&gt;pizza_is_served = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="循环获取命令行参数"><a href="#循环获取命令行参数" class="headerlink" title="循环获取命令行参数"></a>循环获取命令行参数</h3><p>Shapfuzz多了两个个参数，分别为:<code>-w,-k</code>，它们分别做的操作有：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>	afl-&gt;history_mode = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;k&#x27;</span>:<br>	afl-&gt;new_mode = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<h3 id="各种模式的初始化操作"><a href="#各种模式的初始化操作" class="headerlink" title="各种模式的初始化操作"></a>各种模式的初始化操作</h3><p><code>afl-&gt;power_name = power_names[afl-&gt;schedule]; </code>这里被赋值成了<code>fast</code>，是因为初始化afl-&gt;schedule被赋值成了3；默认是fast模式。以及，以下两个成员变量被赋值。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">afl-&gt;sync_id <span class="hljs-operator">=</span> ck_strdup(<span class="hljs-string">&quot;default&quot;</span>)<span class="hljs-comment">;</span><br>afl-&gt;is_secondary_node <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((afl-&gt;schedule &gt;= FAST &amp;&amp; afl-&gt;schedule &lt;= RARE) || afl-&gt;history_mode) &#123;<br><br>  afl-&gt;n_fuzz = ck_alloc(N_FUZZ_SIZE * <span class="hljs-keyword">sizeof</span>(u32));<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>启用history模式或者符合条件的模式，会给afl-&gt;n_fuzz分配空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;max_det_extras = MAX_DET_EXTRAS; <span class="hljs-comment">// 这个常量值为256</span><br></code></pre></td></tr></table></figure>

<p>再初始化测试的cache：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!afl-&gt;afl_env.afl_testcache_size || !afl-&gt;afl_env.afl_testcache_entries) &#123;<br>    afl-&gt;afl_env.afl_testcache_entries = <span class="hljs-number">0</span>;<br>    afl-&gt;afl_env.afl_testcache_size = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化forkserver超时时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.init_tmout = afl-&gt;fsrv.exec_tmout * FORK_WAIT_MULT; <span class="hljs-comment">// 初始化做过一次，重复执行了。</span><br></code></pre></td></tr></table></figure>

<p>为buf分配空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">afl_realloc(AFL_BUF_PARAM(in_scratch), min_alloc); <span class="hljs-comment">// in_scratch_buf</span><br>afl_realloc(AFL_BUF_PARAM(in), min_alloc);		<span class="hljs-comment">// in_buf</span><br>afl_realloc(AFL_BUF_PARAM(out_scratch), min_alloc);	<span class="hljs-comment">// out_scratch_buf</span><br>afl_realloc(AFL_BUF_PARAM(out), min_alloc);			<span class="hljs-comment">// out_buf</span><br>afl_realloc(AFL_BUF_PARAM(eff), min_alloc);			<span class="hljs-comment">// eff_buf</span><br>afl_realloc(AFL_BUF_PARAM(ex), min_alloc);			<span class="hljs-comment">// ex_buf</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.use_fauxsrv = afl-&gt;non_instrumented_mode == <span class="hljs-number">1</span> || afl-&gt;no_forkserver;<span class="hljs-comment">//给use_fauxsrv赋值为 afl-&gt;no_forkserver</span><br></code></pre></td></tr></table></figure>

<h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds()"></a>setup_dirs_fds()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.out_dir_fd = open(afl-&gt;out_dir, O_RDONLY);<br>afl-&gt;fsrv.plot_file = fdopen(fd, <span class="hljs-string">&quot;w&quot;</span>);<br>afl-&gt;fsrv.dev_null_fd = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>afl-&gt;fsrv.dev_urandom_fd = open(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, O_RDONLY);<br></code></pre></td></tr></table></figure>

<h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases()"></a>read_testcases()</h3><p>调用add_to_queue(),将当前输入添加到队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">  q-&gt;fname = fname;<br>  q-&gt;len = len;<br>  q-&gt;depth = afl-&gt;cur_depth + <span class="hljs-number">1</span>;<br>  q-&gt;passed_det = passed_det;<br>  q-&gt;trace_mini = <span class="hljs-literal">NULL</span>;<br>  q-&gt;testcase_buf = <span class="hljs-literal">NULL</span>;<br>  q-&gt;mother = afl-&gt;queue_cur;<br>afl-&gt;max_depth = q-&gt;depth;<br>afl-&gt;<span class="hljs-built_in">queue</span> = afl-&gt;queue_top = q;<br>afl-&gt;ready_for_splicing_count++; <span class="hljs-comment">// 0 -&gt; 2</span><br>  ++afl-&gt;queued_items;			<span class="hljs-comment">// 0 -&gt; 2</span><br>  ++afl-&gt;active_items;			<span class="hljs-comment">// 0 -&gt; 2</span><br>  ++afl-&gt;pending_not_fuzzed;	<span class="hljs-comment">// 0 -&gt; 2  因为初始输入中存在两个文件</span><br>  afl-&gt;cycles_wo_finds = <span class="hljs-number">0</span>;<br>afl-&gt;last_find_time = get_cur_time();<br></code></pre></td></tr></table></figure>

<p>最后，结束read_testcases()时。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">afl</span>-&gt;</span>last_find_time = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">afl</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">queued_at_start</span> = afl-&gt;</span>queued_items;<br></code></pre></td></tr></table></figure>

<p><code>afl-&gt;tmp_dir = afl-&gt;out_dir;</code></p>
<h3 id="确定-cur-input文件路径"><a href="#确定-cur-input文件路径" class="headerlink" title="确定.cur_input文件路径"></a>确定.cur_input文件路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.use_stdin = <span class="hljs-number">0</span>;<br>afl-&gt;fsrv.out_file = alloc_printf(<span class="hljs-string">&quot;%s/.cur_input&quot;</span>, afl-&gt;tmp_dir); <span class="hljs-comment">// &quot;/home/dog/fuzzing_xpdf/out/default/.cur_input&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary()"></a>check_binary()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.target_path = ck_strdup(fname); <span class="hljs-comment">// &quot;/home/dog/fuzzing_xpdf/build/bin/pdftotext&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="setup-testcase-shmem"><a href="#setup-testcase-shmem" class="headerlink" title="setup_testcase_shmem()"></a>setup_testcase_shmem()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;shm_fuzz = ck_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">sharedmem_t</span>));<br>afl-&gt;shm_fuzz-&gt;shmemfuzz_mode = <span class="hljs-number">1</span>;<br>shm-&gt;shm_id =<br>      shmget(IPC_PRIVATE, map_size == MAP_SIZE ? map_size + <span class="hljs-number">8</span> : map_size,<br>             IPC_CREAT | IPC_EXCL | DEFAULT_PERMISSION);<br>shm-&gt;<span class="hljs-built_in">map</span> = shmat(shm-&gt;shm_id, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>shm-&gt;map_size = map_size;<br></code></pre></td></tr></table></figure>

<p>主函数中执行了<code>afl-&gt;start_time = get_cur_time();afl-&gt;argv = use_argv;</code></p>
<h3 id="afl-shm-init"><a href="#afl-shm-init" class="headerlink" title="afl_shm_init()"></a>afl_shm_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.trace_bits =<br>    afl_shm_init(&amp;afl-&gt;shm, afl-&gt;fsrv.map_size, afl-&gt;non_instrumented_mode);<br></code></pre></td></tr></table></figure>

<p>为位图开辟了一个共享内存空间。</p>
<p>主函数执行以下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;fsrv.map_size = DEFAULT_SHMEM_SIZE;  <span class="hljs-comment">// dummy temporary value 其实没变</span><br><br><span class="hljs-built_in">memset</span>(afl-&gt;virgin_bits, <span class="hljs-number">255</span>, map_size); <span class="hljs-comment">// 为virgin_bits置255</span><br><span class="hljs-built_in">memset</span>(afl-&gt;virgin_tmout, <span class="hljs-number">255</span>, map_size); <span class="hljs-comment">//置255</span><br><span class="hljs-built_in">memset</span>(afl-&gt;virgin_crash, <span class="hljs-number">255</span>, map_size); <span class="hljs-comment">//置255</span><br></code></pre></td></tr></table></figure>

<h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run()"></a>perform_dry_run()</h3><p>遍历所有队列项，将队列项都dry_run完成后，需要重置一些数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>; idx &lt; afl-&gt;queued_items; idx++) &#123;<br>  q = afl-&gt;queue_buf[idx];<br>  <span class="hljs-keyword">if</span> (q &amp;&amp; !q-&gt;disabled &amp;&amp; q-&gt;len &gt; <span class="hljs-number">256</span>)&#123;<br>    u32 map_size = afl-&gt;fsrv.map_size;			<br>    q-&gt;virgin_bits = ck_alloc(map_size);		<span class="hljs-comment">// 将virgin_bits重置，以便下次运行时使用</span><br>    <span class="hljs-built_in">memset</span>(q-&gt;virgin_bits, <span class="hljs-number">255</span>, map_size);<br><br>    q-&gt;reset_times = ck_alloc(map_size);		<span class="hljs-comment">// 将reset_times重置。</span><br>    <span class="hljs-built_in">memset</span>(q-&gt;reset_times, <span class="hljs-number">0</span>, map_size);		<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q)&#123;<br>    q-&gt;initial_seed = <span class="hljs-number">0</span>;<br>    q-&gt;ancestor_seed = <span class="hljs-literal">NULL</span>;<br>    q-&gt;splice = <span class="hljs-number">1</span>;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case()"></a>calibrate_case()</h3><p>在calibrate_case函数中会有以下赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">q-&gt;exec_cksum = cksum;			<span class="hljs-comment">// 校验和赋值</span><br><span class="hljs-built_in">memcpy</span>(afl-&gt;first_trace, afl-&gt;fsrv.trace_bits, afl-&gt;fsrv.map_size);  <span class="hljs-comment">// 位图赋给first_trace</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;total_cal_us += diff_us;			<span class="hljs-comment">// 校验时间 </span><br>afl-&gt;total_cal_cycles += afl-&gt;stage_max;	<span class="hljs-comment">// 校验轮次</span><br>q-&gt;exec_us = diff_us / afl-&gt;stage_max;	<span class="hljs-comment">// 执行时间</span><br>q-&gt;bitmap_size = count_bytes(afl, afl-&gt;fsrv.trace_bits);	<span class="hljs-comment">// 位图大小</span><br>q-&gt;handicap = handicap;				<span class="hljs-comment">// 这个没变</span><br>q-&gt;cal_failed = <span class="hljs-number">0</span>;					<span class="hljs-comment">// 失败次数归0</span><br><br>afl-&gt;total_bitmap_size += q-&gt;bitmap_size;	<span class="hljs-comment">//总位图大小</span><br>++afl-&gt;total_bitmap_entries;				<span class="hljs-comment">// 位图数量+1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (new_bits == <span class="hljs-number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;		<span class="hljs-comment">// new_bits == 2说明发现了新的路径</span><br><br>    q-&gt;has_new_cov = <span class="hljs-number">1</span>;						<span class="hljs-comment">// 发现新边标志位置1</span><br>    ++afl-&gt;queued_with_cov;					<span class="hljs-comment">// 新覆盖字节的路径+1</span><br><br>  &#125;<br><span class="hljs-comment">// 要退出calibrate_case()函数了，因此恢复其特征标志。</span><br>  afl-&gt;stage_name = old_sn; 		<span class="hljs-comment">// &quot;init&quot;</span><br>  afl-&gt;stage_cur = old_sc;			<span class="hljs-comment">// 0</span><br>  afl-&gt;stage_max = old_sm;			<span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>



<h3 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits()"></a>has_new_bits()</h3><p>差异如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;read_flag &amp;&amp; afl-&gt;write_flag &amp;&amp; afl-&gt;mini_mode == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//开头多的</span><br>  afl-&gt;new_edges_found_idx = <span class="hljs-number">0</span>;			<span class="hljs-comment">// dryrun里，这个不会执行</span><br>&#125;<br>u32 tmp_edge = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">if</span> (unlikely(ret) &amp;&amp; likely(virgin_map == afl-&gt;virgin_bits))<span class="hljs-comment">// 结尾多的</span><br>  afl-&gt;bitmap_changed = <span class="hljs-number">1</span>;						<span class="hljs-comment">// dryrun里，这个会执行。</span><br></code></pre></td></tr></table></figure>



<h3 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score()"></a>update_bitmap_score()</h3><p>遍历位图的每一位，因为位图的每一位都代表着一个边，该位的值不为0，则代表边被覆盖，那么检查其top_rated是否存在。如果存在，那么使用AFLFast的方式更新top_rated[]数组；如果不存在，那么当前测试实例就暂时是其top_rated种子。queue队列的top_rated数组的每一位对应位图每一位。而该数组存储的是覆盖该路径的所有种子中的最好种子。</p>
<p>从perform_dry_run()结束后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (afl-&gt;q_testcase_max_cache_entries) &#123;<br><br>  afl-&gt;q_testcase_cache =<br>      ck_alloc(afl-&gt;q_testcase_max_cache_entries * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>));<br>  <span class="hljs-keyword">if</span> (!afl-&gt;q_testcase_cache) &#123; PFATAL(<span class="hljs-string">&quot;malloc failed for cache entries&quot;</span>); &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue()"></a>cull_queue()</h3><p>精简队列,获得一个能覆盖现有路径的最小queue_entry</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">  afl-&gt;queued_favored = <span class="hljs-number">0</span>;	<br>  afl-&gt;pending_favored = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 遍历队列，将当前所有测试实例的favored都变为0</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; afl-&gt;queued_items; i++) &#123;<br><br>    afl-&gt;queue_buf[i]-&gt;favored = <span class="hljs-number">0</span>;<br><br>  &#125;<br><span class="hljs-comment">// 迭代</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; afl-&gt;fsrv.map_size; ++i) &#123;<br>	<span class="hljs-comment">// 判断该位的路径有没有被设置</span><br>    <span class="hljs-keyword">if</span> (afl-&gt;top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="hljs-number">3</span>] &amp; (<span class="hljs-number">1</span> &lt;&lt; (i &amp; <span class="hljs-number">7</span>)))) &#123;<br>	<span class="hljs-comment">// 如果top_rated[i]有值，且该路径在temp_v里被置位了，则更新temp_v</span><br>      u32 j = len;<br><br>      <span class="hljs-comment">/* Remove all bits belonging to the current entry from temp_v. */</span><br><br>      <span class="hljs-keyword">while</span> (j--) &#123;<br>		<br>        <span class="hljs-keyword">if</span> (afl-&gt;top_rated[i]-&gt;trace_mini[j]) &#123;<br>			<br>          temp_v[j] &amp;= ~afl-&gt;top_rated[i]-&gt;trace_mini[j];<br><br>        &#125;<br><br>      &#125;<br>	<span class="hljs-comment">// 如果该条目之前没有被标记为favored，则标记并增加。</span><br>      <span class="hljs-keyword">if</span> (!afl-&gt;top_rated[i]-&gt;favored) &#123;<br>		<span class="hljs-comment">// 设置favored位1，queue_favored计数器+1</span><br>        afl-&gt;top_rated[i]-&gt;favored = <span class="hljs-number">1</span>;<br>        ++afl-&gt;queued_favored;<br>		<span class="hljs-comment">// 如果 WAS_FUZZED字段为0，代表其还没有被fuzz过，则将pending_favored计数器加一</span><br>        <span class="hljs-keyword">if</span> (!afl-&gt;top_rated[i]-&gt;was_fuzzed) &#123; ++afl-&gt;pending_favored; &#125;<br><br>      &#125;<br><br>    &#125;<br><br>  &#125;<br>	<span class="hljs-comment">// 遍历queue队列，标记队列中的冗余条目</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; afl-&gt;queued_items; i++) &#123;<br><br>    <span class="hljs-keyword">if</span> (likely(!afl-&gt;queue_buf[i]-&gt;disabled)) &#123;<br>		<br>      mark_as_redundant(afl, afl-&gt;queue_buf[i], !afl-&gt;queue_buf[i]-&gt;favored);<br><br>    &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure>



<h3 id="maybe-update-plot-file"><a href="#maybe-update-plot-file" class="headerlink" title="maybe_update_plot_file()"></a>maybe_update_plot_file()</h3><h3 id="主循环体"><a href="#主循环体" class="headerlink" title="主循环体"></a>主循环体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"> ++afl-&gt;queue_cycle;					<span class="hljs-comment">// cycle+1</span><br>runs_in_current_cycle = (u32)<span class="hljs-number">-1</span>;		<span class="hljs-comment">// 重置为(u32) - 1</span><br>afl-&gt;cur_skipped_items = <span class="hljs-number">0</span>;				<span class="hljs-comment">// 跳过测试用例数量置 0 </span><br><br>afl-&gt;cycles_wo_finds = <span class="hljs-number">0</span>;				<span class="hljs-comment">// 当前周期发现新路径的数量 置 0</span><br><br>runs_in_current_cycle++;				<span class="hljs-comment">// ++ 变成0了</span><br><br></code></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 调用完create_alias_table()函数后，会产生一个alias表，表中记录着测试实例的分数，与概率。</span><br>afl-&gt;current_entry = select_next_queue_entry(afl);	<span class="hljs-comment">// 根据alia算法，选出下一个种子</span><br>afl-&gt;queue_cur = afl-&gt;queue_buf[afl-&gt;current_entry];	<span class="hljs-comment">// 根据选出的种子，赋给当前queue</span><br></code></pre></td></tr></table></figure>



<h3 id="create-alias-table"><a href="#create-alias-table" class="headerlink" title="create_alias_table()"></a>create_alias_table()</h3><p> create the alias table that allows weighted random selection - expensive</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;alias_table =<br>    (u32 *)afl_realloc((<span class="hljs-type">void</span> **)&amp;afl-&gt;alias_table, n * <span class="hljs-keyword">sizeof</span>(u32));<br>afl-&gt;alias_probability = (<span class="hljs-type">double</span> *)afl_realloc(<br>    (<span class="hljs-type">void</span> **)&amp;afl-&gt;alias_probability, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br></code></pre></td></tr></table></figure>



<h3 id="fuzz-one-original"><a href="#fuzz-one-original" class="headerlink" title="fuzz_one_original()"></a>fuzz_one_original()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">  afl-&gt;subseq_tmouts = <span class="hljs-number">0</span>;				<span class="hljs-comment">// 超时数量</span><br><br>  afl-&gt;cur_depth = afl-&gt;queue_cur-&gt;depth;	<span class="hljs-comment">// 记录深度</span><br><br>  afl-&gt;stage_name = afl-&gt;stage_name_buf;	<span class="hljs-comment">// stage名称</span><br>  afl-&gt;bytes_trim_in += q-&gt;len;				<span class="hljs-comment">// 记录修剪字节数</span><br><br>afl-&gt;queue_cur-&gt;trim_done = <span class="hljs-number">1</span>;				<span class="hljs-comment">// 修剪结束标志</span><br></code></pre></td></tr></table></figure>

<p>在trim结束后，根据条件判断，进入聚类函数。以下是shapfuzz中的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c">u64 fuzz_time = ((afl-&gt;prev_run_time + get_cur_time() - afl-&gt;start_time) / <span class="hljs-number">1000</span>);  <br><span class="hljs-keyword">if</span>(afl-&gt;queued_items &gt; afl-&gt;centers_num &amp;&amp; (afl-&gt;queued_items &gt;= <span class="hljs-number">2</span> * afl-&gt;last_centers_realted_seeds))&#123;<br>    <span class="hljs-comment">// 聚类函数</span><br>  kmeans_main(afl);<br><br>  afl-&gt;last_centers_realted_seeds = afl-&gt;queued_items;<br>  afl-&gt;centers_gen_time = fuzz_time;<br><br>  <span class="hljs-keyword">for</span> (u32 c = <span class="hljs-number">0</span>; c &lt; afl-&gt;queued_items; c++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span> * <span class="hljs-title">cur_node</span> =</span> afl-&gt;queue_buf[c];<br>    <span class="hljs-keyword">if</span>(cur_node-&gt;initial_seed &amp;&amp; cur_node-&gt;mutated_pos_num != <span class="hljs-number">-1</span>)&#123;<br>      <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; cur_node-&gt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(cur_node-&gt;mutated_pos[i].flag &gt;= <span class="hljs-number">1</span>)&#123;<br>          M_free(cur_node-&gt;mutated_pos[i].A);<br>          M_free(cur_node-&gt;mutated_pos[i].b);<br><br>          cur_node-&gt;mutated_pos[i].A = M_I(afl-&gt;centers_num);<br>          cur_node-&gt;mutated_pos[i].b = M_Zeros(afl-&gt;centers_num,<span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(afl-&gt;centers_gen_time &gt; afl-&gt;queue_cur-&gt;vec_update_time)&#123;<br>  u32 map_size = afl-&gt;fsrv.map_size;<br>  <span class="hljs-type">float</span>* cur = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br>  <span class="hljs-built_in">memset</span>(cur, <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br><br>  common_fuzz_stuff(afl, out_buf, len);<br>  u32 j = <span class="hljs-number">0</span>;<br>  u8 *src = afl-&gt;fsrv.trace_bits;<br>  <span class="hljs-keyword">while</span> (j &lt; map_size) &#123;<br>    u8 v = *src;<br>    <span class="hljs-keyword">if</span>(v)&#123;<br>      cur[j] = (<span class="hljs-type">float</span>)v;<br>    &#125;<br>    src++;<br>    ++j;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;centers_num;i++)&#123;<br>    <span class="hljs-type">double</span> distance = (<span class="hljs-type">double</span>)cal_distance(cur, afl-&gt;centers[i], map_size);<br>    afl-&gt;queue_cur-&gt;feature_vec-&gt;data[i] = distance;<br>  &#125;<br><br>  afl-&gt;queue_cur-&gt;vec_update_time = afl-&gt;centers_gen_time;<br>  <br>&#125;<br><br><br><span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;len &gt; afl-&gt;max_len)&#123;<br>  <span class="hljs-keyword">if</span>(afl-&gt;history_mutation_sequence)&#123;<br>    <span class="hljs-built_in">free</span>(afl-&gt;history_mutation_sequence);<br>    <span class="hljs-built_in">free</span>(afl-&gt;new_mutation_sequence);<br>  &#125;<br><br>  afl-&gt;history_mutation_sequence = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>  afl-&gt;new_mutation_sequence = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br><br>  <span class="hljs-keyword">if</span>(afl-&gt;max_len != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">free</span>(afl-&gt;dataset_reward);<br>    <span class="hljs-built_in">free</span>(afl-&gt;hit_nums);<br>    <span class="hljs-built_in">free</span>(afl-&gt;tmp_mutated_pos);<br>    <span class="hljs-built_in">free</span>(afl-&gt;tmp_mutated_pos_flag);<br>  &#125;<br>  <br><br>  afl-&gt;dataset_reward = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  afl-&gt;hit_nums = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  afl-&gt;tmp_mutated_pos = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>  afl-&gt;tmp_mutated_pos_flag = (u8 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u8));<br><br>  afl-&gt;max_len = afl-&gt;queue_cur-&gt;len;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-built_in">memset</span>(afl-&gt;dataset_reward, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  <span class="hljs-built_in">memset</span>(afl-&gt;hit_nums, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  <span class="hljs-built_in">memset</span>(afl-&gt;tmp_mutated_pos_flag, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(u8));<br>&#125;<br>afl-&gt;history_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>afl-&gt;new_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>afl-&gt;tmp_mutated_pos_idx = <span class="hljs-number">0</span>;<br>afl-&gt;from_splicing = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">orig_perf = perf_score = afl-&gt;queue_cur-&gt;perf_score;<br></code></pre></td></tr></table></figure>



<h3 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case()"></a>trim_case()</h3><p>shapfuzz:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (q-&gt;len &lt; <span class="hljs-number">5</span>) &#123; <br>    <span class="hljs-comment">// 如果测试实例长度小于5，且是原始种子</span><br>  <span class="hljs-keyword">if</span>(q-&gt;initial_seed)&#123;<br><br>    <span class="hljs-keyword">if</span>(q-&gt;initial_seed)&#123;<br>        <br>      q-&gt;<span class="hljs-built_in">map</span> = (u64 *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(u64) * q-&gt;len);<br>        <span class="hljs-comment">// 初始化q-&gt;map为i</span><br>      <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; q-&gt;len;i++) (q-&gt;<span class="hljs-built_in">map</span>)[i] = (u64)i;<br>      q-&gt;mutated_pos = (<span class="hljs-keyword">struct</span> arm *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> arm) * q-&gt;len);<br>        <span class="hljs-comment">// 遍历当前队列项</span><br>      <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; q-&gt;len;i++)&#123;<br>          <span class="hljs-comment">// 初始化每一个字节</span><br>        q-&gt;mutated_pos[i].SV = <span class="hljs-number">0</span>;<br>        q-&gt;mutated_pos[i].add = <span class="hljs-number">0</span>;<br><br>        q-&gt;mutated_pos[i].flag = <span class="hljs-number">0</span>;<br>        q-&gt;mutated_pos[i].A = <span class="hljs-literal">NULL</span>;<br>        q-&gt;mutated_pos[i].b = <span class="hljs-literal">NULL</span>;<br>      &#125;<br>        <span class="hljs-comment">// 重置变异字节数量</span><br>      q-&gt;mutated_pos_num = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure>

<p>aflpp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (q-&gt;len &lt; <span class="hljs-number">5</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure>

<p>以xpdf为目标测试，修剪中目标程序执行了0x7F8次</p>
<h3 id="变量详解"><a href="#变量详解" class="headerlink" title="变量详解"></a>变量详解</h3><p>初始化后，正式执行中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//除却前面给变量分配看空间，并初始化0外，以下为xpdf测试期间，w模式开启下的变量修改位置与意义。</span><br><span class="hljs-comment">// afl-fuzz-one.c 4137行，函数fuzz_one_original()内</span><br>afl-&gt;write_flag = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// afl-fuzz-one.c 4141行，函数fuzz_one_original()内</span><br><span class="hljs-keyword">if</span>(cur_time &gt; <span class="hljs-number">1200</span>) afl-&gt;time_to_use_length_mutator = <span class="hljs-number">1</span>; <span class="hljs-comment">// 本次执行，变为1，因为cur_time=1331</span><br><span class="hljs-keyword">else</span> afl-&gt;time_to_use_length_mutator = <span class="hljs-number">0</span>;  <br><span class="hljs-comment">// afl-&gt;fuzz-one.c 4279行，函数fuzz_one_original()内</span><br>afl-&gt;use_splice_mutator = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 当一个种子的变异次数r在splice变异器区间的话，以下变量用于存储变异</span><br><span class="hljs-comment">// afl-&gt;fuzz-one.c 函数fuzz_one_original()内</span><br><span class="hljs-keyword">if</span>(afl-&gt;splice_num &lt; <span class="hljs-number">512</span>)&#123;<br>    afl-&gt;splice_stack[afl-&gt;splice_num][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-comment">// splice变异标志位</span><br>    afl-&gt;splice_stack[afl-&gt;splice_num][<span class="hljs-number">1</span>] = clone_to; <span class="hljs-comment">// 变异起始位置</span><br>    afl-&gt;splice_stack[afl-&gt;splice_num][<span class="hljs-number">2</span>] = clone_len;<span class="hljs-comment">// 变异长度</span><br>    afl-&gt;splice_num++;								  <span class="hljs-comment">// splice变异次数</span><br>&#125;<br><br><span class="hljs-comment">// afl-&gt;fuzz-one.c 418行，函数stat_analysis()内</span><br>afl-&gt;read_flag = <span class="hljs-number">1</span>;<br>afl-&gt;mini_mode = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 对每个必要字节:</span><br>u32 ii = (afl-&gt;queue_cur-&gt;<span class="hljs-built_in">map</span>)[i];<br><span class="hljs-comment">// 这里的afl-&gt;queue_cur-&gt;ancestor_seed代表着一个family，也指向某个初始种子。</span><br><span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].flag &lt; <span class="hljs-number">1</span>)&#123;<br>    afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].flag += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].flag &gt;= <span class="hljs-number">1</span>)&#123;<br>        afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].A = M_I(afl-&gt;centers_num);<br>        afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].b = M_Zeros(afl-&gt;centers_num,<span class="hljs-number">1</span>);<br>        afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos_num++;<br>    &#125;<br>&#125;<br>afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].add = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 在控制生成的测试实例数量每次循环后，会将对应变异模式所执行的数量+1</span><br><span class="hljs-keyword">if</span>(random_mode)&#123;			<span class="hljs-comment">// random_mode，后续还有两个模式，就不一一列举。</span><br>    afl-&gt;queue_cur-&gt;found_by_random++;<br>    afl-&gt;found_by_random_all++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上是第一次执行变异的过程所修改的变量，其中有大量路径没有执行，因为初始种子数量不够，无法生成中心种子。因此第一次执行是采取random_mode。接下来是第一次变异执行后的收尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">afl-&gt;write_flag = <span class="hljs-number">0</span>;	<span class="hljs-comment">// 写标志置0</span><br>new_hit_cnt = afl-&gt;queued_items + afl-&gt;saved_crashes;<br><span class="hljs-keyword">if</span> (!splice_cycle) &#123;	<span class="hljs-comment">// 当前不处于splice_cycle</span><br>    <span class="hljs-comment">// 用数组记录当前是哪个阶段，以及当前阶段所保存下来的测试实例数量，执行的测试实例数量。</span><br>    afl-&gt;stage_finds[STAGE_HAVOC] += new_hit_cnt - orig_hit_cnt;<br>  	afl-&gt;stage_cycles[STAGE_HAVOC] += afl-&gt;stage_max;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>接下来进入retry_splicing阶段</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_splicing:<br><span class="hljs-comment">// 根据fuzzing的执行时间，与队列周期决定要不要使用splice变异器</span><br>  <span class="hljs-keyword">if</span>(((afl-&gt;prev_run_time + get_cur_time() - afl-&gt;start_time) / <span class="hljs-number">1000</span>) &gt; <span class="hljs-number">1200</span> &amp;&amp; afl-&gt;queue_cycle &lt;= <span class="hljs-number">1</span>)&#123;<br>    u32 tmp = rand_below(afl, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">1</span>)&#123;<br>      afl-&gt;use_splicing = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      afl-&gt;use_splicing = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><strong>splice阶段</strong>，将种子池中的某个种子，进行拼接变异后，存入<code>afl-&gt;in</code>中，并跳转到<code>havoc_stage</code>对这个种子进行随机变异。</p>
<p><strong>进入splice_cycle中的havoc阶段</strong>，同样的havoc流程。本次执行了两次splicing_havoc。由一个随机值控制splicing_havoc的次数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span>(((afl-&gt;prev_run_time + get_cur_time() - afl-&gt;start_time) / <span class="hljs-number">1000</span>) &gt; <span class="hljs-number">1200</span> &amp;&amp; afl-&gt;queue_cycle &lt;= <span class="hljs-number">1</span>)&#123;<br>    u32 tmp = rand_below(afl, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">1</span>)&#123;<br>      afl-&gt;use_splicing = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      afl-&gt;use_splicing = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 在queue_cycle&gt;1后的周期内，都会置splice为1</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(afl-&gt;queue_cycle &gt; <span class="hljs-number">1</span>)&#123;<br>    afl-&gt;use_splicing = <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    afl-&gt;use_splicing = <span class="hljs-number">0</span>;<br>  &#125;<br><span class="hljs-comment">// 随后还有一个判断，slice_cycle要小于15，也就是不会连续splice_havoc变异超过15次。</span><br>  <span class="hljs-keyword">if</span> (afl-&gt;use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;<br>      afl-&gt;ready_for_splicing_count &gt; <span class="hljs-number">1</span> &amp;&amp; afl-&gt;queue_cur-&gt;len &gt;= <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<p><strong>然后进入abandon_entry阶段：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">abandon_entry:<br>  afl-&gt;splicing_with = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (!afl-&gt;stop_soon &amp;&amp; !afl-&gt;queue_cur-&gt;cal_failed &amp;&amp;<br>      !afl-&gt;queue_cur-&gt;was_fuzzed &amp;&amp; !afl-&gt;queue_cur-&gt;disabled) &#123;<br>	<br>    --afl-&gt;pending_not_fuzzed;				<span class="hljs-comment">// Queued but not done yet </span><br>    afl-&gt;queue_cur-&gt;was_fuzzed = <span class="hljs-number">1</span>;         <span class="hljs-comment">// historical, but needed for MOpt</span><br>    afl-&gt;reinit_table = <span class="hljs-number">1</span>;					<span class="hljs-comment">// reinit the queue weight table</span><br>    <span class="hljs-keyword">if</span> (afl-&gt;queue_cur-&gt;favored) &#123; --afl-&gt;pending_favored; &#125;<span class="hljs-comment">//Pending favored paths</span><br><br>  &#125;<br>++afl-&gt;queue_cur-&gt;fuzz_level;				<span class="hljs-comment">// Number of fuzzing iterations</span><br></code></pre></td></tr></table></figure>

<p><strong>重新一次循环阶段：</strong></p>
<p>在trimming之后，这一次会执行kmeans_main(afl)。</p>
<p><strong>kmeans_main(afl)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先会调用update_feature_map(afl)</span><br>update_feature_map(afl);<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">update_feature_map</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl)</span>&#123;<br>  u32 *ptr = (u32 *)afl-&gt;virgin_bits;		<span class="hljs-comment">// afl-&gt;virgin_bits记录着未被fuzzing区域</span><br>  u32  i = ((afl-&gt;fsrv.real_map_size + <span class="hljs-number">3</span>) &gt;&gt; <span class="hljs-number">2</span>);<br>  u32  ret = <span class="hljs-number">0</span>;<br>  u32 id = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(afl-&gt;feature_map, <span class="hljs-number">0</span>, afl-&gt;fsrv.map_size * <span class="hljs-keyword">sizeof</span>(u32));<br>  afl-&gt;num_edge = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 对于afl-&gt;virgin_bits中的每4个字节为单位进行判断</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    u32 v = *(ptr++);<br>	<br>    <span class="hljs-keyword">if</span> (likely(v == <span class="hljs-number">0xffffffffU</span>)) &#123;<br>      id +=<span class="hljs-number">4</span>;<br>      <span class="hljs-keyword">continue</span>; <br>    &#125;<br>    <span class="hljs-keyword">if</span> ((v &amp; <span class="hljs-number">0x000000ffU</span>) != <span class="hljs-number">0x000000ffU</span>) &#123;			<span class="hljs-comment">// 最低字节不等于ff</span><br>      afl-&gt;feature_map[id + <span class="hljs-number">0</span>] = afl-&gt;num_edge;<br>      afl-&gt;num_edge++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((v &amp; <span class="hljs-number">0x0000ff00U</span>) != <span class="hljs-number">0x0000ff00U</span>) &#123;			<span class="hljs-comment">// 次低字节不等于ff</span><br>      afl-&gt;feature_map[id + <span class="hljs-number">1</span>] = afl-&gt;num_edge;<br>      afl-&gt;num_edge++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((v &amp; <span class="hljs-number">0x00ff0000U</span>) != <span class="hljs-number">0x00ff0000U</span>) &#123;			<span class="hljs-comment">// 次高字节不等于ff</span><br>      afl-&gt;feature_map[id + <span class="hljs-number">2</span>] = afl-&gt;num_edge;<br>      afl-&gt;num_edge++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((v &amp; <span class="hljs-number">0xff000000U</span>) != <span class="hljs-number">0xff000000U</span>) &#123;			<span class="hljs-comment">// 最高字节不等于ff</span><br>      afl-&gt;feature_map[id + <span class="hljs-number">3</span>] = afl-&gt;num_edge;<br>      afl-&gt;num_edge++;<br>    &#125;<br><br>    id +=<span class="hljs-number">4</span>;<br>  &#125;<br><span class="hljs-comment">// 也就是说afl-&gt;num_edge记录着未被覆盖区域的每个不等于ff字节(或许是有效字节)的数量</span><br><span class="hljs-comment">// 并且afl-&gt;feature_map存储着，这个字节是第几个不等于ff的字节。</span><br>&#125; <span class="hljs-comment">// 本次执行后，afl-&gt;num_edge = 2061</span><br></code></pre></td></tr></table></figure>

<p>对feature_map进行更新后，除却一些初始化的操作以外。进入循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是内层循环，外层循环是循环1次，貌似永远执行一次，还不知循环的目的。内存循环遍历种子池队列queue_items</span><br>	<span class="hljs-keyword">for</span> (u32 i = <span class="hljs-number">0</span>; i &lt; observations_size; i++) &#123;<br>      u32 tid;<br>      tid = rand_below(afl, afl-&gt;queued_items);		<span class="hljs-comment">// 首先获得一个[0,queue_items-1]区间的随机数</span><br>      <span class="hljs-keyword">if</span> (likely(!afl-&gt;queue_buf[tid]-&gt;disabled)) &#123; <span class="hljs-comment">// 判断这个种子是否被设置禁用</span><br>        u8* out_buf = queue_testcase_get(afl, afl-&gt;queue_buf[tid]);  <span class="hljs-comment">// 获得这个种子的数据存入out_buf</span><br>        u32 len = afl-&gt;queue_buf[tid]-&gt;len;<br>        common_fuzz_stuff(afl, out_buf, len);				<span class="hljs-comment">// 以out_buf为输入，执行目标程序</span><br><br>        u32 j = <span class="hljs-number">0</span>;<br>        u8 *src = afl-&gt;fsrv.trace_bits;						<span class="hljs-comment">// 存着反馈信息，也就是更新后的位图</span><br>        <span class="hljs-keyword">while</span> (j &lt; map_size) &#123;<br>          u8 v = *src;										<span class="hljs-comment">// 遍历位图</span><br>          <span class="hljs-keyword">if</span>(v)&#123;											<span class="hljs-comment">// 对于覆盖的边</span><br>            u32 idx = afl-&gt;feature_map[j];					<span class="hljs-comment">// 未被探索的第几条边或者已经被探索则为0</span><br>            observations[i][idx] = (<span class="hljs-type">float</span>)v;				<span class="hljs-comment">// idx是未被探索的边的id</span><br>          &#125;													<span class="hljs-comment">// v是已经被探索的边的id</span><br>          src++;											<span class="hljs-comment">// 因此，observations记录着本次发现的新边在原未被探索边中的id，即记录哪些未被覆盖的边，经过这次执行，被覆盖了。</span><br>          ++j;<br>        &#125;<br>      &#125;<br>    &#125;<br>centers = km_new(observations, k, observations_size, vector_size); <span class="hljs-comment">// 调用km_new（开源库函数），得出中心节点</span><br></code></pre></td></tr></table></figure>

<p>算出中心节点后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>  <span class="hljs-keyword">if</span>(afl-&gt;centers[i]) <span class="hljs-built_in">free</span>(afl-&gt;centers[i]);				<span class="hljs-comment">// 如果这个中心节点为空的话，free掉空间。</span><br><br>  <span class="hljs-type">float</span>* tmp = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size); <br>  <span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; map_size;j++)&#123;						<span class="hljs-comment">// 遍历向量图，也就是位图那么大</span><br>    u32 idx = afl-&gt;feature_map[j];						<span class="hljs-comment">// 未探索边的id</span><br>    <span class="hljs-keyword">if</span>(centers[i][idx] != <span class="hljs-number">0</span>)&#123;								<span class="hljs-comment">// </span><br>      tmp[j] = centers[i][idx];							<span class="hljs-comment">// </span><br>    &#125; <br>  &#125;<br>  afl-&gt;centers[i] = tmp;									<span class="hljs-comment">// afl-&gt;centers保存的是中心种子的路径</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>随后释放observations的空间即退出<code>kmeans_main()</code>函数。</p>
<p>回到修剪后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;queued_items &gt; afl-&gt;centers_num &amp;&amp; (afl-&gt;queued_items &gt;= <span class="hljs-number">2</span> * afl-&gt;last_centers_realted_seeds))&#123;<br>  kmeans_main(afl);											<span class="hljs-comment">// 从这儿执行结束后，中心种子已经选取结束。</span><br><br>  afl-&gt;last_centers_realted_seeds = afl-&gt;queued_items;		<span class="hljs-comment">// 这个变量就记录着上一次计算中心种子用到的种子数量</span><br>  afl-&gt;centers_gen_time = fuzz_time;							<span class="hljs-comment">// 中心种子生成所消耗的时间</span><br><br>  <span class="hljs-keyword">for</span> (u32 c = <span class="hljs-number">0</span>; c &lt; afl-&gt;queued_items; c++) &#123;				<span class="hljs-comment">// 遍历种子池</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span> * <span class="hljs-title">cur_node</span> =</span> afl-&gt;queue_buf[c];		<span class="hljs-comment">// </span><br>    <span class="hljs-keyword">if</span>(cur_node-&gt;initial_seed &amp;&amp; cur_node-&gt;mutated_pos_num != <span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">//重置初始种子</span><br>      <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; cur_node-&gt;len;i++)&#123;						<span class="hljs-comment">// 遍历每个字节位置，重新初始化一些变量。</span><br>        <span class="hljs-keyword">if</span>(cur_node-&gt;mutated_pos[i].flag &gt;= <span class="hljs-number">1</span>)&#123;				<br>          M_free(cur_node-&gt;mutated_pos[i].A);<br>          M_free(cur_node-&gt;mutated_pos[i].b);<br><br>          cur_node-&gt;mutated_pos[i].A = M_I(afl-&gt;centers_num);<br>          cur_node-&gt;mutated_pos[i].b = M_Zeros(afl-&gt;centers_num,<span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>紧接着是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;centers_gen_time &gt; afl-&gt;queue_cur-&gt;vec_update_time)&#123;			<span class="hljs-comment">// 如果中心生成时间大于向量更新时间</span><br>  u32 map_size = afl-&gt;fsrv.map_size;<br>  <span class="hljs-type">float</span>* cur = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br>  <span class="hljs-built_in">memset</span>(cur, <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * map_size);<br><br>  common_fuzz_stuff(afl, out_buf, len);							<span class="hljs-comment">// 以in_buf(out_buf与in_buf相等)执行目标程序</span><br>  u32 j = <span class="hljs-number">0</span>;<br>  u8 *src = afl-&gt;fsrv.trace_bits;<br>  <span class="hljs-keyword">while</span> (j &lt; map_size) &#123;<br>    u8 v = *src;<br>    <span class="hljs-keyword">if</span>(v)&#123;<br>      cur[j] = (<span class="hljs-type">float</span>)v;										<span class="hljs-comment">// cur记录着已经覆盖的边</span><br>    &#125;<br>    src++;<br>    ++j;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;centers_num;i++)&#123;					<span class="hljs-comment">// 遍历每个中心种子</span><br>    <span class="hljs-type">double</span> distance = (<span class="hljs-type">double</span>)cal_distance(cur, afl-&gt;centers[i], map_size);<span class="hljs-comment">// 计算当前种子路径与中心种子路径的余弦相似度</span><br>    afl-&gt;queue_cur-&gt;feature_vec-&gt;data[i] = distance;						<span class="hljs-comment">// 特征向量feature_vec-&gt;data记录着余弦相似度</span><br>  &#125;<br><br>  afl-&gt;queue_cur-&gt;vec_update_time = afl-&gt;centers_gen_time;			<span class="hljs-comment">// 最后更新一下向量更新时间与中心种子生成时间一致</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后一个收尾工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;len &gt; afl-&gt;max_len)&#123;<br>  <span class="hljs-keyword">if</span>(afl-&gt;history_mutation_sequence)&#123;<br>    <span class="hljs-built_in">free</span>(afl-&gt;history_mutation_sequence);<br>    <span class="hljs-built_in">free</span>(afl-&gt;new_mutation_sequence);<br>  &#125;<br><br>  afl-&gt;history_mutation_sequence = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>  afl-&gt;new_mutation_sequence = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br><br>  <span class="hljs-keyword">if</span>(afl-&gt;max_len != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">free</span>(afl-&gt;dataset_reward);<br>    <span class="hljs-built_in">free</span>(afl-&gt;hit_nums);<br>    <span class="hljs-built_in">free</span>(afl-&gt;tmp_mutated_pos);<br>    <span class="hljs-built_in">free</span>(afl-&gt;tmp_mutated_pos_flag);<br>  &#125;<br>  <br><br>  afl-&gt;dataset_reward = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  afl-&gt;hit_nums = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  afl-&gt;tmp_mutated_pos = (u32 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u32));<br>  afl-&gt;tmp_mutated_pos_flag = (u8 *)<span class="hljs-built_in">calloc</span>(afl-&gt;queue_cur-&gt;len, <span class="hljs-keyword">sizeof</span>(u8));<br><br>  afl-&gt;max_len = afl-&gt;queue_cur-&gt;len;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-built_in">memset</span>(afl-&gt;dataset_reward, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  <span class="hljs-built_in">memset</span>(afl-&gt;hit_nums, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));<br>  <span class="hljs-built_in">memset</span>(afl-&gt;tmp_mutated_pos_flag, <span class="hljs-number">0</span>, afl-&gt;max_len * <span class="hljs-keyword">sizeof</span>(u8));<br>&#125;<br>afl-&gt;history_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>afl-&gt;new_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>afl-&gt;tmp_mutated_pos_idx = <span class="hljs-number">0</span>;<br>afl-&gt;from_splicing = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>收尾结束后，进入测试实例生成的循环中，会执行以下新代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;history_mode &amp;&amp; afl-&gt;queue_cur-&gt;ancestor_seed &amp;&amp; afl-&gt;from_splicing == <span class="hljs-number">0</span> &amp;&amp; afl-&gt;queue_cur-&gt;vec_update_time)&#123;<br>  generate_mutation_sequence(afl);									<span class="hljs-comment">// 生成变异序列</span><br>  <span class="hljs-keyword">if</span>(afl-&gt;history_mutation_sequence_idx)&#123;								<span class="hljs-comment">// 如果有变异字节出现</span><br>    history_able = <span class="hljs-number">1</span>;													<span class="hljs-comment">// histroy模式标志位</span><br>    history_mini_pos = temp_len;										<span class="hljs-comment">// temp_len为afl-&gt;cur_queue-&gt;len</span><br>    <span class="hljs-keyword">for</span>(u32 e = <span class="hljs-number">0</span>;e &lt; afl-&gt;history_mutation_sequence_idx;e++)&#123;		<span class="hljs-comment">// 遍历变异序列</span><br>      <span class="hljs-keyword">if</span>(history_mini_pos &gt; afl-&gt;history_mutation_sequence[e]) history_mini_pos = afl-&gt;history_mutation_sequence[e];											<span class="hljs-comment">// 找到一个位置最小的变异字节</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(afl-&gt;distribution) <span class="hljs-built_in">free</span>(afl-&gt;distribution);						<span class="hljs-comment">// 如果已经有分布，那么清空。</span><br>  afl-&gt;distribution = (<span class="hljs-type">double</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>) * afl-&gt;history_mutation_sequence_idx);<span class="hljs-comment">//分配空间</span><br>  <span class="hljs-built_in">memset</span>(afl-&gt;distribution, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>) * afl-&gt;history_mutation_sequence_idx);<span class="hljs-comment">// 初始化为0</span><br>  afl-&gt;distribution_sum = <span class="hljs-number">0</span>;													<span class="hljs-comment">// 置0</span><br>  afl-&gt;distribution_analyzed = <span class="hljs-number">0</span>;	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以下是<code>generate_mutation_sequence(afl);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">generate_mutation_sequence</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl)</span>&#123;<br>  afl-&gt;history_mutation_sequence_idx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;queue_cur-&gt;len;i++)&#123;<br>    u64 ii = (afl-&gt;queue_cur-&gt;<span class="hljs-built_in">map</span>)[i];							<span class="hljs-comment">// 在add_to_queue中将q-&gt;map[i]=i &#123;0..len&#125;</span><br>    <span class="hljs-keyword">if</span>(ii &gt; <span class="hljs-number">1000000</span> || ii &gt;= afl-&gt;queue_cur-&gt;ancestor_seed-&gt;len)&#123;<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <br>    <span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].flag &gt;= <span class="hljs-number">1</span>)&#123;<br>      afl-&gt;history_mutation_sequence[afl-&gt;history_mutation_sequence_idx] = i;	<span class="hljs-comment">// 这个记录的就是哪些位置的字节发生了变异</span><br>      afl-&gt;history_mutation_sequence_idx++;	<span class="hljs-comment">//记录着发生变异的数量</span><br>    &#125;<br>  &#125;<br>&#125;<span class="hljs-comment">// 本次执行afl-&gt;history_mutation_sequence_idx为217，意味着这个种子有217个字节位置发生了变异。它们的位置都被记录在afl-&gt;history_mutation_sequence数组中。</span><br></code></pre></td></tr></table></figure>

<p>接下来进入对同一个测试实例的变异次数循环体，由于之前history_able被设置为1了，因此执行以下代码段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(history_able == <span class="hljs-number">1</span> &amp;&amp; new_able == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 计算两个权重值</span><br>    weight_history = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_history / afl-&gt;queue_cur-&gt;exec_history;<br>    weight_random = <span class="hljs-number">1.0</span> * afl-&gt;queue_cur-&gt;found_by_random / afl-&gt;queue_cur-&gt;exec_random;<br>	<span class="hljs-comment">// 计算平均值</span><br>    <span class="hljs-type">double</span> average = <span class="hljs-number">1.0</span> * afl-&gt;found_all / afl-&gt;exec_all;<br>    <span class="hljs-keyword">if</span>(weight_history &lt; average * (<span class="hljs-number">0.7</span> + decrease) &amp;&amp; weight_random &lt; average * (<span class="hljs-number">0.7</span> + decrease))&#123;<br>       <span class="hljs-keyword">break</span>;<br>    &#125; <br>	<span class="hljs-comment">// </span><br>    history_line = weight_history;<br>    random_line = history_line + weight_random;<br>	<span class="hljs-comment">// 产生一个随机数</span><br>    <span class="hljs-type">double</span> tmp = ((<span class="hljs-type">double</span>)rand()/RAND_MAX) * random_line;<br>    <span class="hljs-keyword">if</span>(tmp &lt; weight_history) history_mode = <span class="hljs-number">1</span>;			<span class="hljs-comment">//如果随机数小于weight_history权重值，则进入history_mode，否则进入random_mode模式。</span><br>    <span class="hljs-keyword">else</span> random_mode = <span class="hljs-number">1</span>;					<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于本次执行时，随机数小于权重值，因此又进入了random_mode，则变异阶段结束后的<code>stat_analysis()</code>函数主体没有执行，执行以下分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">if</span>(afl-&gt;new_edges_found_idx == <span class="hljs-number">0</span> || afl-&gt;queue_cur-&gt;ancestor_seed == <span class="hljs-literal">NULL</span> || afl-&gt;use_splice_mutator || afl-&gt;from_splicing)&#123;<br>   afl-&gt;mini_mode = <span class="hljs-number">0</span>;    <br>   u32 after = count_non_255_bytes(afl, afl-&gt;virgin_bits);				<span class="hljs-comment">// 获得afl-&gt;virgin_bits中不是255的字节数量，表示覆盖的边的数量</span><br>   afl-&gt;queue_cur-&gt;found_edges += (after - afl-&gt;before);				<span class="hljs-comment">// afl-&gt;before存储的是执行之前的覆盖的边的数量，两个数值相减则得到本次fuzzing所得到的新覆盖的边的数量。</span><br>   afl-&gt;before = after;			<span class="hljs-comment">// 调整游标</span><br><span class="hljs-comment">// 如果当前种子splice置1，当前种子发现的新边大于8，并且当前种子的长度大于512</span><br>   <span class="hljs-comment">// 那么重置一些变量</span><br>   <span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;splice == <span class="hljs-number">1</span> &amp;&amp; afl-&gt;queue_cur-&gt;found_edges &gt; <span class="hljs-number">8</span> &amp;&amp; afl-&gt;queue_cur-&gt;len &gt; <span class="hljs-number">512</span>)&#123;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span>* <span class="hljs-title">q</span> =</span> afl-&gt;queue_cur;<br><br>     u32 map_size = afl-&gt;fsrv.map_size;<br>     q-&gt;virgin_bits = ck_alloc(map_size);<br>     <span class="hljs-built_in">memset</span>(q-&gt;virgin_bits, <span class="hljs-number">255</span>, map_size);<br><br>     q-&gt;reset_times = ck_alloc(map_size);<br>     <span class="hljs-built_in">memset</span>(q-&gt;reset_times, <span class="hljs-number">0</span>, map_size);<br><br>     q-&gt;initial_seed = <span class="hljs-number">1</span>;<br>     q-&gt;ancestor_seed = q;<br>     q-&gt;splice = <span class="hljs-number">0</span>;<br>     q-&gt;incre = <span class="hljs-number">1</span>;<br>     q-&gt;<span class="hljs-built_in">map</span> = (u64 *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(u64) * q-&gt;len);<br>     <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; q-&gt;len;i++) (q-&gt;<span class="hljs-built_in">map</span>)[i] = i;<br><br>     q-&gt;mutated_pos = (<span class="hljs-keyword">struct</span> arm *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> arm) * q-&gt;len);<br>     <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; q-&gt;len;i++)&#123;<br>       q-&gt;mutated_pos[i].flag = <span class="hljs-number">0</span>;<br>       q-&gt;mutated_pos[i].A = <span class="hljs-literal">NULL</span>;<br>       q-&gt;mutated_pos[i].b = <span class="hljs-literal">NULL</span>;<br>     &#125;<br>     q-&gt;mutated_pos_num = <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>接下来的循环，第二次执行就进入了history_mode，置history_mode为1，afl-&gt;record_flag为1。那么进入<code>stat_analysis</code>后，执行函数主体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;record_flag &amp;&amp; afl-&gt;tmp_mutated_pos_idx != <span class="hljs-number">0</span>)&#123;		<span class="hljs-comment">// record_flag表示执行非random_mode，tmp_mutated_pos_idx表示执行了update()函数，这个函数在进入变异算子的时候会执行。下面有对这个函数的具体解释。</span><br>    <span class="hljs-type">double</span> average_reward;<br>    <span class="hljs-keyword">if</span>(afl-&gt;queue_cur-&gt;n_fuzz_entry != afl-&gt;cur_n_fuzz_idx)&#123; <span class="hljs-comment">// 也就是当前队列种子的覆盖路径与上次执行的路径哈希不一致。即输入种子与变异后的种子覆盖路径不一致。</span><br>      average_reward = (<span class="hljs-number">1</span> - (<span class="hljs-type">double</span>)((<span class="hljs-type">double</span>)afl-&gt;n_fuzz[afl-&gt;cur_n_fuzz_idx] / (<span class="hljs-type">double</span>)afl-&gt;fsrv.total_execs))/(afl-&gt;tmp_mutated_pos_idx * afl-&gt;tmp_mutated_pos_idx);<span class="hljs-comment">// 使用公式计算收益</span><br>    &#125; <br>    <span class="hljs-keyword">else</span>&#123;<br>      average_reward = <span class="hljs-number">0</span>;<br>    &#125;<br>	<span class="hljs-comment">// 遍历当前种子所有变异字节</span><br>    <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>; i &lt; afl-&gt;tmp_mutated_pos_idx;i++)&#123;<br>      u32 target_pos = afl-&gt;tmp_mutated_pos[i];<br>      afl-&gt;dataset_reward[target_pos] += average_reward;	<span class="hljs-comment">// afl-&gt;dataset_reward存储着各个字节的收益</span><br>      afl-&gt;hit_nums[target_pos]++;							<span class="hljs-comment">// 记录着该字节执行分析的次数</span><br>      afl-&gt;dataset_size++;									<span class="hljs-comment">// 记录总共分析多少字节，也即dataset_reward的大小</span><br><br>      afl-&gt;tmp_mutated_pos_flag[target_pos] = <span class="hljs-number">0</span>;			<span class="hljs-comment">// 复原flag，以便下次执行</span><br>      afl-&gt;tmp_mutated_pos[i] = <span class="hljs-number">0</span>;							<span class="hljs-comment">// 复原</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(afl-&gt;tmp_mutated_pos_idx == <span class="hljs-number">0</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);				<span class="hljs-comment">// 没有变异字节，即退出</span><br>    afl-&gt;tmp_mutated_pos_idx = <span class="hljs-number">0</span>;							<span class="hljs-comment">// 遍历结束后，置0，便于下次执行判断。</span><br>  &#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl, u32 target_pos)</span>&#123;<br>  <span class="hljs-keyword">if</span>(afl-&gt;tmp_mutated_pos_flag[target_pos] == <span class="hljs-number">0</span>)&#123;					<span class="hljs-comment">// 给当前变异种子的位置标志置1</span><br>    afl-&gt;tmp_mutated_pos_flag[target_pos] = <span class="hljs-number">1</span>;						<span class="hljs-comment">// </span><br>    afl-&gt;tmp_mutated_pos[afl-&gt;tmp_mutated_pos_idx] = target_pos;	<span class="hljs-comment">// 记录变异位置，模拟一个队列</span><br>    afl-&gt;tmp_mutated_pos_idx++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果是Fast调度的话，那么会存在这个n_fuzz数据结构</span><br><span class="hljs-comment">// cksum是当前位图的Hash值</span><br><span class="hljs-comment">// n_fuzz存储着覆盖路径的执行次数</span><br><span class="hljs-keyword">if</span> (afl-&gt;n_fuzz[cksum % N_FUZZ_SIZE] &lt; <span class="hljs-number">0xFFFFFFFF</span>)<br> afl-&gt;n_fuzz[cksum % N_FUZZ_SIZE]++;<br>afl-&gt;cur_n_fuzz_idx = cksum % N_FUZZ_SIZE;		<span class="hljs-comment">// 存储最近一次执行的种子的路径hash值，也是n_fuzz的索引</span><br>afl-&gt;queue_top-&gt;n_fuzz_entry = cksum % N_FUZZ_SIZE;		<span class="hljs-comment">// n_fuzz_entry是种子的成员变量，因此该种子存储着路径在n_fuzz中的索引</span><br>afl-&gt;n_fuzz[afl-&gt;queue_top-&gt;n_fuzz_entry] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

</blockquote>
<p>O.o 终于到最后了！！！！根据概率分布选择变异字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c">u32 <span class="hljs-title function_">select_position_based_on_distribution</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl)</span>&#123;<br>  <span class="hljs-keyword">if</span>(afl-&gt;distribution_sum == <span class="hljs-number">0</span> &amp;&amp; afl-&gt;history_mutation_sequence_idx)&#123; <span class="hljs-comment">// distribution_sum为0，说明本次是第一次进行概率分布，afl-&gt;history_mutation_sequence_idx不为0，说明有变异字节</span><br>    afl-&gt;distribution_analyzed++;								<span class="hljs-comment">// 记录概率分布分析的次数</span><br><br>    <span class="hljs-type">double</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;history_mutation_sequence_idx;i++)&#123;  <span class="hljs-comment">// 遍历所有变异字节的位置</span><br>      u32 cur_pos = afl-&gt;history_mutation_sequence[i];			<span class="hljs-comment">// 将这个位置值赋予cur_pos</span><br><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span> * <span class="hljs-title">ancestor_node</span> =</span> afl-&gt;queue_cur-&gt;ancestor_seed;	<span class="hljs-comment">// 记录一个初始种子指向当前种子的初始种子</span><br>      u32 ii = (afl-&gt;queue_cur-&gt;<span class="hljs-built_in">map</span>)[cur_pos];								<span class="hljs-comment">// ii现在就等于cur_pos</span><br>      <span class="hljs-type">double</span> result;<br>      <span class="hljs-keyword">if</span>(ancestor_node-&gt;mutated_pos[ii].flag &gt;= <span class="hljs-number">1</span>)&#123;	<span class="hljs-comment">//如果初始种子的这个字节flag不为0，也就是该字节为必要字节</span><br>        Matrix* feature_vec_copy = Matrix_copy(afl-&gt;queue_cur-&gt;feature_vec);<span class="hljs-comment">// 复制一个特征矩阵，这个矩阵存储着余弦相似值，调用cal_distance函数得出。</span><br>        Matrix* A_copy = Matrix_copy(ancestor_node-&gt;mutated_pos[ii].A);		<span class="hljs-comment">// 复制该必要字节的A值</span><br>        Matrix* b_copy = Matrix_copy(ancestor_node-&gt;mutated_pos[ii].b);		<span class="hljs-comment">// 复制该必要字节的b值</span><br><br>        Matrix* A_Inverse = M_Inverse(A_copy);								<span class="hljs-comment">// A的逆矩阵</span><br>        Matrix* theta = M_mul(A_Inverse,b_copy);							<span class="hljs-comment">// A的逆矩阵与b矩阵相乘</span><br>        Matrix* theta_T = M_T(theta);										<span class="hljs-comment">// 乘矩阵的转置矩阵</span><br>        Matrix* r1 = M_mul(theta_T,feature_vec_copy);						<span class="hljs-comment">// 乘矩阵的转置矩阵与特征向量矩阵相乘</span><br><br>        Matrix* feature_vec_T = M_T(feature_vec_copy);						<span class="hljs-comment">// 特征向量矩阵的转置矩阵</span><br>        Matrix* m1 = M_mul(feature_vec_T,A_Inverse);						<span class="hljs-comment">// 转置矩阵与A逆矩阵相乘</span><br>        Matrix* m2 = M_mul(m1,feature_vec_copy);							<span class="hljs-comment">// 再与特征矩阵相乘</span><br>        <span class="hljs-type">double</span> m3 = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(m2-&gt;data[<span class="hljs-number">0</span>]);								<span class="hljs-comment">// m3等于0.5倍的根号m2[0]的值</span><br>        result = r1-&gt;data[<span class="hljs-number">0</span>] + m3 + ancestor_node-&gt;mutated_pos[ii].SV;	<span class="hljs-comment">// 计算公式。</span><br><br>        <span class="hljs-keyword">if</span>(m2-&gt;data[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> || isnan(result))&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;feature_vec_copy\n&quot;</span>);<br>          M_print(feature_vec_copy);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A_copy\n&quot;</span>);<br>          M_print(A_copy);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b_copy\n&quot;</span>);<br>          M_print(b_copy);<br><br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A_Inverse\n&quot;</span>);<br>          M_print(A_Inverse);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;theta\n&quot;</span>);<br>          M_print(theta);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;theta_T\n&quot;</span>);<br>          M_print(theta_T);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;r1\n&quot;</span>);<br>          M_print(r1);<br><br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;feature_vec_T\n&quot;</span>);<br>          M_print(feature_vec_T);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;m1\n&quot;</span>);<br>          M_print(m1);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;m2\n&quot;</span>);<br>          M_print(m2);<br>          <br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;m3:%lf\n&quot;</span>, m3);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result:%lf\n&quot;</span>, result);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        M_free(A_Inverse);<br>        M_free(theta);<br>        M_free(theta_T);<br>        M_free(r1);<br>        M_free(feature_vec_T);<br>        M_free(m1);<br>        M_free(m2);<br><br>        M_free(feature_vec_copy);<br>        M_free(A_copy);<br>        M_free(b_copy);<br><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>) result = <span class="hljs-number">0.05</span>;			<span class="hljs-comment">// 有一个最大下限</span><br>      tmp += result;						<span class="hljs-comment">// tmp用于累加所有的result值</span><br>      afl-&gt;distribution[i] = tmp;			<span class="hljs-comment">// 每个字节的分布值为当前字节的result</span><br>    &#125;<br>    afl-&gt;distribution_sum = tmp;			<span class="hljs-comment">// 将循环结束后的累加值赋予概率分布sum</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(afl-&gt;distribution_sum)&#123;				<span class="hljs-comment">// 若分布和不为0的话</span><br>    <span class="hljs-type">double</span> choose = ((<span class="hljs-type">double</span>)rand()/RAND_MAX) * afl-&gt;distribution_sum; <span class="hljs-comment">// 产生一个随机选择临界值choose</span><br>    <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;history_mutation_sequence_idx;i++)&#123;<br>      <span class="hljs-keyword">if</span>(afl-&gt;distribution[i] &gt;= choose)&#123;							<span class="hljs-comment">// 选择第一个概率权重值大于等于choose的字节</span><br>        <span class="hljs-keyword">return</span> afl-&gt;history_mutation_sequence[i];					<span class="hljs-comment">// 将这个字节返回</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// for(u32 i = 0;i &lt; afl-&gt;history_mutation_sequence_idx;i++)&#123;</span><br>    <span class="hljs-comment">//   printf(&quot;%u:%u -&gt; %f\n&quot;, i, afl-&gt;history_mutation_sequence[i], afl-&gt;distribution[i]);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">return</span> afl-&gt;cur_mutation_sequence[rand_below(afl, afl-&gt;cur_mutation_sequence_idx)];<span class="hljs-comment">// 找不到大于choose的字节，则在变异序列中随机返回一个字节</span><br>  &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 分布和为0的话，也随机返回一个字节。</span><br>    <span class="hljs-keyword">return</span> afl-&gt;cur_mutation_sequence[rand_below(afl, afl-&gt;cur_mutation_sequence_idx)];<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>对于A和b的说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在stat_analysis()中，对A和b的值作初始化</span><br>afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].A = M_I(afl-&gt;centers_num);<br>afl-&gt;queue_cur-&gt;ancestor_seed-&gt;mutated_pos[ii].b = M_Zeros(afl-&gt;centers_num,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></blockquote>
<p>最后，执行完分析后还有一段，对data_set的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(afl-&gt;dataset_size)&#123; <br>    <span class="hljs-type">float</span> max_reward = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> min_reward = <span class="hljs-number">999999999999999</span>;<br>    <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>; i &lt; afl-&gt;queue_cur-&gt;len;i++)&#123;<br>      <span class="hljs-keyword">if</span>(afl-&gt;hit_nums[i])&#123;												<span class="hljs-comment">// 记录着变异字节被变异的次数</span><br>        <span class="hljs-keyword">if</span>(afl-&gt;dataset_reward[i]/afl-&gt;hit_nums[i] &gt; max_reward) max_reward = afl-&gt;dataset_reward[i]/afl-&gt;hit_nums[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(afl-&gt;dataset_reward[i]/afl-&gt;hit_nums[i] &lt; min_reward) min_reward = afl-&gt;dataset_reward[i]/afl-&gt;hit_nums[i];<br>      &#125;																	<span class="hljs-comment">// 获得最大的R和最小的R(收益)</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(max_reward != <span class="hljs-number">0</span> &amp;&amp; min_reward != <span class="hljs-number">999999999999999</span> &amp;&amp; max_reward != min_reward)&#123;<br>      <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>; i &lt; afl-&gt;queue_cur-&gt;len;i++)&#123;			<span class="hljs-comment">// 遍历当前执行的初始种子每个字节</span><br>        <span class="hljs-keyword">if</span>(afl-&gt;hit_nums[i])&#123;								<br>          afl-&gt;dataset_reward[i] = (afl-&gt;dataset_reward[i]/afl-&gt;hit_nums[i] - min_reward)/(max_reward - min_reward);												<span class="hljs-comment">// 给每个字节的收益进行赋值</span><br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(max_reward != min_reward)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span> * <span class="hljs-title">ancestor_node</span> =</span> afl-&gt;queue_cur-&gt;ancestor_seed;<br>        u32 cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 这个循环是为了计算原始种子每个字节的mutated_pos[].A,mutated_pos[].b</span><br>        <span class="hljs-keyword">for</span>(u32 i = <span class="hljs-number">0</span>;i &lt; afl-&gt;queue_cur-&gt;len;i++)&#123;<br>          u32 ii = (afl-&gt;queue_cur-&gt;<span class="hljs-built_in">map</span>)[i];<br>          <span class="hljs-keyword">if</span>(ancestor_node-&gt;mutated_pos[ii].flag &gt;= <span class="hljs-number">1</span> &amp;&amp; afl-&gt;hit_nums[i])&#123;<br>            cnt++;<br>            Matrix* feature_vec_copy = Matrix_copy(afl-&gt;queue_cur-&gt;feature_vec);<br>            Matrix* feature_vec_T = M_T(feature_vec_copy);<br>            Matrix* Mul = M_mul(feature_vec_copy,feature_vec_T);<br>            Matrix* old = ancestor_node-&gt;mutated_pos[ii].A;<br>            ancestor_node-&gt;mutated_pos[ii].A = M_add_sub(<span class="hljs-number">1</span>,old, <span class="hljs-number">-1</span>,Mul);<br>            M_free(feature_vec_T);<br>            M_free(Mul);<br>            M_free(old);<br><br>            M_free(feature_vec_copy);<br>            feature_vec_copy = Matrix_copy(afl-&gt;queue_cur-&gt;feature_vec);<br>            Matrix* Mul_b = M_numul(feature_vec_copy, afl-&gt;dataset_reward[i]);<br>            Matrix* old_b = ancestor_node-&gt;mutated_pos[ii].b;<br>            ancestor_node-&gt;mutated_pos[ii].b = M_add_sub(<span class="hljs-number">1</span>,old_b, <span class="hljs-number">-1</span>,Mul_b);<br><br>            <span class="hljs-keyword">if</span>(isinf(ancestor_node-&gt;mutated_pos[ii].b-&gt;data[<span class="hljs-number">0</span>]))&#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;====== %u -&gt; b ======\n&quot;</span>, i);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;feature_vec_copy\n&quot;</span>);<br>              M_print(feature_vec_copy);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dataset_reward:%f\n&quot;</span>, afl-&gt;dataset_reward[i]);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Mul_b\n&quot;</span>);<br>              M_print(Mul_b);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old_b\n&quot;</span>);<br>              M_print(old_b);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ancestor_node-&gt;mutated_pos[ii].b\n&quot;</span>);<br>              M_print(ancestor_node-&gt;mutated_pos[ii].b);<br>              <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br><br>            M_free(Mul_b);<br>            M_free(old_b);<br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>







<p>Shapfuzz以C++重构思路：</p>
<ol>
<li><p>trimming后，进行判断是否计算中心种子</p>
<p>调用<code>kmeans_main()</code>函数，得到<code>afl-&gt;centers</code>，并且初始化<code>mutated_pos[].A</code>和<code>mutated_pos[].b</code></p>
</li>
<li><p>再根据中心的生成时间与特征向量矩阵的更新时间来决定是否对特征向量矩阵进行更新</p>
<p>更新主要是计算各个种子路径与中心种子的余弦相似度。</p>
</li>
<li><p>初始化后面Shapley分析要用到的成员变量</p>
<p>这里的if判断是为了确保分配的空间足够装得下种子</p>
</li>
<li><p>然后直接来到havoc_stage</p>
</li>
<li><p>进入变异循环体前，首先判断是否需要生成变异序列。</p>
<p>如果需要的话，那么调用<code>generate_mutation_sequence()</code>函数生成，并找到最小的变异位置。随后重置distribution数组，<code>distribution_sum</code>和<code>distribution_analyzed</code>。</p>
</li>
<li><p>进入变异生成测试实例循环体</p>
<p>首先计算decrease，然后进入模式的判断。random_mode是原本aflpp的，history_mode是使用Shapley的。</p>
<p>随后，确定好各个模式后，对相应变量初始化。</p>
</li>
<li><p>进入变异次数控制循环体</p>
<p>生成的随机数r会选择某个变异器进行变异。这里会调用<code>select_position_based_on_distribution()</code>函数，选择一个字节位置进行变异。</p>
</li>
<li><p>测试实例生成好后，执行即可。</p>
</li>
<li><p>执行完毕后，调用<code>stat_analysis()</code>函数</p>
<p>该函数对所有的必要字节进行操作，将其<code>mutated_pos[].A</code>和<code>mutated_pos[].b</code>和<code>mutated_pos[].flag</code>都计算得出。</p>
<p>随后，根据执行结果，势必有一些必要字节。对每一个必要字节都+<code>(float)afl-&gt;new_edges_found_idx/necessary_nums;</code>作为Shapley值。每一次执行的所有必要字节的Shapley Value是相同的。</p>
</li>
<li><p>本次执行的最后，有一个收尾工作。</p>
<p>如果本轮执行，使用到了Shapley分析，那么计算一下原始种子的A和b</p>
</li>
<li><p>进入下一测试实例生成轮次。即跳转到6，直至变异执行阶段结束后，进入下一轮次的选种策略。</p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Fuzz/" class="category-chain-item">Fuzz</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Fuzz/" class="print-no-link">#Fuzz</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>AFL使用与源码分析</div>
      <div>https://loboq1ng.github.io/2024/08/21/AFL使用与源码分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lobo Q1ng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/03/pwn-college-%E9%A2%98%E8%A7%A3/" title="pwn.college 题解">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">pwn.college 题解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-%E5%9F%BA%E7%A1%80/" title="二进制安全-基础">
                        <span class="hidden-mobile">二进制安全-基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
